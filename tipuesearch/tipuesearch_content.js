var tipuesearch = {"pages":[{"title":" Fortran-lang/stdlib ","text":"Fortran-lang/stdlib Fortran stdlib API Documentation Goals and Motivation Scope Code of Conduct License Warning This API documentation for the Fortran-lang/stdlib is a work in progress Note Use the navigation bar at the top of the screen to browse modules, procedures, source files, etc.\nThe listings near the bottom of the page are incomplete. Fortran stdlib API Documentation This is the main API documentation landing page generated by FORD .\nThe documentation for comment markup in source code, running FORD and the FORD project file are all maintained on the FORD wiki . Goals and Motivation The Fortran Standard, as published by the ISO (https://wg5-fortran.org/), does\nnot have a Standard Library. The goal of this project is to provide a community\ndriven and agreed upon de facto \"standard\" library for Fortran, called a\nFortran Standard Library ( stdlib ). We have a rigorous process how stdlib is\ndeveloped as documented in our Workflow . stdlib is both a\nspecification and a reference implementation. We are cooperating with the\nFortran Standards Committee (e.g., the effort started at the J3\ncommittee repository) and the plan is to continue working with the Committee in\nthe future (such as in the step 5. in the Workflow document), so\nthat if the Committee wants to standardize some feature already available in stdlib , it would\nbase it on stdlib 's implementation. Scope The goal of the Fortran Standard Library is to achieve the following general scope: Utilities (containers, strings, files, OS/environment integration, unit\n  testing & assertions, logging,  ...) Algorithms (searching and sorting, merging, ...) Mathematics (linear algebra, sparse matrices, special functions, fast Fourier\n  transform, random numbers, statistics, ordinary differential equations,\n  numerical integration, optimization, ...) Code of Conduct In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Please read first this Code of Conduct License The stdlib source code and related files and documentation are distributed under the MIT license . Developer Info fortran-lang/stdlib contributors","tags":"home","loc":"index.html"},{"title":"stdlib_stats_corr.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_corr.fypp~~EfferentGraph sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_linalg.fypp stdlib_linalg.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_linalg.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_corr Source Code stdlib_stats_corr.fypp Source Code #:include \"common.fypp\" #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_corr use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_linalg , only : diag use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( ${ k1 }$ ) :: res if (. not . optval ( mask , . true .) . or . size ( x ) < 2 ) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if res = 1 end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res if (. not . optval ( mask , . true .) . or . size ( x ) < 2 ) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if res = 1 end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) real ( ${ k1 }$ ) :: res if ( count ( mask ) < 2 ) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if res = 1 end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) real ( dp ) :: res if ( count ( mask ) < 2 ) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if res = 1 end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j ${ t1 }$ :: mean_ ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) ${ t1 }$ :: center ( size ( x , 1 ), size ( x , 2 )) if (. not . optval ( mask , . true .) . or . size ( x ) < 2 ) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if mean_ = mean ( x , dim ) select case ( dim ) case ( 1 ) do i = 1 , size ( x , 1 ) center ( i , :) = x ( i , :) - mean_ end do # : if t1 [ 0 ] == 'r' res = matmul ( transpose ( center ), center ) # : else res = matmul ( transpose ( conjg ( center )), center ) # : endif case ( 2 ) do i = 1 , size ( x , 2 ) center (:, i ) = x (:, i ) - mean_ end do # : if t1 [ 0 ] == 'r' res = matmul ( center , transpose ( center )) # : else res = matmul ( center , transpose ( conjg ( center ))) # : endif case default call error_stop ( \"ERROR (corr): wrong dimension\" ) end select mean_ = 1 / sqrt ( diag ( res )) do i = 1 , size ( res , 1 ) do j = 1 , size ( res , 2 ) res ( j , i ) = res ( j , i ) * mean_ ( i ) * mean_ ( j ) end do end do end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j real ( dp ) :: mean_ ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) real ( dp ) :: center ( size ( x , 1 ), size ( x , 2 )) if (. not . optval ( mask , . true .) . or . size ( x ) < 2 ) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if mean_ = mean ( x , dim ) select case ( dim ) case ( 1 ) do i = 1 , size ( x , 1 ) center ( i , :) = real ( x ( i , :), dp ) - mean_ end do res = matmul ( transpose ( center ), center ) case ( 2 ) do i = 1 , size ( x , 2 ) center (:, i ) = real ( x (:, i ), dp ) - mean_ end do res = matmul ( center , transpose ( center )) case default call error_stop ( \"ERROR (corr): wrong dimension\" ) end select mean_ = 1 / sqrt ( diag ( res )) do i = 1 , size ( res , 1 ) do j = 1 , size ( res , 2 ) res ( j , i ) = res ( j , i ) * mean_ ( i ) * mean_ ( j ) end do end do end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j ${ t1 }$ :: centeri_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) ${ t1 }$ :: centerj_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) logical :: mask_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) select case ( dim ) case ( 1 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask (:, i ) . and . mask (:, j )) centeri_ = merge ( x (:, i ) - mean ( x (:, i ), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) centerj_ = merge ( x (:, j ) - mean ( x (:, j ), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) res ( j , i ) = dot_product ( centerj_ , centeri_ )& / sqrt ( dot_product ( centeri_ , centeri_ ) * & dot_product ( centerj_ , centerj_ )) end do end do case ( 2 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask ( i , :) . and . mask ( j , :)) centeri_ = merge ( x ( i , :) - mean ( x ( i , :), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) centerj_ = merge ( x ( j , :) - mean ( x ( j , :), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) res ( j , i ) = dot_product ( centeri_ , centerj_ )& / sqrt ( dot_product ( centeri_ , centeri_ ) * & dot_product ( centerj_ , centerj_ )) end do end do case default call error_stop ( \"ERROR (corr): wrong dimension\" ) end select end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j real ( dp ) :: centeri_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) real ( dp ) :: centerj_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) logical :: mask_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) select case ( dim ) case ( 1 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask (:, i ) . and . mask (:, j )) centeri_ = merge ( x (:, i ) - mean ( x (:, i ), mask = mask_ ),& 0._dp , mask_ ) centerj_ = merge ( x (:, j ) - mean ( x (:, j ), mask = mask_ ),& 0._dp , mask_ ) res ( j , i ) = dot_product ( centerj_ , centeri_ )& / sqrt ( dot_product ( centeri_ , centeri_ ) * & dot_product ( centerj_ , centerj_ )) end do end do case ( 2 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask ( i , :) . and . mask ( j , :)) centeri_ = merge ( x ( i , :) - mean ( x ( i , :), mask = mask_ ),& 0._dp , mask_ ) centerj_ = merge ( x ( j , :) - mean ( x ( j , :), mask = mask_ ),& 0._dp , mask_ ) res ( j , i ) = dot_product ( centeri_ , centerj_ )& / sqrt ( dot_product ( centeri_ , centeri_ ) * & dot_product ( centerj_ , centerj_ )) end do end do case default call error_stop ( \"ERROR (corr): wrong dimension\" ) end select end function ${ RName }$ # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_corr.fypp.html"},{"title":"stdlib_stats_cov.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_cov.fypp~~EfferentGraph sourcefile~stdlib_stats_cov.fypp stdlib_stats_cov.fypp sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_cov Source Code stdlib_stats_cov.fypp Source Code #:include \"common.fypp\" #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_cov use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if res = var ( x , dim , corrected = optval ( corrected , . true .)) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if res = var ( x , dim , corrected = optval ( corrected , . true .)) end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res res = var ( x , dim , mask , corrected = optval ( corrected , . true .)) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) logical , intent ( in ), optional :: corrected real ( dp ) :: res res = var ( x , dim , mask , corrected = optval ( corrected , . true .)) end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i ${ t1 }$ :: mean_ ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) ${ t1 }$ :: center ( size ( x , 1 ), size ( x , 2 )) if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if mean_ = mean ( x , dim ) select case ( dim ) case ( 1 ) do i = 1 , size ( x , 1 ) center ( i , :) = x ( i , :) - mean_ end do # : if t1 [ 0 ] == 'r' res = matmul ( transpose ( center ), center ) # : else res = matmul ( transpose ( conjg ( center )), center ) # : endif case ( 2 ) do i = 1 , size ( x , 2 ) center (:, i ) = x (:, i ) - mean_ end do # : if t1 [ 0 ] == 'r' res = matmul ( center , transpose ( center )) # : else res = matmul ( center , transpose ( conjg ( center ))) # : endif case default call error_stop ( \"ERROR (cov): wrong dimension\" ) end select res = res / ( size ( x , dim ) - merge ( 1 , 0 , optval ( corrected , . true .))) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i real ( dp ) :: mean_ ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) real ( dp ) :: center ( size ( x , 1 ), size ( x , 2 )) if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if mean_ = mean ( x , dim ) select case ( dim ) case ( 1 ) do i = 1 , size ( x , 1 ) center ( i , :) = real ( x ( i , :), dp ) - mean_ end do res = matmul ( transpose ( center ), center ) case ( 2 ) do i = 1 , size ( x , 2 ) center (:, i ) = real ( x (:, i ), dp ) - mean_ end do res = matmul ( center , transpose ( center )) case default call error_stop ( \"ERROR (cov): wrong dimension\" ) end select res = res / ( size ( x , dim ) - merge ( 1 , 0 , optval ( corrected , . true .))) end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) logical , intent ( in ), optional :: corrected ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j , n ${ t1 }$ :: centeri_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) ${ t1 }$ :: centerj_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) logical :: mask_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) select case ( dim ) case ( 1 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask (:, i ) . and . mask (:, j )) centeri_ = merge ( x (:, i ) - mean ( x (:, i ), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) centerj_ = merge ( x (:, j ) - mean ( x (:, j ), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) n = count ( mask_ ) res ( j , i ) = dot_product ( centerj_ , centeri_ )& / ( n - merge ( 1 , 0 ,& optval ( corrected , . true .) . and . n > 0 )) end do end do case ( 2 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask ( i , :) . and . mask ( j , :)) centeri_ = merge ( x ( i , :) - mean ( x ( i , :), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) centerj_ = merge ( x ( j , :) - mean ( x ( j , :), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) n = count ( mask_ ) res ( j , i ) = dot_product ( centeri_ , centerj_ )& / ( n - merge ( 1 , 0 ,& optval ( corrected , . true .) . and . n > 0 )) end do end do case default call error_stop ( \"ERROR (cov): wrong dimension\" ) end select end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) logical , intent ( in ), optional :: corrected real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j , n real ( dp ) :: centeri_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) real ( dp ) :: centerj_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) logical :: mask_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) select case ( dim ) case ( 1 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask (:, i ) . and . mask (:, j )) centeri_ = merge ( x (:, i ) - mean ( x (:, i ), mask = mask_ ),& 0._dp , mask_ ) centerj_ = merge ( x (:, j ) - mean ( x (:, j ), mask = mask_ ),& 0._dp , mask_ ) n = count ( mask_ ) res ( j , i ) = dot_product ( centerj_ , centeri_ )& / ( n - merge ( 1 , 0 ,& optval ( corrected , . true .) . and . n > 0 )) end do end do case ( 2 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask ( i , :) . and . mask ( j , :)) centeri_ = merge ( x ( i , :) - mean ( x ( i , :), mask = mask_ ),& 0._dp , mask_ ) centerj_ = merge ( x ( j , :) - mean ( x ( j , :), mask = mask_ ),& 0._dp , mask_ ) n = count ( mask_ ) res ( j , i ) = dot_product ( centeri_ , centerj_ )& / ( n - merge ( 1 , 0 ,& optval ( corrected , . true .) . and . n > 0 )) end do end do case default call error_stop ( \"ERROR (cov): wrong dimension\" ) end select end function ${ RName }$ # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_cov.fypp.html"},{"title":"common.fypp – Fortran-lang/stdlib","text":"Contents Source Code common.fypp Source Code #:mute #! Real kinds to be considered during templating #:set REAL_KINDS = [\"sp\", \"dp\", \"qp\"] #! Real types to be considere during templating #:set REAL_TYPES = [\"real({})\".format(k) for k in REAL_KINDS] #! Collected (kind, type) tuples for real types #:set REAL_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES)) #! Complex kinds to be considered during templating #:set CMPLX_KINDS = [\"sp\", \"dp\", \"qp\"] #! Complex types to be considere during templating #:set CMPLX_TYPES = [\"complex({})\".format(k) for k in CMPLX_KINDS] #! Collected (kind, type) tuples for complex types #:set CMPLX_KINDS_TYPES = list(zip(CMPLX_KINDS, CMPLX_TYPES)) #! Integer kinds to be considered during templating #:set INT_KINDS = [\"int8\", \"int16\", \"int32\", \"int64\"] #! Integer types to be considere during templating #:set INT_TYPES = [\"integer({})\".format(k) for k in INT_KINDS] #! Collected (kind, type) tuples for integer types #:set INT_KINDS_TYPES = list(zip(INT_KINDS, INT_TYPES)) #! Whether Fortran 90 compatible code should be generated #:set VERSION90 = defined('VERSION90') #! Ranks to be generated when templates are created #:if not defined('MAXRANK') # : if VERSION90 # : set MAXRANK = 7 # : else # : set MAXRANK = 15 # : endif #:endif #! Generates an array rank suffix. #! #! Args: #!     rank (int): Rank of the variable #! #! Returns: #!     Array rank suffix string (e.g. (:,:) if rank = 2) #! #:def ranksuffix(rank) #{if rank > 0}#(${\":\" + \",:\" * (rank - 1)}$)#{endif}# #:enddef #! Joins stripped lines with given character string #! #! Args: #!   txt (str): Text to process #!   joinstr (str): String to use as connector #!   prefix (str): String to add as prefix before the joined text #!   suffix (str): String to add as suffix after the joined text #! #! Returns: #!   Lines stripped and joined with the given string. #! #:def join_lines(txt, joinstr, prefix=\"\", suffix=\"\") ${ prefix + joinstr . join ([ line . strip () for line in txt . split ( \"\\n\" )]) + suffix }$ #:enddef #! Brace enclosed, comma separated Fortran expressions for a reduced shape. #! #! Rank of the original variable will be reduced by one. The routine generates #! for each dimension a Fortan expression using merge(), which calculates the #! size of the array for that dimension. #! #! Args: #!   varname (str): Name of the variable to be used as origin #!   origrank (int): Rank of the original variable #!   idim (int): Index of the reduced dimension #! #! Returns: #!   Shape expression enclosed in braces, so that it can be used as suffix to #!   define array shapes in declarations. #! #:def reduced_shape(varname, origrank, idim) # : assert origrank > 0 # : if origrank > 1 # : call join_lines ( joinstr = \", \" , prefix = \"(\" , suffix = \")\" ) # : for i in range ( 1 , origrank ) merge ( size ( ${ varname }$ , ${ i }$ ), size ( ${ varname }$ , ${ i + 1 }$ ), mask = ${ i }$ < ${ idim }$ ) # : endfor # : endcall # : endif #:enddef #! Generates a routine name from a generic name, rank, type and kind #! #! Args: #!   gname (str): Generic name #!   rank (integer): Rank if exist #!   type (str): Type of the input #!   kind (str): kind of inputs variable #!   suffix (str): other identifier (could be used for output type/kind) #! #! Returns: #!   A string with a new name #! #:def rname(gname, rank, type, kind, suffix='') $ : \"{0}_{1}_{2}{3}_{2}{3}\" . format ( gname , rank , type [ 0 ], kind ) if suffix == '' else \"{0}_{1}_{2}{3}_{4}\" . format ( gname , rank , type [ 0 ], kind , suffix ) #:enddef #! Generates an array rank suffix for subarrays reducing the dimension #! #! Args: #!   rank (int): Rank of the original variable #!   selectors (array): Dimension and name of the variable(s) #! #! Returns: #!   Array rank suffix string enclosed in braces #! #! E.g., #!   select_subarray(5 , [(4, 'i'), (5, 'j')])}$ #!   -> (:, :, :, i, j) #! #:def select_subarray(rank, selectors) # : assert rank > 0 # : set seldict = dict ( selectors ) # : call join_lines ( joinstr = \", \" , prefix = \"(\" , suffix = \")\" ) # : for i in range ( 1 , rank + 1 ) $ : seldict . get ( i , \":\" ) # : endfor # : endcall #:enddef #:endmute","tags":"","loc":"sourcefile/common.fypp.html"},{"title":"stdlib_stats_moment.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_moment.fypp~~EfferentGraph sourcefile~stdlib_stats_moment.fypp stdlib_stats_moment.fypp sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_moment Source Code stdlib_stats_moment.fypp Source Code #:include \"common.fypp\" #:set RANKS = range(1, MAXRANK + 1) #:set REDRANKS = range(2, MAXRANK + 1) #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_moment use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order ${ t1 }$ , intent ( in ), optional :: center logical , intent ( in ), optional :: mask ${ t1 }$ :: res real ( ${ k1 }$ ) :: n if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if n = real ( size ( x , kind = int64 ), ${ k1 }$ ) if ( present ( center )) then res = sum (( x - center ) ** order ) / n else res = sum (( x - mean ( x )) ** order ) / n end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order real ( dp ), intent ( in ), optional :: center logical , intent ( in ), optional :: mask real ( dp ) :: res real ( dp ) :: n if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if n = real ( size ( x , kind = int64 ), dp ) if ( present ( center )) then res = sum (( real ( x , dp ) - center ) ** order ) / n else res = sum (( real ( x , dp ) - mean ( x )) ** order ) / n end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_scalar\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ) :: center logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum (( x - center ) ** order , dim ) / size ( x , dim ) else call error_stop ( \"ERROR (moment): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( ${ k1 }$ ) :: n ${ t1 }$ , allocatable :: mean_$ { ranksuffix ( rank - 1 ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if n = real ( size ( x , dim ), ${ k1 }$ ) res = 0 select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) if ( present ( center )) then do i = 1 , size ( x , ${ fi }$ ) res = res + ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - center ) ** order end do else allocate ( mean_ , source = mean ( x , ${ fi }$ )) do i = 1 , size ( x , ${ fi }$ ) res = res + ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean_ ) ** order end do deallocate ( mean_ ) end if # : endfor case default call error_stop ( \"ERROR (moment): wrong dimension\" ) end select res = res / n end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_scalar\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ) :: center logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum ( ( real ( x , dp ) - center ) ** order , dim ) / size ( x , dim ) else call error_stop ( \"ERROR (moment): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( dp ) :: n real ( dp ), allocatable :: mean_$ { ranksuffix ( rank - 1 ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if n = real ( size ( x , dim ), dp ) res = 0 select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) if ( present ( center )) then do i = 1 , size ( x , ${ fi }$ ) res = res + ( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - & center ) ** order end do else allocate ( mean_ , source = mean ( x , ${ fi }$ )) do i = 1 , size ( x , ${ fi }$ ) res = res + ( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - mean_ ) ** order end do deallocate ( mean_ ) end if # : endfor case default call error_stop ( \"ERROR (moment): wrong dimension\" ) end select res = res / n end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order ${ t1 }$ , intent ( in ), optional :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res real ( ${ k1 }$ ) :: n n = real ( count ( mask , kind = int64 ), ${ k1 }$ ) if ( present ( center )) then res = sum (( x - center ) ** order , mask ) / n else res = sum (( x - mean ( x , mask )) ** order , mask ) / n end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order real ( dp ), intent ( in ), optional :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res real ( dp ) :: n n = real ( count ( mask , kind = int64 ), dp ) if ( present ( center )) then res = sum (( real ( x , dp ) - center ) ** order , mask ) / n else res = sum (( real ( x , dp ) - mean ( x , mask )) ** order , mask ) / n end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_mask_scalar\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ) :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum (( x - center ) ** order , dim , mask ) / count ( mask , dim ) else call error_stop ( \"ERROR (moment): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( ${ k1 }$ ) :: n$ { reduced_shape ( 'x' , rank , 'dim' ) }$ ${ t1 }$ , allocatable :: mean_$ { ranksuffix ( rank - 1 ) }$ n = real ( count ( mask , dim ), ${ k1 }$ ) res = 0 select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) if ( present ( center )) then do i = 1 , size ( x , ${ fi }$ ) res = res + merge ( ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - & center ) ** order ,& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do else allocate ( mean_ , source = mean ( x , ${ fi }$ , mask )) do i = 1 , size ( x , ${ fi }$ ) res = res + merge ( ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean_ ) ** order ,& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do deallocate ( mean_ ) end if # : endfor case default call error_stop ( \"ERROR (moment): wrong dimension\" ) end select res = res / n end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_mask_scalar\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ) :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum (( real ( x , dp ) - center ) ** order , dim , mask ) / count ( mask , dim ) else call error_stop ( \"ERROR (moment): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( dp ) :: n$ { reduced_shape ( 'x' , rank , 'dim' ) }$ real ( dp ), allocatable :: mean_$ { ranksuffix ( rank - 1 ) }$ n = real ( count ( mask , dim ), dp ) res = 0 select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) if ( present ( center )) then do i = 1 , size ( x , ${ fi }$ ) res = res + merge (( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - & center ) ** order ,& 0._dp , mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do else allocate ( mean_ , source = mean ( x , ${ fi }$ , mask )) do i = 1 , size ( x , ${ fi }$ ) res = res + merge (( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - mean_ )& ** order ,& 0._dp , mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do deallocate ( mean_ ) end if # : endfor case default call error_stop ( \"ERROR (moment): wrong dimension\" ) end select res = res / n end function ${ RName }$ # : endfor # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_moment.fypp.html"},{"title":"stdlib_linalg.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_linalg.fypp~~EfferentGraph sourcefile~stdlib_linalg.fypp stdlib_linalg.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_linalg.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_linalg.fypp~~AfferentGraph sourcefile~stdlib_linalg.fypp stdlib_linalg.fypp sourcefile~stdlib_linalg_diag.fypp stdlib_linalg_diag.fypp sourcefile~stdlib_linalg_diag.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_linalg.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_linalg Source Code stdlib_linalg.fypp Source Code #:include \"common.fypp\" #:set RCI_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES + INT_KINDS_TYPES module stdlib_linalg !!Provides a support for various linear algebra procedures !! ([Specification](../page/specs/stdlib_linalg.html)) use stdlib_kinds , only : sp , dp , qp , & int8 , int16 , int32 , int64 implicit none private public :: diag public :: eye public :: trace interface diag !! version: experimental !! !! Creates a diagonal array or extract the diagonal elements of an array !! ([Specification](../page/specs/stdlib_linalg.html#description)) ! ! Vector to matrix ! # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$ ( v ) result ( res ) ${ t1 }$ , intent ( in ) :: v (:) ${ t1 }$ :: res ( size ( v ), size ( v )) end function diag_$ { t1 [ 0 ] }{ k1 }$ # : endfor # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ k ( v , k ) result ( res ) ${ t1 }$ , intent ( in ) :: v (:) integer , intent ( in ) :: k ${ t1 }$ :: res ( size ( v ) + abs ( k ), size ( v ) + abs ( k )) end function diag_$ { t1 [ 0 ] }{ k1 }$_ k # : endfor ! ! Matrix to vector ! # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ mat ( A ) result ( res ) ${ t1 }$ , intent ( in ) :: A (:,:) ${ t1 }$ :: res ( minval ( shape ( A ))) end function diag_$ { t1 [ 0 ] }{ k1 }$_ mat # : endfor # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ mat_k ( A , k ) result ( res ) ${ t1 }$ , intent ( in ) :: A (:,:) integer , intent ( in ) :: k ${ t1 }$ :: res ( minval ( shape ( A )) - abs ( k )) end function diag_$ { t1 [ 0 ] }{ k1 }$_ mat_k # : endfor end interface ! Matrix trace interface trace !! version: experimental !! !! Computes the trace of a matrix !! ([Specification](../page/specs/stdlib_linalg.html#description_2)) # : for k1 , t1 in RCI_KINDS_TYPES module procedure trace_$ { t1 [ 0 ] }{ k1 }$ # : endfor end interface contains function eye ( n ) result ( res ) !! version: experimental !! !! Constructs the identity matrix !! ([Specification](../page/specs/stdlib_linalg.html#description_1)) integer , intent ( in ) :: n integer ( int8 ) :: res ( n , n ) integer :: i res = 0 do i = 1 , n res ( i , i ) = 1 end do end function eye # : for k1 , t1 in RCI_KINDS_TYPES function trace_$ { t1 [ 0 ] }{ k1 }$ ( A ) result ( res ) ${ t1 }$ , intent ( in ) :: A (:,:) ${ t1 }$ :: res integer :: i res = 0 do i = 1 , minval ( shape ( A )) res = res + A ( i , i ) end do end function trace_$ { t1 [ 0 ] }{ k1 }$ # : endfor end module","tags":"","loc":"sourcefile/stdlib_linalg.fypp.html"},{"title":"stdlib_optval.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_optval.fypp~~EfferentGraph sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_optval.fypp~~AfferentGraph sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_cov.fypp stdlib_stats_cov.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_mean.fypp stdlib_stats_mean.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_logger.f90 stdlib_logger.f90 sourcefile~stdlib_logger.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_moment.fypp stdlib_stats_moment.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_io.fypp stdlib_io.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_var.fypp stdlib_stats_var.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~f18estop.f90 f18estop.f90 sourcefile~f18estop.f90->sourcefile~stdlib_error.f90 sourcefile~stdlib_quadrature_trapz.fypp stdlib_quadrature_trapz.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_quadrature_simps.fypp stdlib_quadrature_simps.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_error.f90 sourcefile~f08estop.f90 f08estop.f90 sourcefile~f08estop.f90->sourcefile~stdlib_error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_optval Source Code stdlib_optval.fypp Source Code #:include \"common.fypp\" #:set KINDS_TYPES = REAL_KINDS_TYPES + INT_KINDS_TYPES + CMPLX_KINDS_TYPES + & & [( 'l1' , 'logical' )] module stdlib_optval !! !! Provides a generic function `optval`, which can be used to !! conveniently implement fallback values for optional arguments !! to subprograms !! ([Specification](../page/specs/stdlib_optval.html)) !! !! If `x` is an `optional` parameter of a !! subprogram, then the expression `optval(x, default)` inside that !! subprogram evaluates to `x` if it is present, otherwise `default`. !! !! It is an error to call `optval` with a single actual argument. !! use stdlib_kinds , only : sp , dp , qp , int8 , int16 , int32 , int64 implicit none private public :: optval interface optval !! version: experimental !! !! Fallback value for optional arguments !! ([Specification](../page/specs/stdlib_optval.html#description)) # : for k1 , t1 in KINDS_TYPES module procedure optval_$ { t1 [ 0 ] }{ k1 }$ # : endfor module procedure optval_character ! TODO: differentiate ascii & ucs char kinds end interface optval contains # : for k1 , t1 in KINDS_TYPES pure elemental function optval_$ { t1 [ 0 ] }{ k1 }$ ( x , default ) result ( y ) ${ t1 }$ , intent ( in ), optional :: x ${ t1 }$ , intent ( in ) :: default ${ t1 }$ :: y if ( present ( x )) then y = x else y = default end if end function optval_$ { t1 [ 0 ] }{ k1 }$ # : endfor ! Cannot be made elemental pure function optval_character ( x , default ) result ( y ) character ( len =* ), intent ( in ), optional :: x character ( len =* ), intent ( in ) :: default character ( len = :), allocatable :: y if ( present ( x )) then y = x else y = default end if end function optval_character end module stdlib_optval","tags":"","loc":"sourcefile/stdlib_optval.fypp.html"},{"title":"stdlib_logger.f90 – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_logger.f90~~EfferentGraph sourcefile~stdlib_logger.f90 stdlib_logger.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_logger.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_ascii.f90 stdlib_ascii.f90 sourcefile~stdlib_logger.f90->sourcefile~stdlib_ascii.f90 sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_logger Source Code stdlib_logger.f90 Source Code module stdlib_logger !!### Module stdlib_logger !! !! This module defines a derived type, procedures, a variable, and !! constants to be used for logging information and reporting errors !! in Fortran applications. !!([Specification](../page/specs/stdlib_logger.html)) !! The derived type, `logger_type`, is to be used to define variables to !! serve as both local and global loggers. A logger directs its messages !! to selected I/O units so the user has a record (a log) of major events. !! For each entity of `logger_type` the reports go to a list of I/O units !! represented by the private internal array, `log_units`. If `log_units` is !! empty then output by default goes to `output_unit`. Otherwise reports !! go to `output_unit` only if it has been explicitly added to `log_units`. !! Each entity of type `logger_type` also maintains an internal state !! controlling the formatting of output. !! !! The procedures are as follows. The logical function !! `log_units_assigned` returns the number of I/O units in `log_units`. The !! subroutines `add_log_file` and `add_log_unit` include the specified file !! in `log_units`. `remove_log_units` removes the specified logical unit from !! the `log_units` array and optionally closes the file. `configure` !! configures the details of the logging process. `configuration` !! reports the details of that configuration. The subroutines !! `log_error`, `log_information`, `log_io_error`, `log_message`, !! `log_text_error`, and `log_warning` send messages to the log units. !! !! The variable `global_logger` of type `logger_type` can be used !! as a default global logger anywhere in the source code. !! !! The constants are used to report errors by some of the subroutines !! in their optional `stat` arguments. The constants are as follows. !! `success` indicates that no error has occurred. `close_failure` !! indicates that a `close` statement for an I/O unit failed. !! `index_invalid_error` indicates that `column` was invalid for !! the given `line`. `open_failure` indicates that an `open` statement !! failed. `read_only_error` indicates that an output unit did not have a !! `\"write\"` or `\"readwrite\"` action. `non_sequential_error` indicates !! that the unit did not have `sequential` access. `unformatted_in_error` !! indicates that the unit did not have a `form` of `\"formatted\"`. !! `unopened_in_error` indicates that the unit was not opened. `write_failure` !! indicates that at least one of the writes to `log_units` failed. use , intrinsic :: & iso_fortran_env , only : & error_unit , & input_unit , & output_unit use stdlib_ascii , only : to_lower use stdlib_optval , only : optval implicit none private public :: global_logger , logger_type !! public constants used as error flags integer , parameter , public :: & success = 0 , & close_failure = 1 , & index_invalid_error = 2 , & non_sequential_error = 3 , & open_failure = 4 , & read_only_error = 5 , & unformatted_in_error = 6 , & unopened_in_error = 7 , & write_failure = 8 character ( * ), parameter :: module_name = 'stdlib_logger' type :: logger_type !! version: experimental !! Public derived type ([Specification](../page/specs/stdlib_logger.html#the-derived-type-logger_type)) private logical :: add_blank_line = . false . logical :: indent_lines = . true . integer , allocatable :: log_units (:) integer :: max_width = 0 logical :: time_stamp = . true . integer :: units = 0 contains private procedure , public , pass ( self ) :: add_log_file procedure , public , pass ( self ) :: add_log_unit procedure , public , pass ( self ) :: configuration procedure , public , pass ( self ) :: configure procedure , public , pass ( self ) :: log_error procedure , public , pass ( self ) :: log_information procedure , public , pass ( self ) :: log_io_error procedure , public , pass ( self ) :: log_message procedure , public , pass ( self ) :: log_text_error procedure , public , pass ( self ) :: log_units_assigned procedure , public , pass ( self ) :: log_warning procedure , public , pass ( self ) :: remove_log_unit final :: final_logger end type logger_type !! Variable of type `logger_type` to be used as a global logger type ( logger_type ) :: global_logger character ( * ), parameter :: & invalid_column = 'column is not a valid index to line.' contains subroutine add_log_file ( self , filename , unit , action , position , status , & stat ) !! version: experimental !! Opens a formatted sequential access output file, `filename` using !! `newunit` and adds the resulting unit number to `self`'s `log_units` !! array. `action`, if present, is the `action` specifier of the `open` !! statement, and has the default value of `\"write\"`. `position`, if present, !! is the `position` specifier, and has the default value of `\"REWIND\"`. !! `status`, if present, is the `status` specifier of the `open` statement, and !! has the default value of `\"REPLACE\"`. `stat`, if present, has the value !! `success` if `filename` could be opened, `read_only_error` if `action` is !! `\"read\"`, and `open_failure` otherwise. !!([Specification](../page/specs/stdlib_logger.html#add_log_file-open-a-file-and-add-its-unit-to-self-log_units)) class ( logger_type ), intent ( inout ) :: self !! The logger variable to which the file is to be added character ( * ), intent ( in ) :: filename !! The name of the file to be  added to the logger integer , intent ( out ), optional :: unit !! The resulting I/O unit number character ( * ), intent ( in ), optional :: action !! The `action` specifier for the `open`` statement character ( * ), intent ( in ), optional :: position !! The `position` specifier for the `open` statement character ( * ), intent ( in ), optional :: status !! The `status` specifier for the  `open`  statement integer , intent ( out ), optional :: stat !! The error status on exit with the possible values !! * `success` - no errors found !! * `Rrea_only_error` - file unopened as `action1 was `\"read\"` for an output file !! * `open_failure` - the `open` statement failed !!##### Example !! !!     program main !!         use stdlib_logger !!         ... !!         integer :: unit, stat !!         ... !!         call global_logger % add_log_file( 'error_log.txt', unit,      & !!                                            position='asis', stat=stat ) !!         if ( stat /= success ) then !!             error stop 'Unable to open \"error_log.txt\".' !!         end if !!         ... !!     end program main character ( 16 ) :: aaction , aposition , astatus integer :: aunit character ( 128 ) :: iomsg integer :: iostat character ( * ), parameter :: procedure_name = 'add_log_file' integer , allocatable :: dummy (:) integer :: lun integer :: i aaction = optval ( action , 'write' ) aposition = optval ( position , 'rewind' ) astatus = optval ( status , 'replace' ) if ( len_trim ( aaction ) == 4 ) then do i = 1 , 4 aaction ( i : i ) = to_lower ( aaction ( i : i )) end do if ( aaction == 'read' ) then if ( present ( stat ) ) then stat = read_only_error return else error stop 'In ' // module_name // ' % ' // & procedure_name // ' action is \"read\" which ' // & 'does not allow writes to the file.' end if end if end if open ( newunit = aunit , file = filename , form = 'formatted' , action = aaction , & position = aposition , status = astatus , iostat = iostat , iomsg = iomsg , & err = 999 ) if ( allocated ( self % log_units ) ) then if ( size ( self % log_units ) == self % units ) then allocate ( dummy ( 2 * self % units ) ) do lun = 1 , self % units dummy ( lun ) = self % log_units ( lun ) end do dummy ( self % units + 1 :) = 0 call move_alloc ( dummy , self % log_units ) end if else allocate ( self % log_units ( 16 ) ) end if self % log_units ( self % units + 1 ) = aunit self % units = self % units + 1 if ( present ( unit ) ) unit = aunit if ( present ( stat ) ) stat = success return 999 if ( present ( stat ) ) then stat = open_failure return else call self % log_io_error ( 'Unable to open ' // trim ( filename ), & module = module_name , & procedure = procedure_name , & iostat = iostat , & iomsg = iomsg ) error stop module_name // ' % ' // procedure_name // & ': Unable to open file' end if end subroutine add_log_file subroutine add_log_unit ( self , unit , stat ) !! version: experimental !! Adds `unit` to the log file units in `log_units`. `unit` must be an `open` !! file, of `form` `\"formatted\"`, with `\"sequential\"` `access`, and an `action` of !! `\"write\"` or `\"readwrite\"`, otherwise either `stat`, if preseent, has a !! value other than `success` and `unit` is not entered into `log_units`, !! or, if `stat` is not presecn, processing stops. !!([Specification](../page/specs/stdlib_logger.html#add_log_unit-add-a-unit-to-the-array-self-log_units)) class ( logger_type ), intent ( inout ) :: self !! The logger variable to which the I/O unit is to be added integer , intent ( in ) :: unit !! The input logical unit number integer , intent ( out ), optional :: stat !! An error code with the possible values !! * `success` - no problems were found !! * `non_sequential_error` - `unit` did not have sequential access !! * `read_only_error` - `unit` was not writeable !! * `unformatted_in_error` - `unit` was an `'unformatted'` file !! * `unopened_in_error` - `unit` was not opened !!##### Example !! !!     program main !!         use stdlib_logger !!         ... !!         character(256) :: iomsg !!         integer :: iostat, unit, stat !!         ... !!         open( newunit=unit, 'error_log.txt', form='formatted', & !!               status='replace', position='rewind', err=999,  & !!               action='read', iostat=iostat, iomsg=iomsg ) !!         ... !!         call global_logger % add_log_unit( unit, stat ) !!         select case ( stat ) !!         ... !!         case ( read_only_error ) !!             error stop 'Unable to write to \"error_log.txt\".' !!         ... !!         end select !!         ... !!     999 error stop 'Unable to open \"error_log.txt\". !!         ... !!     end program main integer , allocatable :: dummy (:) character ( * ), parameter :: procedure_name = 'set_log_unit' integer :: lun character ( 12 ) :: specifier logical :: question call validate_unit () if ( present ( stat ) ) then if ( stat /= success ) return end if do lun = 1 , self % units ! Check that unit is not already registered if ( self % log_units ( lun ) == unit ) return end do if ( allocated ( self % log_units ) ) then if ( size ( self % log_units ) == self % units ) then allocate ( dummy ( 2 * self % units ) ) do lun = 1 , self % units dummy ( lun ) = self % log_units ( lun ) end do call move_alloc ( dummy , self % log_units ) end if else allocate ( self % log_units ( 16 ) ) end if self % log_units ( self % units + 1 ) = unit self % units = self % units + 1 contains subroutine validate_unit () ! Check that unit is not input_unit if ( unit == input_unit ) then if ( present ( stat ) ) then stat = read_only_error return else error stop 'unit in ' // module_name // ' % ' // & procedure_name // ' must not be input_unit.' end if end if ! Check that unit is opened inquire ( unit , opened = question ) if ( . not . question ) then if ( present ( stat ) ) then stat = unopened_in_error return else error stop 'unit in ' // module_name // ' % ' // & procedure_name // ' is not open.' end if end if ! Check that unit is writeable inquire ( unit , write = specifier ) if ( specifier ( 1 : 1 ) /= 'Y' . and . specifier ( 1 : 1 ) /= 'y' ) then if ( present ( stat ) ) then stat = read_only_error return else error stop 'unit in ' // module_name // ' % ' // & procedure_name // ' is not writeable.' end if end if inquire ( unit , sequential = specifier ) if ( specifier ( 1 : 1 ) /= 'Y' . and . specifier ( 1 : 1 ) /= 'y' ) then if ( present ( stat ) ) then stat = non_sequential_error return else error stop 'unit in ' // module_name // ' % ' // & procedure_name // ' is not \"sequential\".' end if end if inquire ( unit , formatted = specifier ) if ( specifier ( 1 : 1 ) /= 'Y' . and . specifier ( 1 : 1 ) /= 'y' ) then if ( present ( stat ) ) then stat = unformatted_in_error return else error stop 'unit in ' // module_name // ' % ' // & procedure_name // ' is not \"formatted\".' end if end if if ( present ( stat ) ) stat = success end subroutine validate_unit end subroutine add_log_unit pure subroutine configuration ( self , add_blank_line , indent , & max_width , time_stamp , log_units ) !! version: experimental !! Reports the logging configuration of `self`. The following attributes are !! reported: !! 1. `add_blank_line` is a logical flag with `.true.` implying that output !!    starts with a blank line, and `.false.` implying no blank line. !! 2. `indent` is a logical flag with `.true.` implying that subsequent columns !!    will be indented 4 spaces and `.false.` implying no indentation. !! 3. `max_width` is the maximum number of columns of output text with !!    `max_width` == 0 => no bounds on output width. !! 4. `time_stamp` is a logical flag with `.true.` implying that the output !!    will have a time stamp, and `.false.` implying that there will be no !!    time stamp. !! 5. `log_units` is an array of the I/O unit numbers to which log output !!    will be written. !!([Specification](../page/specs/stdlib_logger.html#configuration-report-a-loggers-configuration)) class ( logger_type ), intent ( in ) :: self !! The logger variable whose configuration is being reported logical , intent ( out ), optional :: add_blank_line !! A logical flag to add a preceding blank line logical , intent ( out ), optional :: indent !! A logical flag to indent subsequent lines integer , intent ( out ), optional :: max_width !! The maximum number of columns for most outputs logical , intent ( out ), optional :: time_stamp !! A logical flag to add a time stamp integer , intent ( out ), allocatable , optional :: log_units (:) !! The I/O units used in output !!##### Example !! !!     module example_mod !!       use stdlib_logger !!       ... !!     contains !!       ... !!       subroutine example_sub(unit, ...) !!         integer, intent(in) :: unit !!         ... !!         integer, allocatable :: log_units(:) !!         ... !!         call global_logger % configuration( log_units=log_units ) !!         if ( size(log_units) == 0 ) then !!            call add_logger_unit( unit ) !!         end if !!         .. !!       end subroutine example_sub !!       ... !!     end module example_mod if ( present ( add_blank_line ) ) add_blank_line = self % add_blank_line if ( present ( indent ) ) indent = self % indent_lines if ( present ( max_width ) ) max_width = self % max_width if ( present ( time_stamp ) ) time_stamp = self % time_stamp if ( present ( log_units ) ) log_units = self % log_units ( 1 : self % units ) end subroutine configuration pure subroutine configure ( self , add_blank_line , indent , max_width , & time_stamp ) !! version: experimental !! Configures the logging process for SELF. The following attributes are !! configured: !! 1. `add_blank_line` is a logical flag with `.true.` implying that output !!    starts with a blank line, and `.false.` implying no blank line. !!    `add_blank_line` has a startup value of `.false.`. !! 2. `indent` is a logical flag with `.true.` implying that subsequent lines !!    will be indented 4 spaces and `.false.` implying no indentation. `indent` !!    has a startup value of `.true.`. !! 3. `max_width` is the maximum number of columns of output text with !!    `max_width == 0` => no bounds on output width. `max_width` has a startup !!    value of 0. !! 4. `time_stamp` is a logical flag with `.true.` implying that the output !!    will have a time stamp, and `.false.` implying that there will be no !!    time stamp. `time_stamp` has a startup value of `.true.`. !!([Specification](../page/specs/stdlib_logger.html#configure-configure-the-logging-process)) !!##### Example !! !!     program main !!         use stdlib_logger !!         ... !!         call global_logger % configure( indent=.false., max_width=72 ) !!         ... class ( logger_type ), intent ( inout ) :: self logical , intent ( in ), optional :: add_blank_line logical , intent ( in ), optional :: indent integer , intent ( in ), optional :: max_width logical , intent ( in ), optional :: time_stamp if ( present ( add_blank_line ) ) self % add_blank_line = add_blank_line if ( present ( indent ) ) self % indent_lines = indent if ( present ( max_width ) ) then if ( max_width <= 4 ) then self % max_width = 0 else self % max_width = max_width end if end if if ( present ( time_stamp ) ) self % time_stamp = time_stamp end subroutine configure subroutine final_logger ( self ) !! version: experimental !! Finalizes the `logger_type` entity `self` by flushing the units type ( logger_type ), intent ( in ) :: self integer :: iostat character ( 256 ) :: message integer :: unit do unit = 1 , self % units flush ( self % log_units ( unit ), iomsg = message , iostat = iostat ) if ( iostat /= 0 ) then write ( error_unit , '(a, i0)' ) 'In the logger_type finalizer ' // & 'an error occurred in flushing unit = ' , & self % log_units ( unit ) write ( error_unit , '(a, i0)' ) 'With iostat = ' , iostat write ( error_unit , '(a)' ) 'With iomsg = ' // trim ( message ) end if end do end subroutine final_logger subroutine format_output_string ( self , unit , string , procedure_name , & col_indent ) !! version: experimental !! Writes the STRING to UNIT ensuring that the number of characters !! does not exceed MAX_WIDTH and that the lines after the first !! one are indented four characters. class ( logger_type ), intent ( in ) :: self integer , intent ( in ) :: unit character ( * ), intent ( in ) :: string character ( * ), intent ( in ) :: procedure_name character ( * ), intent ( in ) :: col_indent integer :: count , indent_len , index_ , iostat , length , remain character ( 256 ) :: iomsg length = len_trim ( string ) indent_len = len ( col_indent ) call format_first_line () if ( self % indent_lines ) then do while ( remain > 0 ) call indent_format_subsequent_line () end do else do while ( remain > 0 ) call format_subsequent_line () end do end if contains subroutine format_first_line () if ( self % max_width == 0 . or . & ( length <= self % max_width . and . & index ( string ( 1 : length ), new_line ( 'a' )) == 0 ) ) then write ( unit , '(a)' , err = 999 , iostat = iostat , iomsg = iomsg ) & string ( 1 : length ) remain = 0 return else index_ = index ( string ( 1 : min ( length , self % max_width )), new_line ( 'a' )) if ( index_ == 0 ) then do index_ = self % max_width , 1 , - 1 if ( string ( index_ : index_ ) == ' ' ) exit end do end if if ( index_ == 0 ) then write ( unit , '(a)' , err = 999 , iostat = iostat , iomsg = iomsg ) & string ( 1 : self % max_width ) count = self % max_width remain = length - count return else write ( unit , '(a)' , err = 999 , iostat = iostat , iomsg = iomsg ) & string ( 1 : index_ - 1 ) count = index_ remain = length - count return end if end if 999 call handle_write_failure ( unit , procedure_name , iostat , iomsg ) end subroutine format_first_line subroutine format_subsequent_line () if ( remain <= self % max_width ) then write ( unit , '(a)' , err = 999 , iostat = iostat , iomsg = iomsg ) & string ( count + 1 : length ) count = length remain = 0 return else index_ = count + index ( string ( count + 1 : count + self % max_width ), & new_line ( 'a' )) if ( index_ == count ) then do index_ = count + self % max_width , count + 1 , - 1 if ( string ( index_ : index_ ) == ' ' ) exit end do end if if ( index_ == count ) then write ( unit , '(a)' , err = 999 , iostat = iostat , iomsg = iomsg ) & string ( count + 1 : count + self % max_width ) count = count + self % max_width remain = length - count return else write ( unit , '(a)' , err = 999 , iostat = iostat , iomsg = iomsg ) & string ( count + 1 : index_ - 1 ) count = index_ remain = length - count return end if end if 999 call handle_write_failure ( unit , procedure_name , iostat , iomsg ) end subroutine format_subsequent_line subroutine indent_format_subsequent_line () if ( index ( string ( count + 1 : length ), new_line ( 'a' )) == 0 . and . & remain <= self % max_width - indent_len ) then write ( unit , '(a)' , err = 999 , iostat = iostat , iomsg = iomsg ) & col_indent // string ( count + 1 : length ) count = length remain = 0 return else index_ = count + index ( string ( count + 1 : & min ( length , count + self % max_width - indent_len ) ), & new_line ( 'a' )) if ( index_ == count ) then do index_ = count + self % max_width - indent_len , count + 1 , - 1 if ( string ( index_ : index_ ) == ' ' ) exit end do end if if ( index_ == count ) then write ( unit , '(a)' , err = 999 , iostat = iostat , iomsg = iomsg ) & col_indent // & string ( count + 1 : count + self % max_width - indent_len ) count = count + self % max_width - indent_len remain = length - count return else write ( unit , '(a)' , err = 999 , iostat = iostat , iomsg = iomsg ) & col_indent // string ( count + 1 : index_ - 1 ) count = index_ remain = length - count return end if end if 999 call handle_write_failure ( unit , procedure_name , iostat , iomsg ) end subroutine indent_format_subsequent_line end subroutine format_output_string subroutine handle_write_failure ( unit , procedure_name , iostat , iomsg ) !! version: experimental !! Handles a failure to write to `unit` in `procedure_name` with `iostat` and !! `iomsg` by writing a description of the failure to `output_unit` and !! stopping. integer , intent ( in ) :: unit character ( * ), intent ( in ) :: procedure_name integer , intent ( in ) :: iostat character ( * ), intent ( in ) :: iomsg character ( 256 ) :: name logical :: named character ( 10 ) :: action write ( output_unit , '(a)' ) 'write failure in ' // module_name // & ' % ' // trim ( procedure_name ) // '.' write ( output_unit , '(a, i0)' ) 'unit = ' , unit inquire ( unit , named = named ) if ( named ) then inquire ( unit , name = name ) write ( output_unit , '(a, a)' ) 'name = ' , trim ( name ) else write ( output_unit , '(a)' ) 'unit is unnamed' end if inquire ( unit , action = action ) write ( output_unit , '(a, a)' ) 'action = ' , trim ( action ) write ( output_unit , '(a, i0)' ) 'iostat = ' , iostat write ( output_unit , '(a, a )' ) 'iomsg = ' , trim ( iomsg ) error stop 'write failure in ' // module_name // '.' end subroutine handle_write_failure subroutine log_error ( self , message , module , procedure , stat , errmsg ) !! version: experimental !! Writes the string `message` to `self % log_units` with optional additional !! text. !! ([Specification](../specs/stdlib_logger.html#log_error-writes-the-string-message-to-self-log_units)) !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by !! `module` and `procedure` if present, then `message` is !! written with the prefix 'ERROR: ', and then if `stat` or `errmsg` !! are present they are written. !! !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       real, allocatable :: a(:) !!       ... !!       type(logger_type) :: alogger !!       ... !!     contains !!       ... !!       subroutine example_sub( size ) !!         integer, intent(in) :: size !!         character(128) :: errmsg, message !!         integer        :: stat !!         allocate( a(size), stat=stat, errmsg=errmsg ) !!         if ( stat /= 0 ) then !!           write( message, `(a, i0)' )                    & !!               \"Allocation of A failed with SIZE = \", size !!           alogger % call log_error( message,                   & !!                                     module = 'EXAMPLE_MOD',    & !!                                     procedure = 'EXAMPLE_SUB', & !!                                     stat = stat,               & !!                                     errmsg = errmsg ) !!         end if !!       end subroutine example_sub !!       ... !!     end module example_mod !! class ( logger_type ), intent ( in ) :: self !! The logger to be used in logging the message character ( len =* ), intent ( in ) :: message !! A string to be written to log_unit character ( len =* ), intent ( in ), optional :: module !! The name of the module contining the current invocation of `log_error` character ( len =* ), intent ( in ), optional :: procedure !! The name of the procedure contining the current invocation of `log_error` integer , intent ( in ), optional :: stat !! The value of the `stat` specifier returned by a Fortran statement character ( len =* ), intent ( in ), optional :: errmsg !! The value of the `errmsg` specifier returned by a Fortran statement integer :: unit integer :: iostat character ( * ), parameter :: procedure_name = 'log_error' character ( 256 ) :: iomsg call self % log_message ( message , & module = module , & procedure = procedure , & prefix = 'ERROR' ) if ( self % units == 0 ) then call write_log_error ( output_unit ) else do unit = 1 , self % units call write_log_error ( self % log_units ( unit ) ) end do end if contains subroutine write_log_error ( unit ) integer , intent ( in ) :: unit if ( present ( stat ) ) then write ( unit , '(\"With stat = \", i0)' , err = 999 , & iostat = iostat , iomsg = iomsg ) stat end if if ( present ( errmsg ) ) then if ( len_trim ( errmsg ) > 0 ) then call format_output_string ( self , unit , & 'With errmsg = \"' // & trim ( errmsg ) // '\"' , & procedure_name , & '    ' ) end if end if return 999 call handle_write_failure ( unit , procedure_name , iostat , iomsg ) end subroutine write_log_error end subroutine log_error subroutine log_information ( self , message , module , procedure ) !! version: experimental !! Writes the string `message` to `self % log_units` with optional additional !! text. !!([Specification](../page/specs/stdlib_logger.html#log_information-writes-the-string-message-to-self-log_units)) !! !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by !! `module` and `procedure` if present, and then `message` is !! written with the prefix 'INFO: '. !! !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       real, allocatable :: a(:) !!       ... !!       type(logger_type) :: alogger !!       ... !!     contains !!       ... !!       subroutine example_sub( selection ) !!         integer, intent(out) :: selection !!         integer        :: stat !!         write(*,'(a)') \"Enter an integer to select a widget\" !!         read(*,'(i0)') selection !!         write( message, `(a, i0)' )           & !!               \"The user selected \", selection !!         call alogger % log_information( message,                   & !!                                         module = 'EXAMPLE_MOD',    & !!                                         procedure = 'EXAMPLE_SUB' ) !!         ... !!       end subroutine example_sub !!       ... !!     end module example_mod !! class ( logger_type ), intent ( in ) :: self !! The logger used to send the message character ( len =* ), intent ( in ) :: message !! A string to be written to log_unit character ( len =* ), intent ( in ), optional :: module !! The name of the module contining the current invocation of `log_information` character ( len =* ), intent ( in ), optional :: procedure !! The name of the procedure contining the current invocation of `log_information` call self % log_message ( message , & module = module , & procedure = procedure , & prefix = 'INFO' ) end subroutine log_information subroutine log_io_error ( self , message , module , procedure , iostat , & iomsg ) !! version: experimental !! Writes the string `message` to the `self % log_units` with optional !! additional text. !!([Specification](../page/specs/stdlib_logger.html#log_io_error-write-the-string-message-to-self-log_units)) !! !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by !! `module` and `procedure` if present, then `message` is !! written with a prefix 'I/O ERROR: ', and then if `iostat` or `iomsg` !! are present they are also written. !! !!##### Example !! !!    program example !!      use stdlib_logger !!      ... !!      character(*), parameter :: filename = 'dummy.txt' !!      integer                 :: iostat, lun !!      character(128)          :: iomsg !!      character(*), parameter :: message = 'Failure in opening \"dummy.txt\".' !! !!      open( newunit=lun, file = filename, form='formatted', & !!            status='old', iostat=iostat, iomsg=iomsg ) !!      if ( iostat /= 0 ) then !!        call global_logger % log_io_error( message, procedure = 'EXAMPLE', & !!            iostat=iostat, iomsg = iomsg ) !!        error stop 'Error on opening ' // filename !!      end if !!      ... !!    end program example class ( logger_type ), intent ( in ) :: self !! The logger variable to receivee the message character ( len =* ), intent ( in ) :: message !! A string to be written to LOG_UNIT character ( len =* ), intent ( in ), optional :: module !! The name of the module contining the current invocation of REPORT_ERROR character ( len =* ), intent ( in ), optional :: procedure !! The name of the procedure contining the current invocation of REPORT_ERROR integer , intent ( in ), optional :: iostat !! The value of the IOSTAT specifier returned by a Fortran I/O statement character ( len =* ), intent ( in ), optional :: iomsg !! The value of the IOMSG specifier returned by a Fortran I/O statement integer :: unit integer :: iostat2 character ( * ), parameter :: procedure_name = 'log_error' character ( 256 ) :: iomsg2 call self % log_message ( message , & module = module , & procedure = procedure , & prefix = 'I/O ERROR' ) if ( self % units == 0 ) then call write_log_io_error ( output_unit ) else do unit = 1 , self % units call write_log_io_error ( self % log_units ( unit ) ) end do end if contains subroutine write_log_io_error ( unit ) integer , intent ( in ) :: unit if ( present ( iostat ) ) then write ( unit , '(\"With iostat = \", i0)' , err = 999 , & iostat = iostat2 , iomsg = iomsg2 ) iostat end if if ( present ( iomsg ) ) then if ( len_trim ( iomsg ) > 0 ) then call format_output_string ( self , unit , & 'With iomsg = \"' // & trim ( iomsg ) // '\"' , & procedure_name , & '    ' ) end if end if return 999 call handle_write_failure ( unit , procedure_name , iostat , iomsg ) end subroutine write_log_io_error end subroutine log_io_error subroutine log_message ( self , message , module , procedure , prefix ) !! version: experimental !! Writes the string `message` to the `self % log_units` with optional !! additional text. !!([Specification](../page/specs/stdlib_logger.html#log_message-write-the-string-message-to-self-log_units)) !! !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by `module` !! and `procedure` if present, followed by `prefix // ': '` if present, !! and then `message`. !! !!##### Example !! !!    module  example_mod !!      use stdlib_logger !!      ... !!      real, allocatable :: a(:) !!      ... !!    contains !!      ... !!      subroutine example_sub( selection ) !!        integer, intent(out) :: selection !!        integer        :: stat !!        write(*,'(a)') \"Enter an integer to select a widget\" !!        read(*,'(i0)') selection !!        write( message, `(a, i0)' )          & !!              \"The user selected \", selection !!        call global_logger % log_message( message,                   & !!                                          module = 'example_mod',    & !!                                          procedure = 'example_sub', & !!                                          prefix = 'info' ) !!      end subroutine example_sub !!      ... !!    end module example_mod !! class ( logger_type ), intent ( in ) :: self !! The logger variable to receive the message character ( len =* ), intent ( in ) :: message !! A string to be written to log_unit character ( len =* ), intent ( in ), optional :: module !! The name of the module contining the current invocation of `log_message` character ( len =* ), intent ( in ), optional :: procedure !! The name of the procedure contining the current invocation of `log_message` character ( len =* ), intent ( in ), optional :: prefix !! To be prepended to message as `prefix // ': ' // message`. integer :: unit integer :: iostat character ( * ), parameter :: procedure_name = 'log_message' character ( 256 ) :: iomsg character (:), allocatable :: d_and_t , m_and_p , pref if ( present ( prefix ) ) then pref = prefix // ': ' else pref = '' end if if ( self % time_stamp ) then d_and_t = time_stamp () // ': ' else d_and_t = '' end if if ( present ( module ) ) then if ( present ( procedure ) ) then m_and_p = trim ( module ) // ' % ' // trim ( procedure ) // ': ' else m_and_p = trim ( module ) // ': ' end if else if ( present ( procedure ) ) then m_and_p = trim ( procedure ) // ': ' else m_and_p = '' end if if ( self % units == 0 ) then call write_log_message ( output_unit ) else do unit = 1 , self % units call write_log_message ( self % log_units ( unit ) ) end do end if contains subroutine write_log_message ( unit ) integer , intent ( in ) :: unit if ( self % add_blank_line ) write ( unit , * , err = 999 , & iostat = iostat , iomsg = iomsg ) call format_output_string ( self , unit , & d_and_t // m_and_p // pref // & trim ( message ), & procedure_name , '    ' ) return 999 call handle_write_failure ( unit , procedure_name , iostat , iomsg ) end subroutine write_log_message end subroutine log_message subroutine log_text_error ( self , line , column , summary , filename , & line_number , caret , stat ) !! version: experimental !! Sends a message to `self % log_units` describing an error found !! in a line of text. !!([Specification](../page/specs/stdlib_logger.html#log_text_error-send-a-message-to-self-log_units-describing-an-error)) !!##### Behavior !! !! If time stamps are active first a time stamp is written. Then if !! `filename` or `line_number` or `column` are present they are written. !! Then `line` is written. Then the symbol `caret` is written below `line` at the !! column indicated by `column`. Then `summary` is written. ! !!##### Example !! !!    program example !!      ... !!      character(*), parameter :: filename = 'dummy.txt' !!      integer                 :: col_num, line_num, lun !!      character(128)          :: line !!      character(*), parameter :: message = 'Bad text found.' !! !!      open( newunit=lun, file = filename, statu='old', form='formatted' ) !!      line_num = 0 !!      do !!        read( lun, fmt='(a)', end=900 ) line !!        line_num = line_num + 1 !!        call check_line( line, status, col_num ) !!        if ( status /= 0 ) !!          call global_logger % log_text_error( line, col_num, message, & !!                                               filename, line_num ) !!          error stop 'Error in reading ' // filename !!        end if !!        ... !!      end do !!900   continue !!      ... !!    end program example !! class ( logger_type ), intent ( in ) :: self !! The logger variable to receive the message character ( * ), intent ( in ) :: line !! The line of text in which the error was found. integer , intent ( in ) :: column !! The one's based column in LINE at which the error starts. character ( * ), intent ( in ) :: summary !! A brief description of the error. character ( * ), intent ( in ), optional :: filename !! The name of the file, if any, in which the error was found. integer , intent ( in ), optional :: line_number !! The one's based line number in the file where `line` was found. character ( 1 ), intent ( in ), optional :: caret !! The symbol used to mark the column wher the error was first detected integer , intent ( out ), optional :: stat !! Integer flag that an error has occurred. Has the value `success` if no !! error hass occurred, `index_invalid_error` if `column` is less than zero or !! greater than `len(line)`, and `write_failure` if any of the `write` statements !! has failed. character ( 1 ) :: acaret character ( 5 ) :: num character (:), allocatable :: fmt character ( 128 ) :: iomsg integer :: iostat integer :: lun character ( * ), parameter :: procedure_name = 'LOG_TEXT_ERROR' acaret = optval ( caret , '&#94;' ) if ( column < 0 . or . column > len ( line ) + 1 ) then if ( present ( stat ) ) then stat = index_invalid_error return else call self % log_error ( invalid_column , & module = module_name , & procedure = procedure_name ) error stop module_name // ' % ' // procedure_name // ': ' // & invalid_column end if end if write ( num , '(i0)' ) column - 1 fmt = '(' // trim ( num ) // 'x, a)' if ( self % units == 0 ) then call write_log_text_error ( output_unit ) else do lun = 1 , self % units call write_log_text_error ( self % log_units ( lun ) ) end do end if contains subroutine write_log_text_error ( unit ) integer , intent ( in ) :: unit if ( self % add_blank_line ) write ( unit , * ) if ( self % time_stamp ) write ( unit , '(a)' ) time_stamp () if ( present ( filename ) ) then if ( present ( line_number ) ) then write ( unit , '(a,\":\", i0, \":\", i0)' , err = 999 , & iomsg = iomsg , iostat = iostat ) & trim ( filename ) , line_number , column else write ( unit , '(a, i0)' , err = 999 , iomsg = iomsg , & iostat = iostat ) & \"Error found in file: '\" // trim ( filename ) // \"'\" & // ', at column: ' , column end if else if ( present ( line_number ) ) then write ( unit , '(a, i0, a, i0)' , err = 999 , iomsg = iomsg , & iostat = iostat ) & 'Error found at line number: ' , line_number , & ', and column: ' , column else write ( unit , '(\"Error found in line at column:\", i0)' ) & column end if end if write ( unit , * ) write ( unit , '(a)' , err = 999 , iomsg = iomsg , iostat = iostat ) line write ( unit , fmt , err = 999 , iomsg = iomsg , iostat = iostat ) & acaret write ( unit , '(a)' , err = 999 , iomsg = iomsg , iostat = iostat ) & 'Error: ' // trim ( summary ) if ( present ( stat ) ) stat = success return 999 if ( present ( stat ) ) then stat = write_failure return else call handle_write_failure ( unit , procedure_name , iostat , & iomsg ) end if end subroutine write_log_text_error end subroutine log_text_error elemental function log_units_assigned ( self ) !! version: experimental !! Returns the number of units assigned to `self % log_units` !!([Specification](../page/specs/stdlib_logger.html#log_units_assigned-returns-the-number-of-active-io-units)) class ( logger_type ), intent ( in ) :: self !! The logger subject to the inquiry integer :: log_units_assigned !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       type(logger_type) :: alogger !!       ... !!     contains !!       ... !!       subroutine example_sub(unit, ...) !!         integer, intent(in) :: unit !!         ... !!         integer, allocatable :: log_units(:) !!         ... !!         if ( alogger % log_units_assigned() == 0 ) then !!            call alogger % add_log_unit( unit ) !!         end if !!         ... !!       end subroutine example_sub !!       ... !!     end module example_mod log_units_assigned = self % units end function log_units_assigned subroutine log_warning ( self , message , module , procedure ) !! version: experimental !! Writes the string `message` to `self % log_units` with optional additional text. !!([Specification](../page/specs/stdlib_logger.html#log_warning-write-the-string-message-to-log_units)) !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by !! `module` and `procedure` if present, then `message` is !! written with the prefix 'WARN: '. !! !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       real, allocatable :: a(:) !!       ... !!       type(logger_type) :: alogger !!       ... !!     contains !!       ... !!       subroutine example_sub( size, stat ) !!         integer, intent(in)  :: size !!         integer, intent(out) :: stat !!         allocate( a(size) ) !!         if ( stat /= 0 ) then !!           write( message, `(a, i0)' )                    & !!               \"Allocation of A failed with SIZE = \", size !!           call alogger % log_warning( message,                   & !!                                       module = 'EXAMPLE_MOD',    & !!                                       procedure = 'EXAMPLE_SUB' ) !!         end if !!       end subroutine example_sub !!       ... !!     end module example_mod !! class ( logger_type ), intent ( in ) :: self !! The logger to which the message is written character ( len =* ), intent ( in ) :: message !! A string to be written to LOG_UNIT character ( len =* ), intent ( in ), optional :: module !! The name of the module contining the current invocation of `log_warning` character ( len =* ), intent ( in ), optional :: procedure !! The name of the procedure contining the current invocation of `log_warning` call self % log_message ( message , & module = module , & procedure = procedure , & prefix = 'WARN' ) end subroutine log_warning subroutine remove_log_unit ( self , unit , close_unit , stat ) !! version: experimental !! Remove the I/O unit from the self % log_units list. If `close_unit` is !! present and `.true.` then the corresponding file is closed. If `unit` is !! not in `log_units` then nothing is done. If `stat` is present it, by default, !! has the value `success`. If closing the `unit` fails, then if `stat` is !! present it has the value `close_failure`, otherwise processing stops !! with an informative message. !!([Specification](../page/specs/stdlib_logger.html#remove_log_unit-remove-unit-from-self-log_units)) class ( logger_type ), intent ( inout ) :: self !! The logger variable whose unit is to be removed integer , intent ( in ) :: unit !! The I/O unit to be removed from self logical , intent ( in ), optional :: close_unit !! A logical flag to close the unit while removing it from the SELF list integer , intent ( out ), optional :: stat !! An error status with the values !! * success - no problems found !! * close_failure - the close statement for unit failed !! !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       type(logger_type) ::  alogger !!     contains !!       ... !!       subroutine example_sub(unit, ...) !!         integer, intent(in) :: unit !!         ... !!         call alogger % remove_log_unit( unit ) !!         ... !!       end subroutine example_sub !!       ... !!     end module example_mod character ( 128 ) :: errmsg integer :: lun , lun_old character ( * ), parameter :: procedure_name = 'REMOVE_LOG_UNIT' if ( present ( stat ) ) stat = success do lun = 1 , self % units if ( unit == self % log_units ( lun ) ) exit end do if ( lun == self % units + 1 ) return if ( present ( close_unit ) ) then if ( close_unit ) close ( unit , err = 999 , iomsg = errmsg ) end if do lun_old = lun + 1 , self % units self % log_units ( lun_old - 1 ) = self % log_units ( lun_old ) end do self % units = self % units - 1 return 999 if ( present ( stat ) ) then stat = close_failure return else write ( * , '(a, i0)' ) 'In ' // module_name // ' % ' // & procedure_name // ' close_unit failed for unit = ' , unit write ( * , '(a)' ) 'With iomsg = ' // trim ( errmsg ) error stop 'close_unit failed in ' // module_name // ' % ' // & procedure_name // '.' end if end subroutine remove_log_unit function time_stamp () !! Creates a time stamp in the format 'yyyy-mm-dd hh:mm:ss.sss' character ( 23 ) :: time_stamp character ( 8 ) :: date character ( 10 ) :: time call date_and_time ( date , time ) time_stamp ( 1 : 4 ) = date ( 1 : 4 ) time_stamp ( 5 : 5 ) = '-' time_stamp ( 6 : 7 ) = date ( 5 : 6 ) time_stamp ( 8 : 8 ) = '-' time_stamp ( 9 : 10 ) = date ( 7 : 8 ) time_stamp ( 11 : 11 ) = ' ' time_stamp ( 12 : 13 ) = time ( 1 : 2 ) time_stamp ( 14 : 14 ) = ':' time_stamp ( 15 : 16 ) = time ( 3 : 4 ) time_stamp ( 17 : 17 ) = ':' time_stamp ( 18 : 23 ) = time ( 5 : 10 ) end function time_stamp end module stdlib_logger","tags":"","loc":"sourcefile/stdlib_logger.f90.html"},{"title":"stdlib_stats.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats.fypp~~EfferentGraph sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_stats.fypp~~AfferentGraph sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_cov.fypp stdlib_stats_cov.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_mean.fypp stdlib_stats_mean.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_moment.fypp stdlib_stats_moment.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_var.fypp stdlib_stats_var.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_stats.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_stats Source Code stdlib_stats.fypp Source Code #:include \"common.fypp\" #:set RANKS = range(1, MAXRANK + 1) #:set REDRANKS = range(2, MAXRANK + 1) #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES module stdlib_stats !! Provides support for various statistical methods. This includes currently !! descriptive statistics !! ([Specification](../page/specs/stdlib_stats.html)) use stdlib_kinds , only : sp , dp , qp , & int8 , int16 , int32 , int64 implicit none private ! Public API public :: corr , cov , mean , moment , var interface corr !! version: experimental !! !! Pearson correlation of array elements !! ([Specification](../page/specs/stdlib_stats.html#description)) # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) real ( dp ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor end interface corr interface cov !! version: experimental !! !! Covariance of array elements !! ([Specification](../page/specs/stdlib_stats.html#description_1)) # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) logical , intent ( in ), optional :: corrected real ( dp ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) logical , intent ( in ), optional :: corrected ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) logical , intent ( in ), optional :: corrected real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor end interface cov interface mean !! version: experimental !! !! Mean of array elements !! ([Specification](../page/specs/stdlib_stats.html#description_2)) # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask ${ t1 }$ :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_all' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask_all' , rank , t1 , k1 ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask_all' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask' , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor end interface mean interface var !! version: experimental !! !! Variance of array elements !! ([Specification](../page/specs/stdlib_stats.html#description_4)) # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor end interface var interface moment !! version: experimental !! !! Central moment of array elements !! ([Specification](../page/specs/stdlib_stats.html#description_3)) # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order ${ t1 }$ , intent ( in ), optional :: center logical , intent ( in ), optional :: mask ${ t1 }$ :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order real ( dp ), intent ( in ), optional :: center logical , intent ( in ), optional :: mask real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_scalar\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ) :: center logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_scalar\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ) :: center logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order ${ t1 }$ , intent ( in ), optional :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order real ( dp ), intent ( in ), optional :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_mask_scalar\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ) :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_mask_scalar\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ) :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor end interface moment end module stdlib_stats","tags":"","loc":"sourcefile/stdlib_stats.fypp.html"},{"title":"stdlib_io.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_io.fypp~~EfferentGraph sourcefile~stdlib_io.fypp stdlib_io.fypp sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_io.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_ascii.f90 stdlib_ascii.f90 sourcefile~stdlib_io.fypp->sourcefile~stdlib_ascii.f90 sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_io.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_io Source Code stdlib_io.fypp Source Code #:include \"common.fypp\" #:set KINDS_TYPES = REAL_KINDS_TYPES + INT_KINDS_TYPES + CMPLX_KINDS_TYPES module stdlib_io !! Provides a support for file handling !! ([Specification](../page/specs/stdlib_io.html)) use stdlib_kinds , only : sp , dp , qp , & int8 , int16 , int32 , int64 use stdlib_error , only : error_stop use stdlib_optval , only : optval use stdlib_ascii , only : is_blank implicit none private ! Public API public :: loadtxt , savetxt , open ! Private API that is exposed so that we can test it in tests public :: parse_mode interface loadtxt !! version: experimental !! !! Loads a 2D array from a text file !! ([Specification](../page/specs/stdlib_io.html#description)) # : for k1 , t1 in KINDS_TYPES module procedure loadtxt_$ { t1 [ 0 ] }{ k1 }$ # : endfor end interface loadtxt interface savetxt !! version: experimental !! !! Saves a 2D array into a text file !! ([Specification](../page/specs/stdlib_io.html#description_2)) # : for k1 , t1 in KINDS_TYPES module procedure savetxt_$ { t1 [ 0 ] }{ k1 }$ # : endfor end interface contains # : for k1 , t1 in KINDS_TYPES subroutine loadtxt_$ { t1 [ 0 ] }{ k1 }$ ( filename , d ) !! version: experimental !! !! Loads a 2D array from a text file. !! !! Arguments !! --------- !! !! Filename to load the array from character ( len =* ), intent ( in ) :: filename !! The array 'd' will be automatically allocated with the correct dimensions ${ t1 }$ , allocatable , intent ( out ) :: d (:,:) !! !! Example !! ------- !! !!```fortran !! ${t1}$, allocatable :: data(:, :) !! call loadtxt(\"log.txt\", data)  ! 'data' will be automatically allocated !!``` !! !! Where 'log.txt' contains for example:: !! !!     1 2 3 !!     2 4 6 !!     8 9 10 !!     11 12 13 !!     ... !! integer :: s integer :: nrow , ncol , i s = open ( filename ) ! determine number of columns ncol = number_of_columns ( s ) ! determine number or rows nrow = number_of_rows_numeric ( s ) allocate ( d ( nrow , ncol )) do i = 1 , nrow read ( s , * ) d ( i , :) end do close ( s ) end subroutine loadtxt_$ { t1 [ 0 ] }{ k1 }$ # : endfor # : for k1 , t1 in KINDS_TYPES subroutine savetxt_$ { t1 [ 0 ] }{ k1 }$ ( filename , d ) !! version: experimental !! !! Saves a 2D array into a text file. !! !! Arguments !! --------- !! character ( len =* ), intent ( in ) :: filename ! File to save the array to ${ t1 }$ , intent ( in ) :: d (:,:) ! The 2D array to save !! !! Example !! ------- !! !!```fortran !! ${t1}$ :: data(3, 2) !! call savetxt(\"log.txt\", data) !!``` !! integer :: s , i s = open ( filename , \"w\" ) do i = 1 , size ( d , 1 ) write ( s , * ) d ( i , :) end do close ( s ) end subroutine savetxt_$ { t1 [ 0 ] }{ k1 }$ # : endfor integer function number_of_columns ( s ) !! version: experimental !! !! determine number of columns integer , intent ( in ) :: s integer :: ios character :: c logical :: lastblank rewind ( s ) number_of_columns = 0 lastblank = . true . do read ( s , '(a)' , advance = 'no' , iostat = ios ) c if ( ios /= 0 ) exit if ( lastblank . and . . not . is_blank ( c )) number_of_columns = number_of_columns + 1 lastblank = is_blank ( c ) end do rewind ( s ) end function number_of_columns integer function number_of_rows_numeric ( s ) result ( nrows ) !! version: experimental !! !! determine number or rows integer , intent ( in ) :: s integer :: ios real :: r complex :: z rewind ( s ) nrows = 0 do read ( s , * , iostat = ios ) r if ( ios /= 0 ) exit nrows = nrows + 1 end do rewind ( s ) ! If there are no rows of real numbers, it may be that they are complex if ( nrows == 0 ) then do read ( s , * , iostat = ios ) z if ( ios /= 0 ) exit nrows = nrows + 1 end do rewind ( s ) end if end function number_of_rows_numeric integer function open ( filename , mode , iostat ) result ( u ) !! version: experimental !! !! Opens a file !! ([Specification](../page/specs/stdlib_io.html#description_1)) !! !!##### Behavior !! !! !! To open a file to read: !! !!```fortran !! u = open(\"somefile.txt\")        ! The default `mode` is \"rt\" !! u = open(\"somefile.txt\", \"r\") !!``` !! !! To open a file to write: !! !!```fortran !! u = open(\"somefile.txt\", \"w\") !!``` !! !! To append to the end of the file if it exists: !! !!```fortran !! u = open(\"somefile.txt\", \"a\") !!``` character ( * ), intent ( in ) :: filename character ( * ), intent ( in ), optional :: mode integer , intent ( out ), optional :: iostat character ( 3 ) :: mode_ character (:), allocatable :: action_ , position_ , status_ , access_ , form_ mode_ = parse_mode ( optval ( mode , \"\" )) select case ( mode_ ( 1 : 2 )) case ( 'r' ) action_ = 'read' position_ = 'asis' status_ = 'old' case ( 'w' ) action_ = 'write' position_ = 'asis' status_ = 'replace' case ( 'a' ) action_ = 'write' position_ = 'append' status_ = 'old' case ( 'x' ) action_ = 'write' position_ = 'asis' status_ = 'new' case ( 'r+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'old' case ( 'w+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'replace' case ( 'a+' ) action_ = 'readwrite' position_ = 'append' status_ = 'old' case ( 'x+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'new' case default call error_stop ( \"Unsupported mode: \" // mode_ ( 1 : 2 )) end select select case ( mode_ ( 3 : 3 )) case ( 't' ) form_ = 'formatted' case ( 'b' ) form_ = 'unformatted' case default call error_stop ( \"Unsupported mode: \" // mode_ ( 3 : 3 )) end select access_ = 'stream' if ( present ( iostat )) then open ( newunit = u , file = filename , & action = action_ , position = position_ , status = status_ , & access = access_ , form = form_ , & iostat = iostat ) else open ( newunit = u , file = filename , & action = action_ , position = position_ , status = status_ , & access = access_ , form = form_ ) end if end function open character ( 3 ) function parse_mode ( mode ) result ( mode_ ) character ( * ), intent ( in ) :: mode integer :: i character (:), allocatable :: a logical :: lfirst ( 3 ) mode_ = 'r t' if ( len_trim ( mode ) == 0 ) return a = trim ( adjustl ( mode )) lfirst = . true . do i = 1 , len ( a ) if ( lfirst ( 1 ) & . and . ( a ( i : i ) == 'r' . or . a ( i : i ) == 'w' . or . a ( i : i ) == 'a' . or . a ( i : i ) == 'x' ) & ) then mode_ ( 1 : 1 ) = a ( i : i ) lfirst ( 1 ) = . false . else if ( lfirst ( 2 ) . and . a ( i : i ) == '+' ) then mode_ ( 2 : 2 ) = a ( i : i ) lfirst ( 2 ) = . false . else if ( lfirst ( 3 ) . and . ( a ( i : i ) == 't' . or . a ( i : i ) == 'b' )) then mode_ ( 3 : 3 ) = a ( i : i ) lfirst ( 3 ) = . false . else if ( a ( i : i ) == ' ' ) then cycle else if ( any (. not . lfirst )) then call error_stop ( \"Wrong mode: \" // trim ( a )) else call error_stop ( \"Wrong character: \" // a ( i : i )) endif end do end function parse_mode end module","tags":"","loc":"sourcefile/stdlib_io.fypp.html"},{"title":"stdlib_quadrature_simps.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_quadrature_simps.fypp~~EfferentGraph sourcefile~stdlib_quadrature_simps.fypp stdlib_quadrature_simps.fypp sourcefile~stdlib_quadrature.fypp stdlib_quadrature.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_quadrature.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_quadrature_simps Source Code stdlib_quadrature_simps.fypp Source Code #:include \"common.fypp\" submodule ( stdlib_quadrature ) stdlib_quadrature_simps use stdlib_error , only : check implicit none ! internal use only interface simps38 # : for k1 , t1 in REAL_KINDS_TYPES module procedure simps38_dx_$ { k1 }$ module procedure simps38_x_$ { k1 }$ # : endfor end interface simps38 ! internal use only interface simps38_weights # : for k1 , t1 in REAL_KINDS_TYPES module procedure simps38_weights_$ { k1 }$ # : endfor end interface simps38_weights contains #:for k1, t1 in REAL_KINDS_TYPES pure recursive module function simps_dx_$ { k1 }$ ( y , dx , even ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , intent ( in ) :: dx integer , intent ( in ), optional :: even ${ t1 }$ :: integral integer :: n n = size ( y ) select case ( n ) case ( 0 : 1 ) integral = 0.0 _${ k1 }$ case ( 2 ) integral = 0.5 _${ k1 }$ * dx * ( y ( 1 ) + y ( 2 )) case ( 3 ) integral = dx / 3.0 _${ k1 }$ * ( y ( 1 ) + 4 * y ( 2 ) + y ( 3 )) case ( 4 ) integral = simps38 ( y , dx ) ! case (5) not needed; handled by default case ( 6 ) ! needs special handling because of averaged 3/8's rule case if ( present ( even )) then if ( even < 0 ) then ! 3/8 rule on left integral = simps38 ( y ( 1 : 4 ), dx ) + simps ( y ( 4 : 6 ), dx ) return else if ( even > 0 ) then ! 3/8 rule on right integral = simps ( y ( 1 : 3 ), dx ) + simps38 ( y ( 3 : 6 ), dx ) return else ! fall through end if end if ! either `even` not present or is zero ! equivalent to averaging left and right integral = dx / 4 8.0 _${ k1 }$ * ( 17 * ( y ( 1 ) + y ( 6 )) + 59 * ( y ( 2 ) + y ( 5 )) + 44 * ( y ( 3 ) + y ( 4 ))) case default if ( mod ( n , 2 ) == 1 ) then integral = dx / 3.0 _${ k1 }$ * ( y ( 1 ) + 4 * sum ( y ( 2 : n - 1 : 2 )) + 2 * sum ( y ( 3 : n - 2 : 2 )) + y ( n )) else if ( present ( even )) then if ( even < 0 ) then ! 3/8th rule on left integral = simps38 ( y ( 1 : 4 ), dx ) + simps ( y ( 4 : n ), dx ) return else if ( even > 0 ) then ! 3/8 rule on right integral = simps ( y ( 1 : n - 3 ), dx ) + simps38 ( y ( n - 3 : n ), dx ) return else ! fall through end if end if ! either `even` not present or is zero ! equivalent to averaging left and right integral = dx / 4 8.0 _${ k1 }$ * ( 17 * ( y ( 1 ) + y ( n )) + 59 * ( y ( 2 ) + y ( n - 1 )) & + 43 * ( y ( 3 ) + y ( n - 2 )) + 49 * ( y ( 4 ) + y ( n - 3 )) + 48 * sum ( y ( 5 : n - 4 ))) end if end select end function simps_dx_$ { k1 }$ #:endfor #:for k1, t1 in REAL_KINDS_TYPES recursive module function simps_x_$ { k1 }$ ( y , x , even ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: even ${ t1 }$ :: integral integer :: i integer :: n ${ t1 }$ :: h1 , h2 ${ t1 }$ :: a , b , c n = size ( y ) call check ( size ( x ) == n , \"simps: Arguments `x` and `y` must be the same size.\" ) select case ( n ) case ( 0 : 1 ) integral = 0.0 _${ k1 }$ case ( 2 ) integral = 0.5 _${ k1 }$ * ( x ( 2 ) - x ( 1 )) * ( y ( 1 ) + y ( 2 )) case ( 3 ) h1 = x ( 2 ) - x ( 1 ) h2 = x ( 3 ) - x ( 2 ) a = ( 2 * h1 ** 2 + h1 * h2 - h2 ** 2 ) / ( 6 * h1 ) b = ( h1 + h2 ) ** 3 / ( 6 * h1 * h2 ) c = ( 2 * h2 ** 2 + h1 * h2 - h1 ** 2 ) / ( 6 * h2 ) integral = a * y ( 1 ) + b * y ( 2 ) + c * y ( 3 ) case ( 4 ) integral = simps38 ( y , x ) ! case (6) unneeded; handled by default case default if ( mod ( n , 2 ) == 1 ) then integral = 0.0 _${ k1 }$ do i = 1 , n - 2 , 2 h1 = x ( i + 1 ) - x ( i ) h2 = x ( i + 2 ) - x ( i + 1 ) a = ( 2 * h1 ** 2 + h1 * h2 - h2 ** 2 ) / ( 6 * h1 ) b = ( h1 + h2 ) ** 3 / ( 6 * h1 * h2 ) c = ( 2 * h2 ** 2 + h1 * h2 - h1 ** 2 ) / ( 6 * h2 ) integral = integral + a * y ( i ) + b * y ( i + 1 ) + c * y ( i + 2 ) end do else if ( present ( even )) then if ( even < 0 ) then ! 3/8 rule on left integral = simps38 ( y ( 1 : 4 ), x ( 1 : 4 )) + simps ( y ( 4 : n ), x ( 4 : n )) return else if ( even > 0 ) then ! 3/8 rule on right integral = simps ( y ( 1 : n - 3 ), x ( 1 : n - 3 )) + simps38 ( y ( n - 3 : n ), x ( n - 3 : n )) return else ! fall through end if end if ! either `even` not present or is zero integral = 0.5 _${ k1 }$ * ( simps38 ( y ( 1 : 4 ), x ( 1 : 4 )) + simps ( y ( 4 : n ), x ( 4 : n )) & + simps ( y ( 1 : n - 3 ), x ( 1 : n - 3 )) + simps38 ( y ( n - 3 : n ), x ( n - 3 : n )) ) end if end select end function simps_x_$ { k1 }$ #:endfor #:for k1, t1 in REAL_KINDS_TYPES pure recursive module function simps_weights_$ { k1 }$ ( x , even ) result ( w ) ${ t1 }$ , dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: even ${ t1 }$ , dimension ( size ( x )) :: w integer :: i , n ${ t1 }$ :: h1 , h2 n = size ( x ) select case ( n ) case ( 0 ) ! no action needed case ( 1 ) w ( 1 ) = 0.0 _${ k1 }$ case ( 2 ) w = 0.5 _${ k1 }$ * ( x ( 2 ) - x ( 1 )) case ( 3 ) h1 = x ( 2 ) - x ( 1 ) h2 = x ( 3 ) - x ( 2 ) w ( 1 ) = ( 2 * h1 ** 2 + h1 * h2 - h2 ** 2 ) / ( 6 * h1 ) w ( 2 ) = ( h1 + h2 ) ** 3 / ( 6 * h1 * h2 ) w ( 3 ) = ( 2 * h2 ** 2 + h1 * h2 - h1 ** 2 ) / ( 6 * h2 ) case ( 4 ) w = simps38_weights ( x ) case default if ( mod ( n , 2 ) == 1 ) then w = 0.0 _${ k1 }$ do i = 1 , n - 2 , 2 h1 = x ( i + 1 ) - x ( i ) h2 = x ( i + 2 ) - x ( i + 1 ) w ( i ) = w ( i ) + ( 2 * h1 ** 2 + h1 * h2 - h2 ** 2 ) / ( 6 * h1 ) w ( i + 1 ) = w ( i + 1 ) + ( h1 + h2 ) ** 3 / ( 6 * h1 * h2 ) w ( i + 2 ) = w ( i + 2 ) + ( 2 * h2 ** 2 + h1 * h2 - h1 ** 2 ) / ( 6 * h2 ) end do else if ( present ( even )) then if ( even < 0 ) then ! 3/8 rule on left w = 0.0 _${ k1 }$ w ( 1 : 4 ) = simps38_weights ( x ( 1 : 4 )) w ( 4 : n ) = w ( 4 : n ) + simps_weights ( x ( 4 : n )) ! position 4 needs both rules return else if ( even > 0 ) then ! 3/8 rule on right w = 0.0 _${ k1 }$ w ( 1 : n - 3 ) = simps_weights ( x ( 1 : n - 3 )) w ( n - 3 : n ) = w ( n - 3 : n ) + simps38_weights ( x ( n - 3 : n )) ! position n-3 needs both rules return else ! fall through end if end if ! either `even` not present or is zero w = 0.0 _${ k1 }$ ! 3/8 rule on left w ( 1 : 4 ) = simps38_weights ( x ( 1 : 4 )) w ( 4 : n ) = w ( 4 : n ) + simps_weights ( x ( 4 : n )) ! 3/8 rule on right w ( 1 : n - 3 ) = w ( 1 : n - 3 ) + simps_weights ( x ( 1 : n - 3 )) w ( n - 3 : n ) = w ( n - 3 : n ) + simps38_weights ( x ( n - 3 : n )) ! average w = 0.5 _${ k1 }$ * w end if end select end function simps_weights_$ { k1 }$ #:endfor #:for k1, t1 in REAL_KINDS_TYPES pure function simps38_dx_$ { k1 }$ ( y , dx ) result ( integral ) ${ t1 }$ , dimension ( 4 ), intent ( in ) :: y ${ t1 }$ , intent ( in ) :: dx ${ t1 }$ :: integral integral = 3.0 _${ k1 }$ * dx / 8.0 _${ k1 }$ * ( y ( 1 ) + y ( 4 ) + 3 * ( y ( 2 ) + y ( 3 ))) end function simps38_dx_$ { k1 }$ #:endfor #: for k1, t1 in REAL_KINDS_TYPES pure function simps38_x_$ { k1 }$ ( y , x ) result ( integral ) ${ t1 }$ , dimension ( 4 ), intent ( in ) :: y ${ t1 }$ , dimension ( 4 ), intent ( in ) :: x ${ t1 }$ :: integral ${ t1 }$ :: h1 , h2 , h3 ${ t1 }$ :: a , b , c , d h1 = x ( 2 ) - x ( 1 ) h2 = x ( 3 ) - x ( 2 ) h3 = x ( 4 ) - x ( 3 ) a = ( h1 + h2 + h3 ) * ( 3 * h1 ** 2 + 2 * h1 * h2 - 2 * h1 * h3 - h2 ** 2 + h3 ** 2 ) / ( 12 * h1 * ( h1 + h2 )) b = ( h1 + h2 - h3 ) * ( h1 + h2 + h3 ) ** 3 / ( 12 * h1 * h2 * ( h2 + h3 )) c = ( h2 + h3 - h1 ) * ( h1 + h2 + h3 ) ** 3 / ( 12 * h2 * h3 * ( h1 + h2 )) d = ( h1 + h2 + h3 ) * ( 3 * h3 ** 2 + 2 * h2 * h3 - 2 * h1 * h3 - h2 ** 2 + h1 ** 2 ) / ( 12 * h3 * ( h2 + h3 )) integral = a * y ( 1 ) + b * y ( 2 ) + c * y ( 3 ) + d * y ( 4 ) end function simps38_x_$ { k1 }$ #:endfor #:for k1, t1 in REAL_KINDS_TYPES pure function simps38_weights_$ { k1 }$ ( x ) result ( w ) ${ t1 }$ , intent ( in ) :: x ( 4 ) ${ t1 }$ :: w ( size ( x )) ${ t1 }$ :: h1 , h2 , h3 h1 = x ( 2 ) - x ( 1 ) h2 = x ( 3 ) - x ( 2 ) h3 = x ( 4 ) - x ( 3 ) w ( 1 ) = ( h1 + h2 + h3 ) * ( 3 * h1 ** 2 + 2 * h1 * h2 - 2 * h1 * h3 - h2 ** 2 + h3 ** 2 ) / ( 12 * h1 * ( h1 + h2 )) w ( 2 ) = ( h1 + h2 - h3 ) * ( h1 + h2 + h3 ) ** 3 / ( 12 * h1 * h2 * ( h2 + h3 )) w ( 3 ) = ( h2 + h3 - h1 ) * ( h1 + h2 + h3 ) ** 3 / ( 12 * h2 * h3 * ( h1 + h2 )) w ( 4 ) = ( h1 + h2 + h3 ) * ( 3 * h3 ** 2 + 2 * h2 * h3 - 2 * h1 * h3 - h2 ** 2 + h1 ** 2 ) / ( 12 * h3 * ( h2 + h3 )) end function simps38_weights_$ { k1 }$ #:endfor end submodule stdlib_quadrature_simps","tags":"","loc":"sourcefile/stdlib_quadrature_simps.fypp.html"},{"title":"stdlib_error.f90 – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_error.f90~~EfferentGraph sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_error.f90~~AfferentGraph sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~f18estop.f90 f18estop.f90 sourcefile~f18estop.f90->sourcefile~stdlib_error.f90 sourcefile~stdlib_quadrature_trapz.fypp stdlib_quadrature_trapz.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_cov.fypp stdlib_stats_cov.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_mean.fypp stdlib_stats_mean.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_error.f90 sourcefile~f08estop.f90 f08estop.f90 sourcefile~f08estop.f90->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_moment.fypp stdlib_stats_moment.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_quadrature_simps.fypp stdlib_quadrature_simps.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_io.fypp stdlib_io.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_var.fypp stdlib_stats_var.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_error Source Code stdlib_error.f90 Source Code module stdlib_error !! Provides support for catching and handling errors !! ([Specification](../page/specs/stdlib_error.html)) use , intrinsic :: iso_fortran_env , only : stderr => error_unit use stdlib_optval , only : optval implicit none private interface ! f{08,18}estop.f90 module subroutine error_stop ( msg , code ) !! version: experimental !! !! Provides a call to `error stop` and allows the user to specify a code and message !! ([Specification](..//page/specs/stdlib_error.html#description_1)) character ( * ), intent ( in ) :: msg integer , intent ( in ), optional :: code end subroutine error_stop end interface public :: check , error_stop contains subroutine check ( condition , msg , code , warn ) !! version: experimental !! !! Checks the value of a logical condition !! ([Specification](../page/specs/stdlib_error.html#description)) !! !!##### Behavior !! !! If `condition == .false.` and: !! !!   * No other arguments are provided, it stops the program with the default !!     message and exit code `1`; !!   * `msg` is provided, it prints the value of `msg`; !!   * `code` is provided, it stops the program with the given exit code; !!   * `warn` is provided and `.true.`, it doesn't stop the program and prints !!     the message. !! !!##### Examples !! !!* If `a /= 5`, stops the program with exit code `1` !!  and prints `Check failed.` !!``` fortran !!  call check(a == 5) !!``` !! !!* As above, but prints `a == 5 failed`. !!``` fortran !!  call check(a == 5, msg='a == 5 failed.') !!``` !! !!* As above, but doesn't stop the program. !!``` fortran !!  call check(a == 5, msg='a == 5 failed.', warn=.true.) !!``` !! !!* As example #2, but stops the program with exit code `77` !!``` fortran !!  call check(a == 5, msg='a == 5 failed.', code=77) !!``` ! ! Arguments ! --------- logical , intent ( in ) :: condition character ( * ), intent ( in ), optional :: msg integer , intent ( in ), optional :: code logical , intent ( in ), optional :: warn character ( * ), parameter :: msg_default = 'Check failed.' if (. not . condition ) then if ( optval ( warn , . false .)) then write ( stderr , * ) optval ( msg , msg_default ) else call error_stop ( optval ( msg , msg_default ), optval ( code , 1 )) end if end if end subroutine check end module stdlib_error","tags":"","loc":"sourcefile/stdlib_error.f90.html"},{"title":"stdlib_linalg_diag.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_linalg_diag.fypp~~EfferentGraph sourcefile~stdlib_linalg_diag.fypp stdlib_linalg_diag.fypp sourcefile~stdlib_linalg.fypp stdlib_linalg.fypp sourcefile~stdlib_linalg_diag.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_linalg.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_linalg_diag Source Code stdlib_linalg_diag.fypp Source Code #:include \"common.fypp\" #:set RCI_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES + INT_KINDS_TYPES submodule ( stdlib_linalg ) stdlib_linalg_diag implicit none contains # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$ ( v ) result ( res ) ${ t1 }$ , intent ( in ) :: v (:) ${ t1 }$ :: res ( size ( v ), size ( v )) integer :: i res = 0 do i = 1 , size ( v ) res ( i , i ) = v ( i ) end do end function diag_$ { t1 [ 0 ] }{ k1 }$ # : endfor # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ k ( v , k ) result ( res ) ${ t1 }$ , intent ( in ) :: v (:) integer , intent ( in ) :: k ${ t1 }$ :: res ( size ( v ) + abs ( k ), size ( v ) + abs ( k )) integer :: i , sz sz = size ( v ) res = 0 if ( k > 0 ) then do i = 1 , sz res ( i , k + i ) = v ( i ) end do else if ( k < 0 ) then do i = 1 , sz res ( i + abs ( k ), i ) = v ( i ) end do else do i = 1 , sz res ( i , i ) = v ( i ) end do end if end function diag_$ { t1 [ 0 ] }{ k1 }$_ k # : endfor # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ mat ( A ) result ( res ) ${ t1 }$ , intent ( in ) :: A (:,:) ${ t1 }$ :: res ( minval ( shape ( A ))) integer :: i do i = 1 , minval ( shape ( A )) res ( i ) = A ( i , i ) end do end function diag_$ { t1 [ 0 ] }{ k1 }$_ mat # : endfor # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ mat_k ( A , k ) result ( res ) ${ t1 }$ , intent ( in ) :: A (:,:) integer , intent ( in ) :: k ${ t1 }$ :: res ( minval ( shape ( A )) - abs ( k )) integer :: i , sz sz = minval ( shape ( A )) - abs ( k ) if ( k > 0 ) then do i = 1 , sz res ( i ) = A ( i , k + i ) end do else if ( k < 0 ) then do i = 1 , sz res ( i ) = A ( i + abs ( k ), i ) end do else do i = 1 , sz res ( i ) = A ( i , i ) end do end if end function diag_$ { t1 [ 0 ] }{ k1 }$_ mat_k # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_linalg_diag.fypp.html"},{"title":"stdlib_quadrature.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_quadrature.fypp~~EfferentGraph sourcefile~stdlib_quadrature.fypp stdlib_quadrature.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_quadrature.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_quadrature.fypp~~AfferentGraph sourcefile~stdlib_quadrature.fypp stdlib_quadrature.fypp sourcefile~stdlib_quadrature_trapz.fypp stdlib_quadrature_trapz.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_quadrature_simps.fypp stdlib_quadrature_simps.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_quadrature.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_quadrature Source Code stdlib_quadrature.fypp Source Code #:include \"common.fypp\" module stdlib_quadrature !! ([Specification](../page/specs/stdlib_quadrature.html#description)) use stdlib_kinds , only : sp , dp , qp implicit none private ! array integration public :: trapz public :: trapz_weights public :: simps public :: simps_weights interface trapz !! version: experimental !! !! Integrates sampled values using trapezoidal rule !! ([Specification](../page/specs/stdlib_quadrature.html#description)) # : for k1 , t1 in REAL_KINDS_TYPES pure module function trapz_dx_$ { k1 }$ ( y , dx ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , intent ( in ) :: dx ${ t1 }$ :: integral end function trapz_dx_$ { k1 }$ # : endfor # : for k1 , t1 in REAL_KINDS_TYPES module function trapz_x_$ { k1 }$ ( y , x ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , dimension (:), intent ( in ) :: x ${ t1 }$ :: integral end function trapz_x_$ { k1 }$ # : endfor end interface trapz interface trapz_weights !! version: experimental !! !! Integrates sampled values using trapezoidal rule weights for given abscissas !! ([Specification](../page/specs/stdlib_quadrature.html#description_1)) # : for k1 , t1 in REAL_KINDS_TYPES pure module function trapz_weights_$ { k1 }$ ( x ) result ( w ) ${ t1 }$ , dimension (:), intent ( in ) :: x ${ t1 }$ , dimension ( size ( x )) :: w end function trapz_weights_$ { k1 }$ # : endfor end interface trapz_weights interface simps !! version: experimental !! !! Integrates sampled values using Simpson's rule !! ([Specification](../page/specs/stdlib_quadrature.html#description_3)) ! \"recursive\" is an implementation detail # : for k1 , t1 in REAL_KINDS_TYPES pure recursive module function simps_dx_$ { k1 }$ ( y , dx , even ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , intent ( in ) :: dx integer , intent ( in ), optional :: even ${ t1 }$ :: integral end function simps_dx_$ { k1 }$ # : endfor # : for k1 , t1 in REAL_KINDS_TYPES recursive module function simps_x_$ { k1 }$ ( y , x , even ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: even ${ t1 }$ :: integral end function simps_x_$ { k1 }$ # : endfor end interface simps interface simps_weights !! version: experimental !! !! Integrates sampled values using trapezoidal rule weights for given abscissas !! ([Specification](../page/specs/stdlib_quadrature.html#description_3)) # : for k1 , t1 in REAL_KINDS_TYPES pure recursive module function simps_weights_$ { k1 }$ ( x , even ) result ( w ) ${ t1 }$ , dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: even ${ t1 }$ , dimension ( size ( x )) :: w end function simps_weights_$ { k1 }$ # : endfor end interface simps_weights ! Interface for a simple f(x)-style integrand function. ! Could become fancier as we learn about the performance ! ramifications of different ways to do callbacks. abstract interface # : for k1 , t1 in REAL_KINDS_TYPES pure function integrand_$ { k1 }$ ( x ) result ( f ) import :: ${ k1 }$ ${ t1 }$ , intent ( in ) :: x ${ t1 }$ :: f end function integrand_$ { k1 }$ # : endfor end interface end module stdlib_quadrature","tags":"","loc":"sourcefile/stdlib_quadrature.fypp.html"},{"title":"stdlib_stats_mean.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_mean.fypp~~EfferentGraph sourcefile~stdlib_stats_mean.fypp stdlib_stats_mean.fypp sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_mean Source Code stdlib_stats_mean.fypp Source Code #:include \"common.fypp\" #:set RANKS = range(1, MAXRANK + 1) #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_mean use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask ${ t1 }$ :: res if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if res = sum ( x ) / real ( size ( x , kind = int64 ), ${ k1 }$ ) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_all' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask real ( dp ) :: res if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if res = sum ( real ( x , dp )) / real ( size ( x , kind = int64 ), dp ) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum ( x , dim ) / real ( size ( x , dim ), ${ k1 }$ ) else call error_stop ( \"ERROR (mean): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum ( real ( x , dp ), dim ) / real ( size ( x , dim ), dp ) else call error_stop ( \"ERROR (mean): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask_all' , rank , t1 , k1 ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res res = sum ( x , mask ) / real ( count ( mask , kind = int64 ), ${ k1 }$ ) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask_all' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res res = sum ( real ( x , dp ), mask ) / real ( count ( mask , kind = int64 ), dp ) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask' , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum ( x , dim , mask ) / real ( count ( mask , dim ), ${ k1 }$ ) else call error_stop ( \"ERROR (mean): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum ( real ( x , dp ), dim , mask ) / real ( count ( mask , dim ), dp ) else call error_stop ( \"ERROR (mean): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_mean.fypp.html"},{"title":"stdlib_kinds.f90 – Fortran-lang/stdlib","text":"Files dependent on this one sourcefile~~stdlib_kinds.f90~~AfferentGraph sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_linalg.fypp stdlib_linalg.fypp sourcefile~stdlib_linalg.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_quadrature.fypp stdlib_quadrature.fypp sourcefile~stdlib_quadrature.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_io.fypp stdlib_io.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_io.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_quadrature_trapz.fypp stdlib_quadrature_trapz.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_cov.fypp stdlib_stats_cov.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_mean.fypp stdlib_stats_mean.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_logger.f90 stdlib_logger.f90 sourcefile~stdlib_logger.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_moment.fypp stdlib_stats_moment.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_quadrature_simps.fypp stdlib_quadrature_simps.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_linalg_diag.fypp stdlib_linalg_diag.fypp sourcefile~stdlib_linalg_diag.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_var.fypp stdlib_stats_var.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~f18estop.f90 f18estop.f90 sourcefile~f18estop.f90->sourcefile~stdlib_error.f90 sourcefile~f08estop.f90 f08estop.f90 sourcefile~f08estop.f90->sourcefile~stdlib_error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_kinds Source Code stdlib_kinds.f90 Source Code module stdlib_kinds !! version: experimental use iso_fortran_env , only : sp => real32 , dp => real64 , qp => real128 use iso_fortran_env , only : int8 , int16 , int32 , int64 ! If we decide later to use iso_c_binding instead of iso_fortran_env: !use iso_c_binding, only: sp=>c_float, dp=>c_double, qp=>c_float128 !use iso_c_binding, only: int8=>c_int8_t, int16=>c_int16_t, int32=>c_int32_t, int64=>c_int64_t implicit none private public sp , dp , qp , int8 , int16 , int32 , int64 end module stdlib_kinds","tags":"","loc":"sourcefile/stdlib_kinds.f90.html"},{"title":"stdlib_ascii.f90 – Fortran-lang/stdlib","text":"Files dependent on this one sourcefile~~stdlib_ascii.f90~~AfferentGraph sourcefile~stdlib_ascii.f90 stdlib_ascii.f90 sourcefile~stdlib_logger.f90 stdlib_logger.f90 sourcefile~stdlib_logger.f90->sourcefile~stdlib_ascii.f90 sourcefile~stdlib_io.fypp stdlib_io.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_ascii.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_ascii Source Code stdlib_ascii.f90 Source Code module stdlib_ascii implicit none private ! Character validation functions public :: is_alpha , is_alphanum public :: is_digit , is_hex_digit , is_octal_digit public :: is_control , is_white , is_blank public :: is_ascii , is_punctuation public :: is_graphical , is_printable public :: is_lower , is_upper ! Character conversion functions public :: to_lower , to_upper ! All control characters in the ASCII table (see www.asciitable.com). character ( len = 1 ), public , parameter :: NUL = achar ( int ( z '00' )) !! Null character ( len = 1 ), public , parameter :: SOH = achar ( int ( z '01' )) !! Start of heading character ( len = 1 ), public , parameter :: STX = achar ( int ( z '02' )) !! Start of text character ( len = 1 ), public , parameter :: ETX = achar ( int ( z '03' )) !! End of text character ( len = 1 ), public , parameter :: EOT = achar ( int ( z '04' )) !! End of transmission character ( len = 1 ), public , parameter :: ENQ = achar ( int ( z '05' )) !! Enquiry character ( len = 1 ), public , parameter :: ACK = achar ( int ( z '06' )) !! Acknowledge character ( len = 1 ), public , parameter :: BEL = achar ( int ( z '07' )) !! Bell character ( len = 1 ), public , parameter :: BS = achar ( int ( z '08' )) !! Backspace character ( len = 1 ), public , parameter :: TAB = achar ( int ( z '09' )) !! Horizontal tab character ( len = 1 ), public , parameter :: LF = achar ( int ( z '0A' )) !! NL line feed, new line character ( len = 1 ), public , parameter :: VT = achar ( int ( z '0B' )) !! Vertical tab character ( len = 1 ), public , parameter :: FF = achar ( int ( z '0C' )) !! NP form feed, new page character ( len = 1 ), public , parameter :: CR = achar ( int ( z '0D' )) !! Carriage return character ( len = 1 ), public , parameter :: SO = achar ( int ( z '0E' )) !! Shift out character ( len = 1 ), public , parameter :: SI = achar ( int ( z '0F' )) !! Shift in character ( len = 1 ), public , parameter :: DLE = achar ( int ( z '10' )) !! Data link escape character ( len = 1 ), public , parameter :: DC1 = achar ( int ( z '11' )) !! Device control 1 character ( len = 1 ), public , parameter :: DC2 = achar ( int ( z '12' )) !! Device control 2 character ( len = 1 ), public , parameter :: DC3 = achar ( int ( z '13' )) !! Device control 3 character ( len = 1 ), public , parameter :: DC4 = achar ( int ( z '14' )) !! Device control 4 character ( len = 1 ), public , parameter :: NAK = achar ( int ( z '15' )) !! Negative acknowledge character ( len = 1 ), public , parameter :: SYN = achar ( int ( z '16' )) !! Synchronous idle character ( len = 1 ), public , parameter :: ETB = achar ( int ( z '17' )) !! End of transmission block character ( len = 1 ), public , parameter :: CAN = achar ( int ( z '18' )) !! Cancel character ( len = 1 ), public , parameter :: EM = achar ( int ( z '19' )) !! End of medium character ( len = 1 ), public , parameter :: SUB = achar ( int ( z '1A' )) !! Substitute character ( len = 1 ), public , parameter :: ESC = achar ( int ( z '1B' )) !! Escape character ( len = 1 ), public , parameter :: FS = achar ( int ( z '1C' )) !! File separator character ( len = 1 ), public , parameter :: GS = achar ( int ( z '1D' )) !! Group separator character ( len = 1 ), public , parameter :: RS = achar ( int ( z '1E' )) !! Record separator character ( len = 1 ), public , parameter :: US = achar ( int ( z '1F' )) !! Unit separator character ( len = 1 ), public , parameter :: DEL = achar ( int ( z '7F' )) !! Delete ! Constant character sequences character ( len =* ), public , parameter :: fullhex_digits = \"0123456789ABCDEFabcdef\" !! 0 .. 9A .. Fa .. f character ( len =* ), public , parameter :: hex_digits = fullhex_digits ( 1 : 16 ) !! 0 .. 9A .. F character ( len =* ), public , parameter :: lowerhex_digits = \"0123456789abcdef\" !! 0 .. 9a .. f character ( len =* ), public , parameter :: digits = hex_digits ( 1 : 10 ) !! 0 .. 9 character ( len =* ), public , parameter :: octal_digits = digits ( 1 : 8 ) !! 0 .. 7 character ( len =* ), public , parameter :: letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" !! A .. Za .. z character ( len =* ), public , parameter :: uppercase = letters ( 1 : 26 ) !! A .. Z character ( len =* ), public , parameter :: lowercase = letters ( 27 :) !! a .. z character ( len =* ), public , parameter :: whitespace = \" \" // TAB // VT // CR // LF // FF !! ASCII _whitespace character ( len = 26 ), parameter , private :: lower_case = 'abcdefghijklmnopqrstuvwxyz' character ( len = 26 ), parameter , private :: upper_case = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' contains !> Checks whether `c` is an ASCII letter (A .. Z, a .. z). pure logical function is_alpha ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) is_alpha = ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) . or . ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) end function !> Checks whether `c` is a letter or a number (0 .. 9, a .. z, A .. Z). pure logical function is_alphanum ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) is_alphanum = ( ic >= iachar ( '0' ) . and . ic <= iachar ( '9' )) . or . ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' )) & . or . ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' )) end function !> Checks whether or not `c` is in the ASCII character set - !  i.e. in the range 0 .. 0x7F. pure logical function is_ascii ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_ascii = iachar ( c ) <= int ( z '7F' ) end function !> Checks whether `c` is a control character. pure logical function is_control ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) is_control = ic < int ( z '20' ) . or . ic == int ( z '7F' ) end function !> Checks whether `c` is a digit (0 .. 9). pure logical function is_digit ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) is_digit = ( iachar ( '0' ) <= ic ) . and . ( ic <= iachar ( '9' )) end function !> Checks whether `c` is a digit in base 8 (0 .. 7). pure logical function is_octal_digit ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) is_octal_digit = ( ic >= iachar ( '0' )) . and . ( ic <= iachar ( '7' )) end function !> Checks whether `c` is a digit in base 16 (0 .. 9, A .. F, a .. f). pure logical function is_hex_digit ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) is_hex_digit = ( ic >= iachar ( '0' ) . and . ic <= iachar ( '9' )) . or . ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'f' )) & . or . ( ic >= iachar ( 'A' ) . and . ic <= iachar ( 'F' )) . or . ( ic >= iachar ( 'a' ) . and . ic <= iachar ( 'f' )) end function !> Checks whether or not `c` is a punctuation character. That includes !  all ASCII characters which are not control characters, letters, !  digits, or whitespace. pure logical function is_punctuation ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) !       '~'                 '!' is_punctuation = ( ic <= int ( z '7E' )) . and . ( ic >= int ( z '21' )) . and . & (. not . is_alphanum ( c )) end function !> Checks whether or not `c` is a printable character other than the !  space character. pure logical function is_graphical ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) !The character is graphical if it's between '!' and '~' in the ASCII table, !that is: printable but not a space is_graphical = ( int ( z '21' ) <= ic ) . and . ( ic <= int ( z '7E' )) end function !> Checks whether or not `c` is a printable character - including the !  space character. pure logical function is_printable ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) !The character is printable if it's between ' ' and '~' in the ASCII table is_printable = ic >= iachar ( ' ' ) . and . ic <= int ( z '7E' ) end function !> Checks whether `c` is a lowercase ASCII letter (a .. z). pure logical function is_lower ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) is_lower = ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' ) end function !> Checks whether `c` is an uppercase ASCII letter (A .. Z). pure logical function is_upper ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) is_upper = ic >= iachar ( 'A' ) . and . ic <= iachar ( 'Z' ) end function !> Checks whether or not `c` is a whitespace character. That includes the !  space, tab, vertical tab, form feed, carriage return, and linefeed !  characters. pure logical function is_white ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) ! TAB, LF, VT, FF, CR is_white = ic == iachar ( ' ' ) . or . ( ic >= int ( z '09' ) . and . ic <= int ( z '0D' )) end function !> Checks whether or not `c` is a blank character. That includes the !  only the space and tab characters pure logical function is_blank ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) ! TAB is_blank = ic == iachar ( ' ' ) . or . ic == int ( z '09' ) end function !> Returns the corresponding lowercase letter, if `c` is an uppercase !  ASCII character, otherwise `c` itself. pure function to_lower ( c ) result ( t ) character ( len = 1 ), intent ( in ) :: c !! A character. character ( len = 1 ) :: t integer :: k k = index ( upper_case , c ) if ( k > 0 ) then t = lower_case ( k : k ) else t = c endif end function !> Returns the corresponding uppercase letter, if `c` is a lowercase !  ASCII character, otherwise `c` itself. pure function to_upper ( c ) result ( t ) character ( len = 1 ), intent ( in ) :: c !! A character. character ( len = 1 ) :: t integer :: k k = index ( lower_case , c ) if ( k > 0 ) then t = upper_case ( k : k ) else t = c endif end function end module","tags":"","loc":"sourcefile/stdlib_ascii.f90.html"},{"title":"f08estop.f90 – Fortran-lang/stdlib","text":"This file depends on sourcefile~~f08estop.f90~~EfferentGraph sourcefile~f08estop.f90 f08estop.f90 sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~f08estop.f90->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules estop Source Code f08estop.f90 Source Code submodule ( stdlib_error ) estop implicit none contains module procedure error_stop ! Aborts the program with nonzero exit code ! this is a fallback for Fortran 2008 error stop (e.g. Intel 19.1/2020 compiler) ! ! The \"stop <character>\" statement generally has return code 0. ! To allow non-zero return code termination with character message, ! error_stop() uses the statement \"error stop\", which by default ! has exit code 1 and prints the message to stderr. ! An optional integer return code \"code\" may be specified. ! ! Example ! ------- ! ! call error_stop(\"Invalid argument\") write ( stderr , * ) msg if ( present ( code )) then select case ( code ) case ( 1 ) error stop 1 case ( 2 ) error stop 2 case ( 77 ) error stop 77 case default write ( stderr , * ) 'ERROR: code ' , code , ' was specified.' error stop end select else error stop endif end procedure end submodule","tags":"","loc":"sourcefile/f08estop.f90.html"},{"title":"stdlib_quadrature_trapz.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_quadrature_trapz.fypp~~EfferentGraph sourcefile~stdlib_quadrature_trapz.fypp stdlib_quadrature_trapz.fypp sourcefile~stdlib_quadrature.fypp stdlib_quadrature.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_quadrature.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_quadrature_trapz Source Code stdlib_quadrature_trapz.fypp Source Code #:include \"common.fypp\" submodule ( stdlib_quadrature ) stdlib_quadrature_trapz use stdlib_error , only : check implicit none contains # : for KIND in REAL_KINDS pure module function trapz_dx_$ { KIND }$ ( y , dx ) result ( integral ) real ( ${ KIND }$ ), dimension (:), intent ( in ) :: y real ( ${ KIND }$ ), intent ( in ) :: dx real ( ${ KIND }$ ) :: integral integer :: n n = size ( y ) select case ( n ) case ( 0 : 1 ) integral = 0.0 _${ KIND }$ case ( 2 ) integral = 0.5 _${ KIND }$ * dx * ( y ( 1 ) + y ( 2 )) case default integral = dx * ( sum ( y ( 2 : n - 1 )) + 0.5 _${ KIND }$ * ( y ( 1 ) + y ( n ))) end select end function trapz_dx_$ { KIND }$ # : endfor # : for KIND in REAL_KINDS module function trapz_x_$ { KIND }$ ( y , x ) result ( integral ) real ( ${ KIND }$ ), dimension (:), intent ( in ) :: y real ( ${ KIND }$ ), dimension (:), intent ( in ) :: x real ( ${ KIND }$ ) :: integral integer :: i integer :: n n = size ( y ) call check ( size ( x ) == n , \"trapz: Arguments `x` and `y` must be the same size.\" ) select case ( n ) case ( 0 : 1 ) integral = 0.0 _${ KIND }$ case ( 2 ) integral = 0.5 _${ KIND }$ * ( x ( 2 ) - x ( 1 )) * ( y ( 1 ) + y ( 2 )) case default integral = 0.0 _${ KIND }$ do i = 2 , n integral = integral + ( x ( i ) - x ( i - 1 )) * ( y ( i ) + y ( i - 1 )) end do integral = 0.5 _${ KIND }$ * integral end select end function trapz_x_$ { KIND }$ # : endfor # : for KIND in REAL_KINDS pure module function trapz_weights_$ { KIND }$ ( x ) result ( w ) real ( ${ KIND }$ ), dimension (:), intent ( in ) :: x real ( ${ KIND }$ ), dimension ( size ( x )) :: w integer :: i integer :: n n = size ( x ) select case ( n ) case ( 0 ) ! no action needed case ( 1 ) w ( 1 ) = 0.0 _${ KIND }$ case ( 2 ) w = 0.5 _${ KIND }$ * ( x ( 2 ) - x ( 1 )) case default w ( 1 ) = 0.5 _${ KIND }$ * ( x ( 2 ) - x ( 1 )) w ( n ) = 0.5 _${ KIND }$ * ( x ( n ) - x ( n - 1 )) do i = 2 , size ( x ) - 1 w ( i ) = 0.5 _${ KIND }$ * ( x ( i + 1 ) - x ( i - 1 )) end do end select end function trapz_weights_$ { KIND }$ #:endfor end submodule stdlib_quadrature_trapz","tags":"","loc":"sourcefile/stdlib_quadrature_trapz.fypp.html"},{"title":"stdlib_stats_var.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_var.fypp~~EfferentGraph sourcefile~stdlib_stats_var.fypp stdlib_stats_var.fypp sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_var Source Code stdlib_stats_var.fypp Source Code #:include \"common.fypp\" #:set RANKS = range(1, MAXRANK + 1) #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_var use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res real ( ${ k1 }$ ) :: n ${ t1 }$ :: mean if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if n = real ( size ( x , kind = int64 ), ${ k1 }$ ) mean = sum ( x ) / n # : if t1 [ 0 ] == 'r' res = sum (( x - mean ) ** 2 ) / ( n - merge ( 1 , 0 , optval ( corrected , . true .))) # : else res = sum ( abs ( x - mean ) ** 2 ) / ( n - merge ( 1 , 0 , optval ( corrected , . true .))) # : endif end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res real ( dp ) :: n , mean if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if n = real ( size ( x , kind = int64 ), dp ) mean = sum ( real ( x , dp )) / n res = sum (( real ( x , dp ) - mean ) ** 2 ) / ( n - merge ( 1 , 0 , optval ( corrected , . true .))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( ${ k1 }$ ) :: n ${ t1 }$ :: mean$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if res = 0. _${ k1 }$ select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) n = size ( x , dim ) mean = sum ( x , dim ) / n do i = 1 , size ( x , dim ) # : if t1 [ 0 ] == 'r' res = res + ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean ) ** 2 # : else res = res + abs ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean ) ** 2 # : endif end do # : endfor case default call error_stop ( \"ERROR (var): wrong dimension\" ) end select res = res / ( n - merge ( 1 , 0 , optval ( corrected , . true .))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( dp ) :: n real ( dp ) :: mean$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if res = 0._dp select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) n = size ( x , dim ) mean = sum ( real ( x , dp ), dim ) / n do i = 1 , size ( x , dim ) res = res + ( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - mean ) ** 2 end do # : endfor case default call error_stop ( \"ERROR (var): wrong dimension\" ) end select res = res / ( n - merge ( 1 , 0 , optval ( corrected , . true .))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res real ( ${ k1 }$ ) :: n ${ t1 }$ :: mean n = real ( count ( mask , kind = int64 ), ${ k1 }$ ) mean = sum ( x , mask ) / n # : if t1 [ 0 ] == 'r' res = sum (( x - mean ) ** 2 , mask ) / ( n - & # : else res = sum ( abs ( x - mean ) ** 2 , mask ) / ( n - & # : endif merge ( 1 , 0 , ( optval ( corrected , . true .) . and . n > 0 ))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( dp ) :: res real ( dp ) :: n , mean n = real ( count ( mask , kind = int64 ), dp ) mean = sum ( real ( x , dp ), mask ) / n res = sum (( real ( x , dp ) - mean ) ** 2 , mask ) / ( n - & merge ( 1 , 0 , ( optval ( corrected , . true .) . and . n > 0 ))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( ${ k1 }$ ) :: n$ { reduced_shape ( 'x' , rank , 'dim' ) }$ ${ t1 }$ :: mean$ { reduced_shape ( 'x' , rank , 'dim' ) }$ res = 0. _${ k1 }$ select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) n = count ( mask , dim ) mean = sum ( x , dim , mask ) / n do i = 1 , size ( x , dim ) # : if t1 [ 0 ] == 'r' res = res + merge ( ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean ) ** 2 ,& # : else res = res + merge ( abs ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean ) ** 2 ,& # : endif 0. _${ k1 }$ ,& mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do # : endfor case default call error_stop ( \"ERROR (var): wrong dimension\" ) end select res = res / ( n - merge ( 1 , 0 , ( optval ( corrected , . true .) . and . n > 0 ))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( dp ) :: n$ { reduced_shape ( 'x' , rank , 'dim' ) }$ real ( dp ) :: mean$ { reduced_shape ( 'x' , rank , 'dim' ) }$ res = 0._dp select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) n = count ( mask , dim ) mean = sum ( real ( x , dp ), dim , mask ) / n do i = 1 , size ( x , dim ) res = res + merge (( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - mean ) ** 2 ,& 0._dp , mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do # : endfor case default call error_stop ( \"ERROR (var): wrong dimension\" ) end select res = res / ( n - merge ( 1 , 0 , ( optval ( corrected , . true .) . and . n > 0 ))) end function ${ RName }$ # : endfor # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_var.fypp.html"},{"title":"f18estop.f90 – Fortran-lang/stdlib","text":"This file depends on sourcefile~~f18estop.f90~~EfferentGraph sourcefile~f18estop.f90 f18estop.f90 sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~f18estop.f90->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules estop Source Code f18estop.f90 Source Code submodule ( stdlib_error ) estop implicit none contains module procedure error_stop ! Aborts the program with nonzero exit code ! ! The \"stop <character>\" statement generally has return code 0. ! To allow non-zero return code termination with character message, ! error_stop() uses the statement \"error stop\", which by default ! has exit code 1 and prints the message to stderr. ! An optional integer return code \"code\" may be specified. ! ! Example ! ------- ! ! call error_stop(\"Invalid argument\") if ( present ( code )) then write ( stderr , * ) msg error stop code else error stop msg endif end procedure end submodule estop","tags":"","loc":"sourcefile/f18estop.f90.html"},{"title":"logger_type – Fortran-lang/stdlib ","text":"type, public :: logger_type Public derived type ( Specification ) Contents Finalization Procedures final_logger Type-Bound Procedures add_log_file add_log_unit configuration configure log_error log_information log_io_error log_message log_text_error log_units_assigned log_warning remove_log_unit Source Code logger_type Finalization Procedures final :: final_logger private subroutine final_logger(self) Finalizes the logger_type entity self by flushing the units Arguments Type Intent Optional Attributes Name type( logger_type ), intent(in) :: self Type-Bound Procedures procedure, public, pass(self) :: add_log_file private subroutine add_log_file(self, filename, unit, action, position, status, stat) Opens a formatted sequential access output file, filename using newunit and adds the resulting unit number to self 's log_units array. action , if present, is the action specifier of the open statement, and has the default value of \"write\" . position , if present,\n is the position specifier, and has the default value of \"REWIND\" . status , if present, is the status specifier of the open statement, and\n has the default value of \"REPLACE\" . stat , if present, has the value success if filename could be opened, read_only_error if action is \"read\" , and open_failure otherwise.\n( Specification ) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self The logger variable to which the file is to be added character(len=*), intent(in) :: filename The name of the file to be  added to the logger integer, intent(out), optional :: unit The resulting I/O unit number character(len=*), intent(in), optional :: action The action specifier for the `open`` statement character(len=*), intent(in), optional :: position The position specifier for the open statement character(len=*), intent(in), optional :: status The status specifier for the open statement integer, intent(out), optional :: stat The error status on exit with the possible values\n * success - no errors found\n * Rrea_only_error - file unopened as action1 was \"read\" for an output file\n * open_failure - the open` statement failed Example program main use stdlib_logger ... integer :: unit, stat ... call global_logger % add_log_file( 'error_log.txt', unit,      & position='asis', stat=stat ) if ( stat /= success ) then error stop 'Unable to open \"error_log.txt\".' end if ... end program main procedure, public, pass(self) :: add_log_unit private subroutine add_log_unit(self, unit, stat) Adds unit to the log file units in log_units . unit must be an open file, of form \"formatted\" , with \"sequential\" access , and an action of \"write\" or \"readwrite\" , otherwise either stat , if preseent, has a\n value other than success and unit is not entered into log_units ,\n or, if stat is not presecn, processing stops.\n( Specification ) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self The logger variable to which the I/O unit is to be added integer, intent(in) :: unit The input logical unit number integer, intent(out), optional :: stat An error code with the possible values\n * success - no problems were found\n * non_sequential_error - unit did not have sequential access\n * read_only_error - unit was not writeable\n * unformatted_in_error - unit was an 'unformatted' file\n * unopened_in_error - unit was not opened Example program main use stdlib_logger ... character(256) :: iomsg integer :: iostat, unit, stat ... open( newunit=unit, 'error_log.txt', form='formatted', & status='replace', position='rewind', err=999,  & action='read', iostat=iostat, iomsg=iomsg ) ... call global_logger % add_log_unit( unit, stat ) select case ( stat ) ... case ( read_only_error ) error stop 'Unable to write to \"error_log.txt\".' ... end select ... 999 error stop 'Unable to open \"error_log.txt\". ... end program main procedure, public, pass(self) :: configuration private pure subroutine configuration(self, add_blank_line, indent, max_width, time_stamp, log_units) Reports the logging configuration of self . The following attributes are\n reported:\n 1. add_blank_line is a logical flag with .true. implying that output\n    starts with a blank line, and .false. implying no blank line.\n 2. indent is a logical flag with .true. implying that subsequent columns\n    will be indented 4 spaces and .false. implying no indentation.\n 3. max_width is the maximum number of columns of output text with max_width == 0 => no bounds on output width.\n 4. time_stamp is a logical flag with .true. implying that the output\n    will have a time stamp, and .false. implying that there will be no\n    time stamp.\n 5. log_units is an array of the I/O unit numbers to which log output\n    will be written.\n( Specification ) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger variable whose configuration is being reported logical, intent(out), optional :: add_blank_line A logical flag to add a preceding blank line logical, intent(out), optional :: indent A logical flag to indent subsequent lines integer, intent(out), optional :: max_width The maximum number of columns for most outputs logical, intent(out), optional :: time_stamp A logical flag to add a time stamp integer, intent(out), optional allocatable :: log_units (:) The I/O units used in output Example module example_mod use stdlib_logger ... contains ... subroutine example_sub(unit, ...) integer, intent(in) :: unit ... integer, allocatable :: log_units(:) ... call global_logger % configuration( log_units=log_units ) if ( size(log_units) == 0 ) then call add_logger_unit( unit ) end if .. end subroutine example_sub ... end module example_mod procedure, public, pass(self) :: configure private pure subroutine configure(self, add_blank_line, indent, max_width, time_stamp) Configures the logging process for SELF. The following attributes are\n configured:\n 1. add_blank_line is a logical flag with .true. implying that output\n    starts with a blank line, and .false. implying no blank line. add_blank_line has a startup value of .false. .\n 2. indent is a logical flag with .true. implying that subsequent lines\n    will be indented 4 spaces and .false. implying no indentation. indent has a startup value of .true. .\n 3. max_width is the maximum number of columns of output text with max_width == 0 => no bounds on output width. max_width has a startup\n    value of 0.\n 4. time_stamp is a logical flag with .true. implying that the output\n    will have a time stamp, and .false. implying that there will be no\n    time stamp. time_stamp has a startup value of .true. .\n( Specification ) Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self logical, intent(in), optional :: add_blank_line logical, intent(in), optional :: indent integer, intent(in), optional :: max_width logical, intent(in), optional :: time_stamp procedure, public, pass(self) :: log_error private subroutine log_error(self, message, module, procedure, stat, errmsg) Writes the string message to self % log_units with optional additional\n text.\n ( Specification ) Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger to be used in logging the message character(len=*), intent(in) :: message A string to be written to log_unit character(len=*), intent(in), optional :: module The name of the module contining the current invocation of log_error character(len=*), intent(in), optional :: procedure The name of the procedure contining the current invocation of log_error integer, intent(in), optional :: stat The value of the stat specifier returned by a Fortran statement character(len=*), intent(in), optional :: errmsg The value of the errmsg specifier returned by a Fortran statement procedure, public, pass(self) :: log_information private subroutine log_information(self, message, module, procedure) Writes the string message to self % log_units with optional additional\n text.\n( Specification ) Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger used to send the message character(len=*), intent(in) :: message A string to be written to log_unit character(len=*), intent(in), optional :: module The name of the module contining the current invocation of log_information character(len=*), intent(in), optional :: procedure The name of the procedure contining the current invocation of log_information procedure, public, pass(self) :: log_io_error private subroutine log_io_error(self, message, module, procedure, iostat, iomsg) Writes the string message to the self % log_units with optional\n additional text.\n( Specification ) Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger variable to receivee the message character(len=*), intent(in) :: message A string to be written to LOG_UNIT character(len=*), intent(in), optional :: module The name of the module contining the current invocation of REPORT_ERROR character(len=*), intent(in), optional :: procedure The name of the procedure contining the current invocation of REPORT_ERROR integer, intent(in), optional :: iostat The value of the IOSTAT specifier returned by a Fortran I/O statement character(len=*), intent(in), optional :: iomsg The value of the IOMSG specifier returned by a Fortran I/O statement procedure, public, pass(self) :: log_message private subroutine log_message(self, message, module, procedure, prefix) Writes the string message to the self % log_units with optional\n additional text.\n( Specification ) Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger variable to receive the message character(len=*), intent(in) :: message A string to be written to log_unit character(len=*), intent(in), optional :: module The name of the module contining the current invocation of log_message character(len=*), intent(in), optional :: procedure The name of the procedure contining the current invocation of log_message character(len=*), intent(in), optional :: prefix To be prepended to message as prefix // ': ' // message . procedure, public, pass(self) :: log_text_error private subroutine log_text_error(self, line, column, summary, filename, line_number, caret, stat) Sends a message to self % log_units describing an error found\n in a line of text.\n( Specification ) Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger variable to receive the message character(len=*), intent(in) :: line The line of text in which the error was found. integer, intent(in) :: column The one's based column in LINE at which the error starts. character(len=*), intent(in) :: summary A brief description of the error. character(len=*), intent(in), optional :: filename The name of the file, if any, in which the error was found. integer, intent(in), optional :: line_number The one's based line number in the file where line was found. character(len=1), intent(in), optional :: caret The symbol used to mark the column wher the error was first detected integer, intent(out), optional :: stat Integer flag that an error has occurred. Has the value success if no\n error hass occurred, index_invalid_error if column is less than zero or\n greater than len(line) , and write_failure if any of the write statements\n has failed. procedure, public, pass(self) :: log_units_assigned private elemental function log_units_assigned(self) Returns the number of units assigned to self % log_units ( Specification ) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger subject to the inquiry Return Value integer Read more… procedure, public, pass(self) :: log_warning private subroutine log_warning(self, message, module, procedure) Writes the string message to self % log_units with optional additional text.\n( Specification ) Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self The logger to which the message is written character(len=*), intent(in) :: message A string to be written to LOG_UNIT character(len=*), intent(in), optional :: module The name of the module contining the current invocation of log_warning character(len=*), intent(in), optional :: procedure The name of the procedure contining the current invocation of log_warning procedure, public, pass(self) :: remove_log_unit private subroutine remove_log_unit(self, unit, close_unit, stat) Remove the I/O unit from the self % log_units list. If close_unit is\n present and .true. then the corresponding file is closed. If unit is\n not in log_units then nothing is done. If stat is present it, by default,\n has the value success . If closing the unit fails, then if stat is\n present it has the value close_failure , otherwise processing stops\n with an informative message.\n( Specification ) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self The logger variable whose unit is to be removed integer, intent(in) :: unit The I/O unit to be removed from self logical, intent(in), optional :: close_unit A logical flag to close the unit while removing it from the SELF list integer, intent(out), optional :: stat An error status with the values\n * success - no problems found\n * close_failure - the close statement for unit failed Example module  example_mod use stdlib_logger ... type(logger_type) ::  alogger contains ... subroutine example_sub(unit, ...) integer, intent(in) :: unit ... call alogger % remove_log_unit( unit ) ... end subroutine example_sub ... end module example_mod Source Code type :: logger_type !! version: experimental !! Public derived type ([Specification](../page/specs/stdlib_logger.html#the-derived-type-logger_type)) private logical :: add_blank_line = . false . logical :: indent_lines = . true . integer , allocatable :: log_units (:) integer :: max_width = 0 logical :: time_stamp = . true . integer :: units = 0 contains private procedure , public , pass ( self ) :: add_log_file procedure , public , pass ( self ) :: add_log_unit procedure , public , pass ( self ) :: configuration procedure , public , pass ( self ) :: configure procedure , public , pass ( self ) :: log_error procedure , public , pass ( self ) :: log_information procedure , public , pass ( self ) :: log_io_error procedure , public , pass ( self ) :: log_message procedure , public , pass ( self ) :: log_text_error procedure , public , pass ( self ) :: log_units_assigned procedure , public , pass ( self ) :: log_warning procedure , public , pass ( self ) :: remove_log_unit final :: final_logger end type logger_type","tags":"","loc":"type/logger_type.html"},{"title":"eye – Fortran-lang/stdlib","text":"public function eye(n) result(res) Constructs the identity matrix\n ( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer(kind=int8)\n  (n,n) Contents Variables i Source Code eye Variables Type Visibility Attributes Name Initial integer, public :: i Source Code function eye ( n ) result ( res ) !! version: experimental !! !! Constructs the identity matrix !! ([Specification](../page/specs/stdlib_linalg.html#description_1)) integer , intent ( in ) :: n integer ( int8 ) :: res ( n , n ) integer :: i res = 0 do i = 1 , n res ( i , i ) = 1 end do end function eye","tags":"","loc":"proc/eye.html"},{"title":"diag – Fortran-lang/stdlib","text":"public interface diag Creates a diagonal array or extract the diagonal elements of an array\n ( Specification ) Contents Functions diag_cdp diag_cdp_k diag_cdp_mat diag_cdp_mat_k diag_cqp diag_cqp_k diag_cqp_mat diag_cqp_mat_k diag_csp diag_csp_k diag_csp_mat diag_csp_mat_k diag_iint16 diag_iint16_k diag_iint16_mat diag_iint16_mat_k diag_iint32 diag_iint32_k diag_iint32_mat diag_iint32_mat_k diag_iint64 diag_iint64_k diag_iint64_mat diag_iint64_mat_k diag_iint8 diag_iint8_k diag_iint8_mat diag_iint8_mat_k diag_rdp diag_rdp_k diag_rdp_mat diag_rdp_mat_k diag_rqp diag_rqp_k diag_rqp_mat diag_rqp_mat_k diag_rsp diag_rsp_k diag_rsp_mat diag_rsp_mat_k Functions public function diag_cdp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: v (:) Return Value complex(kind=dp)\n  (size(v),size(v)) public function diag_cdp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=dp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_cdp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value complex(kind=dp)\n  (minval(shape(A))) public function diag_cdp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=dp)\n  (minval(shape(A))-abs(k)) public function diag_cqp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: v (:) Return Value complex(kind=qp)\n  (size(v),size(v)) public function diag_cqp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=qp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_cqp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) Return Value complex(kind=qp)\n  (minval(shape(A))) public function diag_cqp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=qp)\n  (minval(shape(A))-abs(k)) public function diag_csp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: v (:) Return Value complex(kind=sp)\n  (size(v),size(v)) public function diag_csp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=sp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_csp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value complex(kind=sp)\n  (minval(shape(A))) public function diag_csp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=sp)\n  (minval(shape(A))-abs(k)) public function diag_iint16(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: v (:) Return Value integer(kind=int16)\n  (size(v),size(v)) public function diag_iint16_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int16)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint16_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) Return Value integer(kind=int16)\n  (minval(shape(A))) public function diag_iint16_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int16)\n  (minval(shape(A))-abs(k)) public function diag_iint32(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: v (:) Return Value integer(kind=int32)\n  (size(v),size(v)) public function diag_iint32_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int32)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint32_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) Return Value integer(kind=int32)\n  (minval(shape(A))) public function diag_iint32_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int32)\n  (minval(shape(A))-abs(k)) public function diag_iint64(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: v (:) Return Value integer(kind=int64)\n  (size(v),size(v)) public function diag_iint64_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int64)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint64_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) Return Value integer(kind=int64)\n  (minval(shape(A))) public function diag_iint64_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int64)\n  (minval(shape(A))-abs(k)) public function diag_iint8(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: v (:) Return Value integer(kind=int8)\n  (size(v),size(v)) public function diag_iint8_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int8)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint8_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) Return Value integer(kind=int8)\n  (minval(shape(A))) public function diag_iint8_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int8)\n  (minval(shape(A))-abs(k)) public function diag_rdp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) Return Value real(kind=dp)\n  (size(v),size(v)) public function diag_rdp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=dp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rdp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp)\n  (minval(shape(A))) public function diag_rdp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=dp)\n  (minval(shape(A))-abs(k)) public function diag_rqp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: v (:) Return Value real(kind=qp)\n  (size(v),size(v)) public function diag_rqp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=qp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rqp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) Return Value real(kind=qp)\n  (minval(shape(A))) public function diag_rqp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=qp)\n  (minval(shape(A))-abs(k)) public function diag_rsp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: v (:) Return Value real(kind=sp)\n  (size(v),size(v)) public function diag_rsp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=sp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rsp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value real(kind=sp)\n  (minval(shape(A))) public function diag_rsp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=sp)\n  (minval(shape(A))-abs(k))","tags":"","loc":"interface/diag.html"},{"title":"trace – Fortran-lang/stdlib","text":"public interface trace Computes the trace of a matrix\n ( Specification ) Contents Module Procedures trace_rsp trace_rdp trace_rqp trace_csp trace_cdp trace_cqp trace_iint8 trace_iint16 trace_iint32 trace_iint64 Module Procedures private function trace_rsp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value real(kind=sp) private function trace_rdp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp) private function trace_rqp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) Return Value real(kind=qp) private function trace_csp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value complex(kind=sp) private function trace_cdp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value complex(kind=dp) private function trace_cqp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) Return Value complex(kind=qp) private function trace_iint8(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) Return Value integer(kind=int8) private function trace_iint16(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) Return Value integer(kind=int16) private function trace_iint32(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) Return Value integer(kind=int32) private function trace_iint64(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) Return Value integer(kind=int64)","tags":"","loc":"interface/trace.html"},{"title":"optval – Fortran-lang/stdlib","text":"public interface optval Fallback value for optional arguments\n ( Specification ) Called by interface~~optval~~CalledByGraph interface~optval optval proc~open open proc~open->interface~optval proc~check check proc~check->interface~optval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures optval_rsp optval_rdp optval_rqp optval_iint8 optval_iint16 optval_iint32 optval_iint64 optval_csp optval_cdp optval_cqp optval_ll1 optval_character Module Procedures private pure elemental function optval_rsp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), optional :: x real(kind=sp), intent(in) :: default Return Value real(kind=sp) private pure elemental function optval_rdp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional :: x real(kind=dp), intent(in) :: default Return Value real(kind=dp) private pure elemental function optval_rqp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), optional :: x real(kind=qp), intent(in) :: default Return Value real(kind=qp) private pure elemental function optval_iint8(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), optional :: x integer(kind=int8), intent(in) :: default Return Value integer(kind=int8) private pure elemental function optval_iint16(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), optional :: x integer(kind=int16), intent(in) :: default Return Value integer(kind=int16) private pure elemental function optval_iint32(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), optional :: x integer(kind=int32), intent(in) :: default Return Value integer(kind=int32) private pure elemental function optval_iint64(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), optional :: x integer(kind=int64), intent(in) :: default Return Value integer(kind=int64) private pure elemental function optval_csp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), optional :: x complex(kind=sp), intent(in) :: default Return Value complex(kind=sp) private pure elemental function optval_cdp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), optional :: x complex(kind=dp), intent(in) :: default Return Value complex(kind=dp) private pure elemental function optval_cqp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), optional :: x complex(kind=qp), intent(in) :: default Return Value complex(kind=qp) private pure elemental function optval_ll1(x, default) result(y) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: x logical, intent(in) :: default Return Value logical private pure function optval_character(x, default) result(y) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: x character(len=*), intent(in) :: default Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/optval.html"},{"title":"corr – Fortran-lang/stdlib","text":"public interface corr Pearson correlation of array elements\n ( Specification ) Contents Functions corr_1_cdp_cdp corr_1_cqp_cqp corr_1_csp_csp corr_1_iint16_dp corr_1_iint32_dp corr_1_iint64_dp corr_1_iint8_dp corr_1_rdp_rdp corr_1_rqp_rqp corr_1_rsp_rsp corr_2_cdp_cdp corr_2_cqp_cqp corr_2_csp_csp corr_2_iint16_dp corr_2_iint32_dp corr_2_iint64_dp corr_2_iint8_dp corr_2_rdp_rdp corr_2_rqp_rqp corr_2_rsp_rsp corr_mask_1_cdp_cdp corr_mask_1_cqp_cqp corr_mask_1_csp_csp corr_mask_1_iint16_dp corr_mask_1_iint32_dp corr_mask_1_iint64_dp corr_mask_1_iint8_dp corr_mask_1_rdp_rdp corr_mask_1_rqp_rqp corr_mask_1_rsp_rsp corr_mask_2_cdp_cdp corr_mask_2_cqp_cqp corr_mask_2_csp_csp corr_mask_2_iint16_dp corr_mask_2_iint32_dp corr_mask_2_iint64_dp corr_mask_2_iint8_dp corr_mask_2_rdp_rdp corr_mask_2_rqp_rqp corr_mask_2_rsp_rsp Functions public function corr_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function corr_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function corr_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function corr_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function corr_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function corr_mask_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function corr_mask_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function corr_mask_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function corr_mask_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1","tags":"","loc":"interface/corr.html"},{"title":"cov – Fortran-lang/stdlib","text":"public interface cov Covariance of array elements\n ( Specification ) Contents Functions cov_1_cdp_cdp cov_1_cqp_cqp cov_1_csp_csp cov_1_iint16_dp cov_1_iint32_dp cov_1_iint64_dp cov_1_iint8_dp cov_1_rdp_rdp cov_1_rqp_rqp cov_1_rsp_rsp cov_2_cdp_cdp cov_2_cqp_cqp cov_2_csp_csp cov_2_iint16_dp cov_2_iint32_dp cov_2_iint64_dp cov_2_iint8_dp cov_2_rdp_rdp cov_2_rqp_rqp cov_2_rsp_rsp cov_mask_1_cdp_cdp cov_mask_1_cqp_cqp cov_mask_1_csp_csp cov_mask_1_iint16_dp cov_mask_1_iint32_dp cov_mask_1_iint64_dp cov_mask_1_iint8_dp cov_mask_1_rdp_rdp cov_mask_1_rqp_rqp cov_mask_1_rsp_rsp cov_mask_2_cdp_cdp cov_mask_2_cqp_cqp cov_mask_2_csp_csp cov_mask_2_iint16_dp cov_mask_2_iint32_dp cov_mask_2_iint64_dp cov_mask_2_iint8_dp cov_mask_2_rdp_rdp cov_mask_2_rqp_rqp cov_mask_2_rsp_rsp Functions public function cov_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_mask_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_mask_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_mask_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_mask_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1","tags":"","loc":"interface/cov.html"},{"title":"mean – Fortran-lang/stdlib","text":"public interface mean Mean of array elements\n ( Specification ) Contents Functions mean_1_cdp_cdp mean_1_cqp_cqp mean_1_csp_csp mean_1_iint16_dp mean_1_iint32_dp mean_1_iint64_dp mean_1_iint8_dp mean_1_rdp_rdp mean_1_rqp_rqp mean_1_rsp_rsp mean_2_cdp_cdp mean_2_cqp_cqp mean_2_csp_csp mean_2_iint16_dp mean_2_iint32_dp mean_2_iint64_dp mean_2_iint8_dp mean_2_rdp_rdp mean_2_rqp_rqp mean_2_rsp_rsp mean_3_cdp_cdp mean_3_cqp_cqp mean_3_csp_csp mean_3_iint16_dp mean_3_iint32_dp mean_3_iint64_dp mean_3_iint8_dp mean_3_rdp_rdp mean_3_rqp_rqp mean_3_rsp_rsp mean_all_1_cdp_cdp mean_all_1_cqp_cqp mean_all_1_csp_csp mean_all_1_iint16_dp mean_all_1_iint32_dp mean_all_1_iint64_dp mean_all_1_iint8_dp mean_all_1_rdp_rdp mean_all_1_rqp_rqp mean_all_1_rsp_rsp mean_all_2_cdp_cdp mean_all_2_cqp_cqp mean_all_2_csp_csp mean_all_2_iint16_dp mean_all_2_iint32_dp mean_all_2_iint64_dp mean_all_2_iint8_dp mean_all_2_rdp_rdp mean_all_2_rqp_rqp mean_all_2_rsp_rsp mean_all_3_cdp_cdp mean_all_3_cqp_cqp mean_all_3_csp_csp mean_all_3_iint16_dp mean_all_3_iint32_dp mean_all_3_iint64_dp mean_all_3_iint8_dp mean_all_3_rdp_rdp mean_all_3_rqp_rqp mean_all_3_rsp_rsp mean_mask_1_cdp_cdp mean_mask_1_cqp_cqp mean_mask_1_csp_csp mean_mask_1_iint16_dp mean_mask_1_iint32_dp mean_mask_1_iint64_dp mean_mask_1_iint8_dp mean_mask_1_rdp_rdp mean_mask_1_rqp_rqp mean_mask_1_rsp_rsp mean_mask_2_cdp_cdp mean_mask_2_cqp_cqp mean_mask_2_csp_csp mean_mask_2_iint16_dp mean_mask_2_iint32_dp mean_mask_2_iint64_dp mean_mask_2_iint8_dp mean_mask_2_rdp_rdp mean_mask_2_rqp_rqp mean_mask_2_rsp_rsp mean_mask_3_cdp_cdp mean_mask_3_cqp_cqp mean_mask_3_csp_csp mean_mask_3_iint16_dp mean_mask_3_iint32_dp mean_mask_3_iint64_dp mean_mask_3_iint8_dp mean_mask_3_rdp_rdp mean_mask_3_rqp_rqp mean_mask_3_rsp_rsp mean_mask_all_1_cdp_cdp mean_mask_all_1_cqp_cqp mean_mask_all_1_csp_csp mean_mask_all_1_iint16_dp mean_mask_all_1_iint32_dp mean_mask_all_1_iint64_dp mean_mask_all_1_iint8_dp mean_mask_all_1_rdp_rdp mean_mask_all_1_rqp_rqp mean_mask_all_1_rsp_rsp mean_mask_all_2_cdp_cdp mean_mask_all_2_cqp_cqp mean_mask_all_2_csp_csp mean_mask_all_2_iint16_dp mean_mask_all_2_iint32_dp mean_mask_all_2_iint64_dp mean_mask_all_2_iint8_dp mean_mask_all_2_rdp_rdp mean_mask_all_2_rqp_rqp mean_mask_all_2_rsp_rsp mean_mask_all_3_cdp_cdp mean_mask_all_3_cqp_cqp mean_mask_all_3_csp_csp mean_mask_all_3_iint16_dp mean_mask_all_3_iint32_dp mean_mask_all_3_iint64_dp mean_mask_all_3_iint8_dp mean_mask_all_3_rdp_rdp mean_mask_all_3_rqp_rqp mean_mask_all_3_rsp_rsp Functions public function mean_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_all_1_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_1_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_1_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_1_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_1_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_all_2_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_2_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_2_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_2_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_2_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_all_3_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_3_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_3_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_3_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_3_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_mask_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function mean_mask_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function mean_mask_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function mean_mask_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function mean_mask_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function mean_mask_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_all_1_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function mean_mask_all_1_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function mean_mask_all_1_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function mean_mask_all_1_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=qp) public function mean_mask_all_1_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=sp) public function mean_mask_all_2_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=dp) public function mean_mask_all_2_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=qp) public function mean_mask_all_2_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=sp) public function mean_mask_all_2_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=qp) public function mean_mask_all_2_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=sp) public function mean_mask_all_3_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp) public function mean_mask_all_3_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp) public function mean_mask_all_3_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp) public function mean_mask_all_3_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp) public function mean_mask_all_3_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)","tags":"","loc":"interface/mean.html"},{"title":"moment – Fortran-lang/stdlib","text":"public interface moment Central moment of array elements\n ( Specification ) Contents Functions moment_1_cdp_cdp moment_1_cqp_cqp moment_1_csp_csp moment_1_iint16_dp moment_1_iint32_dp moment_1_iint64_dp moment_1_iint8_dp moment_1_rdp_rdp moment_1_rqp_rqp moment_1_rsp_rsp moment_2_cdp_cdp moment_2_cqp_cqp moment_2_csp_csp moment_2_iint16_dp moment_2_iint32_dp moment_2_iint64_dp moment_2_iint8_dp moment_2_rdp_rdp moment_2_rqp_rqp moment_2_rsp_rsp moment_3_cdp_cdp moment_3_cqp_cqp moment_3_csp_csp moment_3_iint16_dp moment_3_iint32_dp moment_3_iint64_dp moment_3_iint8_dp moment_3_rdp_rdp moment_3_rqp_rqp moment_3_rsp_rsp moment_all_1_cdp_cdp moment_all_1_cqp_cqp moment_all_1_csp_csp moment_all_1_iint16_dp moment_all_1_iint32_dp moment_all_1_iint64_dp moment_all_1_iint8_dp moment_all_1_rdp_rdp moment_all_1_rqp_rqp moment_all_1_rsp_rsp moment_all_2_cdp_cdp moment_all_2_cqp_cqp moment_all_2_csp_csp moment_all_2_iint16_dp moment_all_2_iint32_dp moment_all_2_iint64_dp moment_all_2_iint8_dp moment_all_2_rdp_rdp moment_all_2_rqp_rqp moment_all_2_rsp_rsp moment_all_3_cdp_cdp moment_all_3_cqp_cqp moment_all_3_csp_csp moment_all_3_iint16_dp moment_all_3_iint32_dp moment_all_3_iint64_dp moment_all_3_iint8_dp moment_all_3_rdp_rdp moment_all_3_rqp_rqp moment_all_3_rsp_rsp moment_mask_1_cdp_cdp moment_mask_1_cqp_cqp moment_mask_1_csp_csp moment_mask_1_iint16_dp moment_mask_1_iint32_dp moment_mask_1_iint64_dp moment_mask_1_iint8_dp moment_mask_1_rdp_rdp moment_mask_1_rqp_rqp moment_mask_1_rsp_rsp moment_mask_2_cdp_cdp moment_mask_2_cqp_cqp moment_mask_2_csp_csp moment_mask_2_iint16_dp moment_mask_2_iint32_dp moment_mask_2_iint64_dp moment_mask_2_iint8_dp moment_mask_2_rdp_rdp moment_mask_2_rqp_rqp moment_mask_2_rsp_rsp moment_mask_3_cdp_cdp moment_mask_3_cqp_cqp moment_mask_3_csp_csp moment_mask_3_iint16_dp moment_mask_3_iint32_dp moment_mask_3_iint64_dp moment_mask_3_iint8_dp moment_mask_3_rdp_rdp moment_mask_3_rqp_rqp moment_mask_3_rsp_rsp moment_mask_all_1_cdp_cdp moment_mask_all_1_cqp_cqp moment_mask_all_1_csp_csp moment_mask_all_1_iint16_dp moment_mask_all_1_iint32_dp moment_mask_all_1_iint64_dp moment_mask_all_1_iint8_dp moment_mask_all_1_rdp_rdp moment_mask_all_1_rqp_rqp moment_mask_all_1_rsp_rsp moment_mask_all_2_cdp_cdp moment_mask_all_2_cqp_cqp moment_mask_all_2_csp_csp moment_mask_all_2_iint16_dp moment_mask_all_2_iint32_dp moment_mask_all_2_iint64_dp moment_mask_all_2_iint8_dp moment_mask_all_2_rdp_rdp moment_mask_all_2_rqp_rqp moment_mask_all_2_rsp_rsp moment_mask_all_3_cdp_cdp moment_mask_all_3_cqp_cqp moment_mask_all_3_csp_csp moment_mask_all_3_iint16_dp moment_mask_all_3_iint32_dp moment_mask_all_3_iint64_dp moment_mask_all_3_iint8_dp moment_mask_all_3_rdp_rdp moment_mask_all_3_rqp_rqp moment_mask_all_3_rsp_rsp moment_mask_scalar_2_cdp_cdp moment_mask_scalar_2_cqp_cqp moment_mask_scalar_2_csp_csp moment_mask_scalar_2_iint16_dp moment_mask_scalar_2_iint32_dp moment_mask_scalar_2_iint64_dp moment_mask_scalar_2_iint8_dp moment_mask_scalar_2_rdp_rdp moment_mask_scalar_2_rqp_rqp moment_mask_scalar_2_rsp_rsp moment_mask_scalar_3_cdp_cdp moment_mask_scalar_3_cqp_cqp moment_mask_scalar_3_csp_csp moment_mask_scalar_3_iint16_dp moment_mask_scalar_3_iint32_dp moment_mask_scalar_3_iint64_dp moment_mask_scalar_3_iint8_dp moment_mask_scalar_3_rdp_rdp moment_mask_scalar_3_rqp_rqp moment_mask_scalar_3_rsp_rsp moment_scalar_2_cdp_cdp moment_scalar_2_cqp_cqp moment_scalar_2_csp_csp moment_scalar_2_iint16_dp moment_scalar_2_iint32_dp moment_scalar_2_iint64_dp moment_scalar_2_iint8_dp moment_scalar_2_rdp_rdp moment_scalar_2_rqp_rqp moment_scalar_2_rsp_rsp moment_scalar_3_cdp_cdp moment_scalar_3_cqp_cqp moment_scalar_3_csp_csp moment_scalar_3_iint16_dp moment_scalar_3_iint32_dp moment_scalar_3_iint64_dp moment_scalar_3_iint8_dp moment_scalar_3_rdp_rdp moment_scalar_3_rqp_rqp moment_scalar_3_rsp_rsp Functions public function moment_1_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_1_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_1_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_1_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_1_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_all_1_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_1_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_1_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_1_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_1_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_all_2_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_2_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_2_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_2_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_2_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_all_3_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_3_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_3_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_3_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_3_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_mask_1_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function moment_mask_1_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function moment_mask_1_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function moment_mask_1_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=qp) public function moment_mask_1_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=sp) public function moment_mask_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_all_1_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function moment_mask_all_1_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function moment_mask_all_1_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function moment_mask_all_1_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=qp) public function moment_mask_all_1_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=sp) public function moment_mask_all_2_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=dp) public function moment_mask_all_2_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=qp) public function moment_mask_all_2_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=sp) public function moment_mask_all_2_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=qp) public function moment_mask_all_2_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=sp) public function moment_mask_all_3_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp) public function moment_mask_all_3_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp) public function moment_mask_all_3_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp) public function moment_mask_all_3_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp) public function moment_mask_all_3_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp) public function moment_mask_scalar_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1","tags":"","loc":"interface/moment.html"},{"title":"var – Fortran-lang/stdlib","text":"public interface var Variance of array elements\n ( Specification ) Contents Functions var_1_cdp_cdp var_1_cqp_cqp var_1_csp_csp var_1_iint16_dp var_1_iint32_dp var_1_iint64_dp var_1_iint8_dp var_1_rdp_rdp var_1_rqp_rqp var_1_rsp_rsp var_2_cdp_cdp var_2_cqp_cqp var_2_csp_csp var_2_iint16_dp var_2_iint32_dp var_2_iint64_dp var_2_iint8_dp var_2_rdp_rdp var_2_rqp_rqp var_2_rsp_rsp var_3_cdp_cdp var_3_cqp_cqp var_3_csp_csp var_3_iint16_dp var_3_iint32_dp var_3_iint64_dp var_3_iint8_dp var_3_rdp_rdp var_3_rqp_rqp var_3_rsp_rsp var_all_1_cdp_cdp var_all_1_cqp_cqp var_all_1_csp_csp var_all_1_iint16_dp var_all_1_iint32_dp var_all_1_iint64_dp var_all_1_iint8_dp var_all_1_rdp_rdp var_all_1_rqp_rqp var_all_1_rsp_rsp var_all_2_cdp_cdp var_all_2_cqp_cqp var_all_2_csp_csp var_all_2_iint16_dp var_all_2_iint32_dp var_all_2_iint64_dp var_all_2_iint8_dp var_all_2_rdp_rdp var_all_2_rqp_rqp var_all_2_rsp_rsp var_all_3_cdp_cdp var_all_3_cqp_cqp var_all_3_csp_csp var_all_3_iint16_dp var_all_3_iint32_dp var_all_3_iint64_dp var_all_3_iint8_dp var_all_3_rdp_rdp var_all_3_rqp_rqp var_all_3_rsp_rsp var_mask_1_cdp_cdp var_mask_1_cqp_cqp var_mask_1_csp_csp var_mask_1_iint16_dp var_mask_1_iint32_dp var_mask_1_iint64_dp var_mask_1_iint8_dp var_mask_1_rdp_rdp var_mask_1_rqp_rqp var_mask_1_rsp_rsp var_mask_2_cdp_cdp var_mask_2_cqp_cqp var_mask_2_csp_csp var_mask_2_iint16_dp var_mask_2_iint32_dp var_mask_2_iint64_dp var_mask_2_iint8_dp var_mask_2_rdp_rdp var_mask_2_rqp_rqp var_mask_2_rsp_rsp var_mask_3_cdp_cdp var_mask_3_cqp_cqp var_mask_3_csp_csp var_mask_3_iint16_dp var_mask_3_iint32_dp var_mask_3_iint64_dp var_mask_3_iint8_dp var_mask_3_rdp_rdp var_mask_3_rqp_rqp var_mask_3_rsp_rsp var_mask_all_1_cdp_cdp var_mask_all_1_cqp_cqp var_mask_all_1_csp_csp var_mask_all_1_iint16_dp var_mask_all_1_iint32_dp var_mask_all_1_iint64_dp var_mask_all_1_iint8_dp var_mask_all_1_rdp_rdp var_mask_all_1_rqp_rqp var_mask_all_1_rsp_rsp var_mask_all_2_cdp_cdp var_mask_all_2_cqp_cqp var_mask_all_2_csp_csp var_mask_all_2_iint16_dp var_mask_all_2_iint32_dp var_mask_all_2_iint64_dp var_mask_all_2_iint8_dp var_mask_all_2_rdp_rdp var_mask_all_2_rqp_rqp var_mask_all_2_rsp_rsp var_mask_all_3_cdp_cdp var_mask_all_3_cqp_cqp var_mask_all_3_csp_csp var_mask_all_3_iint16_dp var_mask_all_3_iint32_dp var_mask_all_3_iint64_dp var_mask_all_3_iint8_dp var_mask_all_3_rdp_rdp var_mask_all_3_rqp_rqp var_mask_all_3_rsp_rsp Functions public function var_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_all_1_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_1_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_1_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_1_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_2_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_2_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_2_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_2_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_3_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_3_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_3_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_3_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_all_1_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_1_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_1_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_1_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_2_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_2_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_2_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_2_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_3_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_3_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_3_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_3_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)","tags":"","loc":"interface/var.html"},{"title":"open – Fortran-lang/stdlib","text":"public function open(filename, mode, iostat) result(u) Opens a file\n ( Specification ) Behavior To open a file to read: u = open ( \"somefile.txt\" ) ! The default `mode` is \"rt\" u = open ( \"somefile.txt\" , \"r\" ) To open a file to write: u = open ( \"somefile.txt\" , \"w\" ) To append to the end of the file if it exists: u = open ( \"somefile.txt\" , \"a\" ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: mode integer, intent(out), optional :: iostat Return Value integer Calls proc~~open~~CallsGraph proc~open open proc~parse_mode parse_mode proc~open->proc~parse_mode interface~optval optval proc~open->interface~optval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables access_ action_ form_ mode_ position_ status_ Source Code open Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: access_ character(len=:), public, allocatable :: action_ character(len=:), public, allocatable :: form_ character(len=3), public :: mode_ character(len=:), public, allocatable :: position_ character(len=:), public, allocatable :: status_ Source Code integer function open ( filename , mode , iostat ) result ( u ) !! version: experimental !! !! Opens a file !! ([Specification](../page/specs/stdlib_io.html#description_1)) !! !!##### Behavior !! !! !! To open a file to read: !! !!```fortran !! u = open(\"somefile.txt\")        ! The default `mode` is \"rt\" !! u = open(\"somefile.txt\", \"r\") !!``` !! !! To open a file to write: !! !!```fortran !! u = open(\"somefile.txt\", \"w\") !!``` !! !! To append to the end of the file if it exists: !! !!```fortran !! u = open(\"somefile.txt\", \"a\") !!``` character ( * ), intent ( in ) :: filename character ( * ), intent ( in ), optional :: mode integer , intent ( out ), optional :: iostat character ( 3 ) :: mode_ character (:), allocatable :: action_ , position_ , status_ , access_ , form_ mode_ = parse_mode ( optval ( mode , \"\" )) select case ( mode_ ( 1 : 2 )) case ( 'r' ) action_ = 'read' position_ = 'asis' status_ = 'old' case ( 'w' ) action_ = 'write' position_ = 'asis' status_ = 'replace' case ( 'a' ) action_ = 'write' position_ = 'append' status_ = 'old' case ( 'x' ) action_ = 'write' position_ = 'asis' status_ = 'new' case ( 'r+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'old' case ( 'w+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'replace' case ( 'a+' ) action_ = 'readwrite' position_ = 'append' status_ = 'old' case ( 'x+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'new' case default call error_stop ( \"Unsupported mode: \" // mode_ ( 1 : 2 )) end select select case ( mode_ ( 3 : 3 )) case ( 't' ) form_ = 'formatted' case ( 'b' ) form_ = 'unformatted' case default call error_stop ( \"Unsupported mode: \" // mode_ ( 3 : 3 )) end select access_ = 'stream' if ( present ( iostat )) then open ( newunit = u , file = filename , & action = action_ , position = position_ , status = status_ , & access = access_ , form = form_ , & iostat = iostat ) else open ( newunit = u , file = filename , & action = action_ , position = position_ , status = status_ , & access = access_ , form = form_ ) end if end function open","tags":"","loc":"proc/open.html"},{"title":"parse_mode – Fortran-lang/stdlib","text":"public function parse_mode(mode) result(mode_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mode Return Value character(len=3) Called by proc~~parse_mode~~CalledByGraph proc~parse_mode parse_mode proc~open open proc~open->proc~parse_mode Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a i lfirst Source Code parse_mode Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: a integer, public :: i logical, public :: lfirst (3) Source Code character ( 3 ) function parse_mode ( mode ) result ( mode_ ) character ( * ), intent ( in ) :: mode integer :: i character (:), allocatable :: a logical :: lfirst ( 3 ) mode_ = 'r t' if ( len_trim ( mode ) == 0 ) return a = trim ( adjustl ( mode )) lfirst = . true . do i = 1 , len ( a ) if ( lfirst ( 1 ) & . and . ( a ( i : i ) == 'r' . or . a ( i : i ) == 'w' . or . a ( i : i ) == 'a' . or . a ( i : i ) == 'x' ) & ) then mode_ ( 1 : 1 ) = a ( i : i ) lfirst ( 1 ) = . false . else if ( lfirst ( 2 ) . and . a ( i : i ) == '+' ) then mode_ ( 2 : 2 ) = a ( i : i ) lfirst ( 2 ) = . false . else if ( lfirst ( 3 ) . and . ( a ( i : i ) == 't' . or . a ( i : i ) == 'b' )) then mode_ ( 3 : 3 ) = a ( i : i ) lfirst ( 3 ) = . false . else if ( a ( i : i ) == ' ' ) then cycle else if ( any (. not . lfirst )) then call error_stop ( \"Wrong mode: \" // trim ( a )) else call error_stop ( \"Wrong character: \" // a ( i : i )) endif end do end function parse_mode","tags":"","loc":"proc/parse_mode.html"},{"title":"loadtxt – Fortran-lang/stdlib","text":"public interface loadtxt Loads a 2D array from a text file\n ( Specification ) Contents Module Procedures loadtxt_rsp loadtxt_rdp loadtxt_rqp loadtxt_iint8 loadtxt_iint16 loadtxt_iint32 loadtxt_iint64 loadtxt_csp loadtxt_cdp loadtxt_cqp Module Procedures private subroutine loadtxt_rsp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=sp), intent(out), allocatable :: d (:,:) Example real ( sp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_rdp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=dp), intent(out), allocatable :: d (:,:) Example real ( dp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_rqp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=qp), intent(out), allocatable :: d (:,:) Example real ( qp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint8(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int8), intent(out), allocatable :: d (:,:) Example integer ( int8 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint16(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int16), intent(out), allocatable :: d (:,:) Example integer ( int16 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint32(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int32), intent(out), allocatable :: d (:,:) Example integer ( int32 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint64(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int64), intent(out), allocatable :: d (:,:) Example integer ( int64 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_csp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=sp), intent(out), allocatable :: d (:,:) Example complex ( sp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_cdp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=dp), intent(out), allocatable :: d (:,:) Example complex ( dp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_cqp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=qp), intent(out), allocatable :: d (:,:) Example complex ( qp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ...","tags":"","loc":"interface/loadtxt.html"},{"title":"savetxt – Fortran-lang/stdlib","text":"public interface savetxt Saves a 2D array into a text file\n ( Specification ) Contents Module Procedures savetxt_rsp savetxt_rdp savetxt_rqp savetxt_iint8 savetxt_iint16 savetxt_iint32 savetxt_iint64 savetxt_csp savetxt_cdp savetxt_cqp Module Procedures private subroutine savetxt_rsp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(in) :: d (:,:) Example real ( sp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_rdp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in) :: d (:,:) Example real ( dp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_rqp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(in) :: d (:,:) Example real ( qp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint8(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(in) :: d (:,:) Example integer ( int8 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint16(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(in) :: d (:,:) Example integer ( int16 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint32(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(in) :: d (:,:) Example integer ( int32 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint64(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(in) :: d (:,:) Example integer ( int64 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_csp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(in) :: d (:,:) Example complex ( sp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_cdp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(in) :: d (:,:) Example complex ( dp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_cqp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(in) :: d (:,:) Example complex ( qp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data )","tags":"","loc":"interface/savetxt.html"},{"title":"check – Fortran-lang/stdlib","text":"public subroutine check(condition, msg, code, warn) Checks the value of a logical condition\n ( Specification ) Behavior If condition == .false. and: No other arguments are provided, it stops the program with the default\n     message and exit code 1 ; msg is provided, it prints the value of msg ; code is provided, it stops the program with the given exit code; warn is provided and .true. , it doesn't stop the program and prints\n     the message. Examples If a /= 5 , stops the program with exit code 1 and prints Check failed. call check ( a == 5 ) As above, but prints a == 5 failed . call check ( a == 5 , msg = 'a == 5 failed.' ) As above, but doesn't stop the program. call check ( a == 5 , msg = 'a == 5 failed.' , warn = . true .) As example #2, but stops the program with exit code 77 call check ( a == 5 , msg = 'a == 5 failed.' , code = 77 ) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in), optional :: msg integer, intent(in), optional :: code logical, intent(in), optional :: warn Calls proc~~check~~CallsGraph proc~check check interface~optval optval proc~check->interface~optval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables msg_default Source Code check Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: msg_default = 'Check failed.' Source Code subroutine check ( condition , msg , code , warn ) !! version: experimental !! !! Checks the value of a logical condition !! ([Specification](../page/specs/stdlib_error.html#description)) !! !!##### Behavior !! !! If `condition == .false.` and: !! !!   * No other arguments are provided, it stops the program with the default !!     message and exit code `1`; !!   * `msg` is provided, it prints the value of `msg`; !!   * `code` is provided, it stops the program with the given exit code; !!   * `warn` is provided and `.true.`, it doesn't stop the program and prints !!     the message. !! !!##### Examples !! !!* If `a /= 5`, stops the program with exit code `1` !!  and prints `Check failed.` !!``` fortran !!  call check(a == 5) !!``` !! !!* As above, but prints `a == 5 failed`. !!``` fortran !!  call check(a == 5, msg='a == 5 failed.') !!``` !! !!* As above, but doesn't stop the program. !!``` fortran !!  call check(a == 5, msg='a == 5 failed.', warn=.true.) !!``` !! !!* As example #2, but stops the program with exit code `77` !!``` fortran !!  call check(a == 5, msg='a == 5 failed.', code=77) !!``` ! ! Arguments ! --------- logical , intent ( in ) :: condition character ( * ), intent ( in ), optional :: msg integer , intent ( in ), optional :: code logical , intent ( in ), optional :: warn character ( * ), parameter :: msg_default = 'Check failed.' if (. not . condition ) then if ( optval ( warn , . false .)) then write ( stderr , * ) optval ( msg , msg_default ) else call error_stop ( optval ( msg , msg_default ), optval ( code , 1 )) end if end if end subroutine check","tags":"","loc":"proc/check.html"},{"title":"error_stop – Fortran-lang/stdlib","text":"interface public module subroutine error_stop(msg, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg integer, intent(in), optional :: code Description Provides a call to error stop and allows the user to specify a code and message\n ( Specification )","tags":"","loc":"interface/error_stop.html"},{"title":"simps – Fortran-lang/stdlib","text":"public interface simps Integrates sampled values using Simpson's rule\n ( Specification ) Contents Functions simps_dx_dp simps_dx_qp simps_dx_sp simps_x_dp simps_x_qp simps_x_sp Functions public pure recursive function simps_dx_dp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=dp) public pure recursive function simps_dx_qp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=qp) public pure recursive function simps_dx_sp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=sp) public recursive function simps_x_dp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=dp) public recursive function simps_x_qp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=qp) public recursive function simps_x_sp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=sp)","tags":"","loc":"interface/simps.html"},{"title":"simps_weights – Fortran-lang/stdlib","text":"public interface simps_weights Integrates sampled values using trapezoidal rule weights for given abscissas\n ( Specification ) Contents Functions simps_weights_dp simps_weights_qp simps_weights_sp Functions public pure recursive function simps_weights_dp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=dp),\n  dimension(size(x)) public pure recursive function simps_weights_qp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=qp),\n  dimension(size(x)) public pure recursive function simps_weights_sp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=sp),\n  dimension(size(x))","tags":"","loc":"interface/simps_weights.html"},{"title":"trapz – Fortran-lang/stdlib","text":"public interface trapz Integrates sampled values using trapezoidal rule\n ( Specification ) Contents Functions trapz_dx_dp trapz_dx_qp trapz_dx_sp trapz_x_dp trapz_x_qp trapz_x_sp Functions public pure function trapz_dx_dp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in) :: dx Return Value real(kind=dp) public pure function trapz_dx_qp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in) :: dx Return Value real(kind=qp) public pure function trapz_dx_sp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in) :: dx Return Value real(kind=sp) public function trapz_x_dp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp) public function trapz_x_qp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in), dimension(:) :: x Return Value real(kind=qp) public function trapz_x_sp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in), dimension(:) :: x Return Value real(kind=sp)","tags":"","loc":"interface/trapz.html"},{"title":"trapz_weights – Fortran-lang/stdlib","text":"public interface trapz_weights Integrates sampled values using trapezoidal rule weights for given abscissas\n ( Specification ) Contents Functions trapz_weights_dp trapz_weights_qp trapz_weights_sp Functions public pure function trapz_weights_dp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp),\n  dimension(size(x)) public pure function trapz_weights_qp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x Return Value real(kind=qp),\n  dimension(size(x)) public pure function trapz_weights_sp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x Return Value real(kind=sp),\n  dimension(size(x))","tags":"","loc":"interface/trapz_weights.html"},{"title":"is_alpha – Fortran-lang/stdlib","text":"public pure function is_alpha(c) Checks whether c is an ASCII letter (A .. Z, a .. z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_alpha.html"},{"title":"is_alphanum – Fortran-lang/stdlib","text":"public pure function is_alphanum(c) Checks whether c is a letter or a number (0 .. 9, a .. z, A .. Z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Called by proc~~is_alphanum~~CalledByGraph proc~is_alphanum is_alphanum proc~is_punctuation is_punctuation proc~is_punctuation->proc~is_alphanum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_alphanum.html"},{"title":"is_ascii – Fortran-lang/stdlib","text":"public pure function is_ascii(c) Checks whether or not c is in the ASCII character set - Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents None","tags":"","loc":"proc/is_ascii.html"},{"title":"is_blank – Fortran-lang/stdlib","text":"public pure function is_blank(c) Checks whether or not c is a blank character. That includes the Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_blank.html"},{"title":"is_control – Fortran-lang/stdlib","text":"public pure function is_control(c) Checks whether c is a control character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_control.html"},{"title":"is_digit – Fortran-lang/stdlib","text":"public pure function is_digit(c) Checks whether c is a digit (0 .. 9). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_digit.html"},{"title":"is_graphical – Fortran-lang/stdlib","text":"public pure function is_graphical(c) Checks whether or not c is a printable character other than the Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_graphical.html"},{"title":"is_hex_digit – Fortran-lang/stdlib","text":"public pure function is_hex_digit(c) Checks whether c is a digit in base 16 (0 .. 9, A .. F, a .. f). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_hex_digit.html"},{"title":"is_lower – Fortran-lang/stdlib","text":"public pure function is_lower(c) Checks whether c is a lowercase ASCII letter (a .. z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_lower.html"},{"title":"is_octal_digit – Fortran-lang/stdlib","text":"public pure function is_octal_digit(c) Checks whether c is a digit in base 8 (0 .. 7). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_octal_digit.html"},{"title":"is_printable – Fortran-lang/stdlib","text":"public pure function is_printable(c) Checks whether or not c is a printable character - including the Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_printable.html"},{"title":"is_punctuation – Fortran-lang/stdlib","text":"public pure function is_punctuation(c) Checks whether or not c is a punctuation character. That includes Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Calls proc~~is_punctuation~~CallsGraph proc~is_punctuation is_punctuation proc~is_alphanum is_alphanum proc~is_punctuation->proc~is_alphanum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_punctuation.html"},{"title":"is_upper – Fortran-lang/stdlib","text":"public pure function is_upper(c) Checks whether c is an uppercase ASCII letter (A .. Z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_upper.html"},{"title":"is_white – Fortran-lang/stdlib","text":"public pure function is_white(c) Checks whether or not c is a whitespace character. That includes the Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_white.html"},{"title":"to_lower – Fortran-lang/stdlib","text":"public pure function to_lower(c) result(t) Returns the corresponding lowercase letter, if c is an uppercase Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c A character. Return Value character(len=1) Contents Variables k Variables Type Visibility Attributes Name Initial integer, public :: k","tags":"","loc":"proc/to_lower.html"},{"title":"to_upper – Fortran-lang/stdlib","text":"public pure function to_upper(c) result(t) Returns the corresponding uppercase letter, if c is a lowercase Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c A character. Return Value character(len=1) Contents Variables k Variables Type Visibility Attributes Name Initial integer, public :: k","tags":"","loc":"proc/to_upper.html"},{"title":"stdlib_linalg – Fortran-lang/stdlib","text":"Provides a support for various linear algebra procedures\n ( Specification ) Uses stdlib_kinds module~~stdlib_linalg~~UsesGraph module~stdlib_linalg stdlib_linalg module~stdlib_kinds stdlib_kinds module~stdlib_linalg->module~stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: stdlib_linalg_diag module~~stdlib_linalg~~UsedByGraph module~stdlib_linalg stdlib_linalg module~stdlib_stats_corr stdlib_stats_corr module~stdlib_stats_corr->module~stdlib_linalg module~stdlib_linalg_diag stdlib_linalg_diag module~stdlib_linalg_diag->module~stdlib_linalg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces diag trace Functions eye Interfaces public interface diag Creates a diagonal array or extract the diagonal elements of an array\n ( Specification ) public function diag_cdp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: v (:) Return Value complex(kind=dp)\n  (size(v),size(v)) public function diag_cdp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=dp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_cdp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value complex(kind=dp)\n  (minval(shape(A))) public function diag_cdp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=dp)\n  (minval(shape(A))-abs(k)) public function diag_cqp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: v (:) Return Value complex(kind=qp)\n  (size(v),size(v)) public function diag_cqp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=qp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_cqp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) Return Value complex(kind=qp)\n  (minval(shape(A))) public function diag_cqp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=qp)\n  (minval(shape(A))-abs(k)) public function diag_csp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: v (:) Return Value complex(kind=sp)\n  (size(v),size(v)) public function diag_csp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=sp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_csp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value complex(kind=sp)\n  (minval(shape(A))) public function diag_csp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=sp)\n  (minval(shape(A))-abs(k)) public function diag_iint16(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: v (:) Return Value integer(kind=int16)\n  (size(v),size(v)) public function diag_iint16_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int16)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint16_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) Return Value integer(kind=int16)\n  (minval(shape(A))) public function diag_iint16_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int16)\n  (minval(shape(A))-abs(k)) public function diag_iint32(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: v (:) Return Value integer(kind=int32)\n  (size(v),size(v)) public function diag_iint32_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int32)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint32_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) Return Value integer(kind=int32)\n  (minval(shape(A))) public function diag_iint32_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int32)\n  (minval(shape(A))-abs(k)) public function diag_iint64(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: v (:) Return Value integer(kind=int64)\n  (size(v),size(v)) public function diag_iint64_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int64)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint64_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) Return Value integer(kind=int64)\n  (minval(shape(A))) public function diag_iint64_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int64)\n  (minval(shape(A))-abs(k)) public function diag_iint8(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: v (:) Return Value integer(kind=int8)\n  (size(v),size(v)) public function diag_iint8_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int8)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint8_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) Return Value integer(kind=int8)\n  (minval(shape(A))) public function diag_iint8_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int8)\n  (minval(shape(A))-abs(k)) public function diag_rdp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) Return Value real(kind=dp)\n  (size(v),size(v)) public function diag_rdp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=dp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rdp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp)\n  (minval(shape(A))) public function diag_rdp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=dp)\n  (minval(shape(A))-abs(k)) public function diag_rqp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: v (:) Return Value real(kind=qp)\n  (size(v),size(v)) public function diag_rqp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=qp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rqp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) Return Value real(kind=qp)\n  (minval(shape(A))) public function diag_rqp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=qp)\n  (minval(shape(A))-abs(k)) public function diag_rsp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: v (:) Return Value real(kind=sp)\n  (size(v),size(v)) public function diag_rsp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=sp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rsp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value real(kind=sp)\n  (minval(shape(A))) public function diag_rsp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=sp)\n  (minval(shape(A))-abs(k)) public interface trace Computes the trace of a matrix\n ( Specification ) private function trace_rsp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value real(kind=sp) private function trace_rdp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp) private function trace_rqp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) Return Value real(kind=qp) private function trace_csp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value complex(kind=sp) private function trace_cdp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value complex(kind=dp) private function trace_cqp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) Return Value complex(kind=qp) private function trace_iint8(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) Return Value integer(kind=int8) private function trace_iint16(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) Return Value integer(kind=int16) private function trace_iint32(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) Return Value integer(kind=int32) private function trace_iint64(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) Return Value integer(kind=int64) Functions public function eye (n) result(res) Version experimental Constructs the identity matrix\n ( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer(kind=int8)\n  (n,n)","tags":"","loc":"module/stdlib_linalg.html"},{"title":"stdlib_optval – Fortran-lang/stdlib","text":"Provides a generic function optval , which can be used to\n conveniently implement fallback values for optional arguments\n to subprograms\n ( Specification ) If x is an optional parameter of a\n subprogram, then the expression optval(x, default) inside that\n subprogram evaluates to x if it is present, otherwise default . It is an error to call optval with a single actual argument. Uses stdlib_kinds module~~stdlib_optval~~UsesGraph module~stdlib_optval stdlib_optval module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~stdlib_optval~~UsedByGraph module~stdlib_optval stdlib_optval module~stdlib_stats_corr stdlib_stats_corr module~stdlib_stats_corr->module~stdlib_optval module~stdlib_error stdlib_error module~stdlib_stats_corr->module~stdlib_error module~stdlib_logger stdlib_logger module~stdlib_logger->module~stdlib_optval module~stdlib_stats_mean stdlib_stats_mean module~stdlib_stats_mean->module~stdlib_optval module~stdlib_stats_mean->module~stdlib_error module~stdlib_io stdlib_io module~stdlib_io->module~stdlib_optval module~stdlib_io->module~stdlib_error module~stdlib_stats_var stdlib_stats_var module~stdlib_stats_var->module~stdlib_optval module~stdlib_stats_var->module~stdlib_error module~stdlib_error->module~stdlib_optval module~stdlib_stats_cov stdlib_stats_cov module~stdlib_stats_cov->module~stdlib_optval module~stdlib_stats_cov->module~stdlib_error module~stdlib_stats_moment stdlib_stats_moment module~stdlib_stats_moment->module~stdlib_optval module~stdlib_stats_moment->module~stdlib_error module~stdlib_quadrature_trapz stdlib_quadrature_trapz module~stdlib_quadrature_trapz->module~stdlib_error module~estop estop module~estop->module~stdlib_error module~estop~2 estop module~estop~2->module~stdlib_error module~stdlib_quadrature_simps stdlib_quadrature_simps module~stdlib_quadrature_simps->module~stdlib_error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces optval Interfaces public interface optval Fallback value for optional arguments\n ( Specification ) private pure elemental function optval_rsp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), optional :: x real(kind=sp), intent(in) :: default Return Value real(kind=sp) private pure elemental function optval_rdp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional :: x real(kind=dp), intent(in) :: default Return Value real(kind=dp) private pure elemental function optval_rqp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), optional :: x real(kind=qp), intent(in) :: default Return Value real(kind=qp) private pure elemental function optval_iint8(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), optional :: x integer(kind=int8), intent(in) :: default Return Value integer(kind=int8) private pure elemental function optval_iint16(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), optional :: x integer(kind=int16), intent(in) :: default Return Value integer(kind=int16) private pure elemental function optval_iint32(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), optional :: x integer(kind=int32), intent(in) :: default Return Value integer(kind=int32) private pure elemental function optval_iint64(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), optional :: x integer(kind=int64), intent(in) :: default Return Value integer(kind=int64) private pure elemental function optval_csp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), optional :: x complex(kind=sp), intent(in) :: default Return Value complex(kind=sp) private pure elemental function optval_cdp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), optional :: x complex(kind=dp), intent(in) :: default Return Value complex(kind=dp) private pure elemental function optval_cqp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), optional :: x complex(kind=qp), intent(in) :: default Return Value complex(kind=qp) private pure elemental function optval_ll1(x, default) result(y) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: x logical, intent(in) :: default Return Value logical private pure function optval_character(x, default) result(y) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: x character(len=*), intent(in) :: default Return Value character(len=:),\n  allocatable","tags":"","loc":"module/stdlib_optval.html"},{"title":"stdlib_logger – Fortran-lang/stdlib","text":"Module stdlib_logger This module defines a derived type, procedures, a variable, and\n constants to be used for logging information and reporting errors\n in Fortran applications.\n( Specification ) The derived type, logger_type , is to be used to define variables to\n serve as both local and global loggers. A logger directs its messages\n to selected I/O units so the user has a record (a log) of major events.\n For each entity of logger_type the reports go to a list of I/O units\n represented by the private internal array, log_units . If log_units is\n empty then output by default goes to output_unit . Otherwise reports\n go to output_unit only if it has been explicitly added to log_units .\n Each entity of type logger_type also maintains an internal state\n controlling the formatting of output. The procedures are as follows. The logical function log_units_assigned returns the number of I/O units in log_units . The\n subroutines add_log_file and add_log_unit include the specified file\n in log_units . remove_log_units removes the specified logical unit from\n the log_units array and optionally closes the file. configure configures the details of the logging process. configuration reports the details of that configuration. The subroutines log_error , log_information , log_io_error , log_message , log_text_error , and log_warning send messages to the log units. The variable global_logger of type logger_type can be used\n as a default global logger anywhere in the source code. The constants are used to report errors by some of the subroutines\n in their optional stat arguments. The constants are as follows. success indicates that no error has occurred. close_failure indicates that a close statement for an I/O unit failed. index_invalid_error indicates that column was invalid for\n the given line . open_failure indicates that an open statement\n failed. read_only_error indicates that an output unit did not have a \"write\" or \"readwrite\" action. non_sequential_error indicates\n that the unit did not have sequential access. unformatted_in_error indicates that the unit did not have a form of \"formatted\" . unopened_in_error indicates that the unit was not opened. write_failure indicates that at least one of the writes to log_units failed. public constants used as error flags\n Variable of type logger_type to be used as a global logger Uses iso_fortran_env stdlib_ascii stdlib_optval module~~stdlib_logger~~UsesGraph module~stdlib_logger stdlib_logger module~stdlib_ascii stdlib_ascii module~stdlib_logger->module~stdlib_ascii module~stdlib_optval stdlib_optval module~stdlib_logger->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_logger->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables close_failure global_logger index_invalid_error non_sequential_error open_failure read_only_error success unformatted_in_error unopened_in_error write_failure Derived Types logger_type Variables Type Visibility Attributes Name Initial integer, public, parameter :: close_failure = 1 type( logger_type ), public :: global_logger integer, public, parameter :: index_invalid_error = 2 integer, public, parameter :: non_sequential_error = 3 integer, public, parameter :: open_failure = 4 integer, public, parameter :: read_only_error = 5 integer, public, parameter :: success = 0 integer, public, parameter :: unformatted_in_error = 6 integer, public, parameter :: unopened_in_error = 7 integer, public, parameter :: write_failure = 8 Derived Types type, public :: logger_type Public derived type ( Specification ) Finalizations Procedures final :: final_logger","tags":"","loc":"module/stdlib_logger.html"},{"title":"stdlib_stats – Fortran-lang/stdlib","text":"Provides support for various statistical methods. This includes currently\n descriptive statistics\n ( Specification ) Uses stdlib_kinds module~~stdlib_stats~~UsesGraph module~stdlib_stats stdlib_stats module~stdlib_kinds stdlib_kinds module~stdlib_stats->module~stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: stdlib_stats_corr stdlib_stats_cov stdlib_stats_mean stdlib_stats_moment stdlib_stats_var module~~stdlib_stats~~UsedByGraph module~stdlib_stats stdlib_stats module~stdlib_stats_corr stdlib_stats_corr module~stdlib_stats_corr->module~stdlib_stats module~stdlib_stats_mean stdlib_stats_mean module~stdlib_stats_mean->module~stdlib_stats module~stdlib_stats_var stdlib_stats_var module~stdlib_stats_var->module~stdlib_stats module~stdlib_stats_cov stdlib_stats_cov module~stdlib_stats_cov->module~stdlib_stats module~stdlib_stats_moment stdlib_stats_moment module~stdlib_stats_moment->module~stdlib_stats Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces corr cov mean moment var Interfaces public interface corr Pearson correlation of array elements\n ( Specification ) public function corr_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function corr_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function corr_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function corr_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function corr_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function corr_mask_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function corr_mask_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function corr_mask_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function corr_mask_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public interface cov Covariance of array elements\n ( Specification ) public function cov_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_mask_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_mask_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_mask_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_mask_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public interface mean Mean of array elements\n ( Specification ) public function mean_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_all_1_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_1_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_1_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_1_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_1_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_all_2_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_2_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_2_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_2_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_2_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_all_3_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_3_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_3_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_3_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_3_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_mask_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function mean_mask_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function mean_mask_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function mean_mask_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function mean_mask_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function mean_mask_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_all_1_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function mean_mask_all_1_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function mean_mask_all_1_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function mean_mask_all_1_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=qp) public function mean_mask_all_1_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=sp) public function mean_mask_all_2_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=dp) public function mean_mask_all_2_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=qp) public function mean_mask_all_2_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=sp) public function mean_mask_all_2_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=qp) public function mean_mask_all_2_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=sp) public function mean_mask_all_3_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp) public function mean_mask_all_3_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp) public function mean_mask_all_3_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp) public function mean_mask_all_3_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp) public function mean_mask_all_3_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp) public interface moment Central moment of array elements\n ( Specification ) public function moment_1_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_1_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_1_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_1_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_1_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_all_1_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_1_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_1_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_1_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_1_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_all_2_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_2_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_2_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_2_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_2_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_all_3_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_3_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_3_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_3_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_3_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_mask_1_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function moment_mask_1_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function moment_mask_1_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function moment_mask_1_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=qp) public function moment_mask_1_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=sp) public function moment_mask_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_all_1_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function moment_mask_all_1_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function moment_mask_all_1_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function moment_mask_all_1_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=qp) public function moment_mask_all_1_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=sp) public function moment_mask_all_2_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=dp) public function moment_mask_all_2_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=qp) public function moment_mask_all_2_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=sp) public function moment_mask_all_2_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=qp) public function moment_mask_all_2_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=sp) public function moment_mask_all_3_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp) public function moment_mask_all_3_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp) public function moment_mask_all_3_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp) public function moment_mask_all_3_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp) public function moment_mask_all_3_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp) public function moment_mask_scalar_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public interface var Variance of array elements\n ( Specification ) public function var_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_all_1_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_1_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_1_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_1_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_2_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_2_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_2_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_2_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_3_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_3_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_3_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_3_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_all_1_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_1_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_1_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_1_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_2_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_2_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_2_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_2_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_3_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_3_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_3_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_3_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)","tags":"","loc":"module/stdlib_stats.html"},{"title":"stdlib_io – Fortran-lang/stdlib","text":"Provides a support for file handling\n ( Specification ) Uses stdlib_kinds stdlib_error stdlib_optval stdlib_ascii module~~stdlib_io~~UsesGraph module~stdlib_io stdlib_io module~stdlib_kinds stdlib_kinds module~stdlib_io->module~stdlib_kinds module~stdlib_error stdlib_error module~stdlib_io->module~stdlib_error module~stdlib_ascii stdlib_ascii module~stdlib_io->module~stdlib_ascii module~stdlib_optval stdlib_optval module~stdlib_io->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env module~stdlib_error->module~stdlib_optval module~stdlib_error->iso_fortran_env module~stdlib_optval->module~stdlib_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces loadtxt savetxt Functions open parse_mode Interfaces public interface loadtxt Loads a 2D array from a text file\n ( Specification ) private subroutine loadtxt_rsp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=sp), intent(out), allocatable :: d (:,:) Example real ( sp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_rdp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=dp), intent(out), allocatable :: d (:,:) Example real ( dp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_rqp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=qp), intent(out), allocatable :: d (:,:) Example real ( qp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint8(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int8), intent(out), allocatable :: d (:,:) Example integer ( int8 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint16(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int16), intent(out), allocatable :: d (:,:) Example integer ( int16 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint32(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int32), intent(out), allocatable :: d (:,:) Example integer ( int32 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint64(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int64), intent(out), allocatable :: d (:,:) Example integer ( int64 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_csp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=sp), intent(out), allocatable :: d (:,:) Example complex ( sp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_cdp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=dp), intent(out), allocatable :: d (:,:) Example complex ( dp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_cqp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=qp), intent(out), allocatable :: d (:,:) Example complex ( qp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... public interface savetxt Saves a 2D array into a text file\n ( Specification ) private subroutine savetxt_rsp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(in) :: d (:,:) Example real ( sp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_rdp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in) :: d (:,:) Example real ( dp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_rqp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(in) :: d (:,:) Example real ( qp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint8(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(in) :: d (:,:) Example integer ( int8 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint16(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(in) :: d (:,:) Example integer ( int16 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint32(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(in) :: d (:,:) Example integer ( int32 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint64(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(in) :: d (:,:) Example integer ( int64 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_csp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(in) :: d (:,:) Example complex ( sp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_cdp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(in) :: d (:,:) Example complex ( dp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_cqp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(in) :: d (:,:) Example complex ( qp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) Functions public function open (filename, mode, iostat) result(u) Version experimental Opens a file\n ( Specification ) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: mode integer, intent(out), optional :: iostat Return Value integer public function parse_mode (mode) result(mode_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mode Return Value character(len=3)","tags":"","loc":"module/stdlib_io.html"},{"title":"stdlib_error – Fortran-lang/stdlib","text":"Provides support for catching and handling errors\n ( Specification ) Uses iso_fortran_env stdlib_optval module~~stdlib_error~~UsesGraph module~stdlib_error stdlib_error iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_optval stdlib_optval module~stdlib_error->module~stdlib_optval module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: estop estop module~~stdlib_error~~UsedByGraph module~stdlib_error stdlib_error module~stdlib_stats_corr stdlib_stats_corr module~stdlib_stats_corr->module~stdlib_error module~stdlib_quadrature_simps stdlib_quadrature_simps module~stdlib_quadrature_simps->module~stdlib_error module~estop estop module~estop->module~stdlib_error module~stdlib_stats_mean stdlib_stats_mean module~stdlib_stats_mean->module~stdlib_error module~stdlib_io stdlib_io module~stdlib_io->module~stdlib_error module~stdlib_quadrature_trapz stdlib_quadrature_trapz module~stdlib_quadrature_trapz->module~stdlib_error module~stdlib_stats_var stdlib_stats_var module~stdlib_stats_var->module~stdlib_error module~estop~2 estop module~estop~2->module~stdlib_error module~stdlib_stats_cov stdlib_stats_cov module~stdlib_stats_cov->module~stdlib_error module~stdlib_stats_moment stdlib_stats_moment module~stdlib_stats_moment->module~stdlib_error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces error_stop Subroutines check Interfaces interface public module subroutine error_stop(msg, code) Provides a call to error stop and allows the user to specify a code and message\n ( Specification ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg integer, intent(in), optional :: code Subroutines public subroutine check (condition, msg, code, warn) Version experimental Checks the value of a logical condition\n ( Specification ) Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in), optional :: msg integer, intent(in), optional :: code logical, intent(in), optional :: warn","tags":"","loc":"module/stdlib_error.html"},{"title":"stdlib_quadrature – Fortran-lang/stdlib","text":"( Specification ) Uses stdlib_kinds module~~stdlib_quadrature~~UsesGraph module~stdlib_quadrature stdlib_quadrature module~stdlib_kinds stdlib_kinds module~stdlib_quadrature->module~stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: stdlib_quadrature_simps stdlib_quadrature_trapz module~~stdlib_quadrature~~UsedByGraph module~stdlib_quadrature stdlib_quadrature module~stdlib_quadrature_trapz stdlib_quadrature_trapz module~stdlib_quadrature_trapz->module~stdlib_quadrature module~stdlib_quadrature_simps stdlib_quadrature_simps module~stdlib_quadrature_simps->module~stdlib_quadrature Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces simps simps_weights trapz trapz_weights Interfaces public interface simps Integrates sampled values using Simpson's rule\n ( Specification ) public pure recursive function simps_dx_dp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=dp) public pure recursive function simps_dx_qp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=qp) public pure recursive function simps_dx_sp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=sp) public recursive function simps_x_dp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=dp) public recursive function simps_x_qp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=qp) public recursive function simps_x_sp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=sp) public interface simps_weights Integrates sampled values using trapezoidal rule weights for given abscissas\n ( Specification ) public pure recursive function simps_weights_dp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=dp),\n  dimension(size(x)) public pure recursive function simps_weights_qp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=qp),\n  dimension(size(x)) public pure recursive function simps_weights_sp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=sp),\n  dimension(size(x)) public interface trapz Integrates sampled values using trapezoidal rule\n ( Specification ) public pure function trapz_dx_dp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in) :: dx Return Value real(kind=dp) public pure function trapz_dx_qp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in) :: dx Return Value real(kind=qp) public pure function trapz_dx_sp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in) :: dx Return Value real(kind=sp) public function trapz_x_dp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp) public function trapz_x_qp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in), dimension(:) :: x Return Value real(kind=qp) public function trapz_x_sp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in), dimension(:) :: x Return Value real(kind=sp) public interface trapz_weights Integrates sampled values using trapezoidal rule weights for given abscissas\n ( Specification ) public pure function trapz_weights_dp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp),\n  dimension(size(x)) public pure function trapz_weights_qp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x Return Value real(kind=qp),\n  dimension(size(x)) public pure function trapz_weights_sp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x Return Value real(kind=sp),\n  dimension(size(x))","tags":"","loc":"module/stdlib_quadrature.html"},{"title":"stdlib_kinds – Fortran-lang/stdlib","text":"Uses iso_fortran_env iso_fortran_env module~~stdlib_kinds~~UsesGraph module~stdlib_kinds stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~stdlib_kinds~~UsedByGraph module~stdlib_kinds stdlib_kinds module~stdlib_quadrature stdlib_quadrature module~stdlib_quadrature->module~stdlib_kinds module~stdlib_stats stdlib_stats module~stdlib_stats->module~stdlib_kinds module~stdlib_linalg stdlib_linalg module~stdlib_linalg->module~stdlib_kinds module~stdlib_optval stdlib_optval module~stdlib_optval->module~stdlib_kinds module~stdlib_io stdlib_io module~stdlib_io->module~stdlib_kinds module~stdlib_io->module~stdlib_optval module~stdlib_error stdlib_error module~stdlib_io->module~stdlib_error module~stdlib_stats_corr stdlib_stats_corr module~stdlib_stats_corr->module~stdlib_stats module~stdlib_stats_corr->module~stdlib_linalg module~stdlib_stats_corr->module~stdlib_optval module~stdlib_stats_corr->module~stdlib_error module~stdlib_linalg_diag stdlib_linalg_diag module~stdlib_linalg_diag->module~stdlib_linalg module~stdlib_quadrature_simps stdlib_quadrature_simps module~stdlib_quadrature_simps->module~stdlib_quadrature module~stdlib_quadrature_simps->module~stdlib_error module~stdlib_logger stdlib_logger module~stdlib_logger->module~stdlib_optval module~stdlib_quadrature_trapz stdlib_quadrature_trapz module~stdlib_quadrature_trapz->module~stdlib_quadrature module~stdlib_quadrature_trapz->module~stdlib_error module~stdlib_stats_mean stdlib_stats_mean module~stdlib_stats_mean->module~stdlib_stats module~stdlib_stats_mean->module~stdlib_optval module~stdlib_stats_mean->module~stdlib_error module~stdlib_stats_var stdlib_stats_var module~stdlib_stats_var->module~stdlib_stats module~stdlib_stats_var->module~stdlib_optval module~stdlib_stats_var->module~stdlib_error module~stdlib_error->module~stdlib_optval module~stdlib_stats_cov stdlib_stats_cov module~stdlib_stats_cov->module~stdlib_stats module~stdlib_stats_cov->module~stdlib_optval module~stdlib_stats_cov->module~stdlib_error module~stdlib_stats_moment stdlib_stats_moment module~stdlib_stats_moment->module~stdlib_stats module~stdlib_stats_moment->module~stdlib_optval module~stdlib_stats_moment->module~stdlib_error module~estop~2 estop module~estop~2->module~stdlib_error module~estop estop module~estop->module~stdlib_error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_kinds.html"},{"title":"stdlib_ascii – Fortran-lang/stdlib","text":"Used by module~~stdlib_ascii~~UsedByGraph module~stdlib_ascii stdlib_ascii module~stdlib_io stdlib_io module~stdlib_io->module~stdlib_ascii module~stdlib_logger stdlib_logger module~stdlib_logger->module~stdlib_ascii Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ACK BEL BS CAN CR DC1 DC2 DC3 DC4 DEL DLE EM ENQ EOT ESC ETB ETX FF FS GS LF NAK NUL RS SI SO SOH STX SUB SYN TAB US VT digits fullhex_digits hex_digits letters lowercase lowerhex_digits octal_digits uppercase whitespace Functions is_alpha is_alphanum is_ascii is_blank is_control is_digit is_graphical is_hex_digit is_lower is_octal_digit is_printable is_punctuation is_upper is_white to_lower to_upper Variables Type Visibility Attributes Name Initial character(len=1), public, parameter :: ACK = achar(int(z'06')) Acknowledge character(len=1), public, parameter :: BEL = achar(int(z'07')) Bell character(len=1), public, parameter :: BS = achar(int(z'08')) Backspace character(len=1), public, parameter :: CAN = achar(int(z'18')) Cancel character(len=1), public, parameter :: CR = achar(int(z'0D')) Carriage return character(len=1), public, parameter :: DC1 = achar(int(z'11')) Device control 1 character(len=1), public, parameter :: DC2 = achar(int(z'12')) Device control 2 character(len=1), public, parameter :: DC3 = achar(int(z'13')) Device control 3 character(len=1), public, parameter :: DC4 = achar(int(z'14')) Device control 4 character(len=1), public, parameter :: DEL = achar(int(z'7F')) Delete character(len=1), public, parameter :: DLE = achar(int(z'10')) Data link escape character(len=1), public, parameter :: EM = achar(int(z'19')) End of medium character(len=1), public, parameter :: ENQ = achar(int(z'05')) Enquiry character(len=1), public, parameter :: EOT = achar(int(z'04')) End of transmission character(len=1), public, parameter :: ESC = achar(int(z'1B')) Escape character(len=1), public, parameter :: ETB = achar(int(z'17')) End of transmission block character(len=1), public, parameter :: ETX = achar(int(z'03')) End of text character(len=1), public, parameter :: FF = achar(int(z'0C')) NP form feed, new page character(len=1), public, parameter :: FS = achar(int(z'1C')) File separator character(len=1), public, parameter :: GS = achar(int(z'1D')) Group separator character(len=1), public, parameter :: LF = achar(int(z'0A')) NL line feed, new line character(len=1), public, parameter :: NAK = achar(int(z'15')) Negative acknowledge character(len=1), public, parameter :: NUL = achar(int(z'00')) Null character(len=1), public, parameter :: RS = achar(int(z'1E')) Record separator character(len=1), public, parameter :: SI = achar(int(z'0F')) Shift in character(len=1), public, parameter :: SO = achar(int(z'0E')) Shift out character(len=1), public, parameter :: SOH = achar(int(z'01')) Start of heading character(len=1), public, parameter :: STX = achar(int(z'02')) Start of text character(len=1), public, parameter :: SUB = achar(int(z'1A')) Substitute character(len=1), public, parameter :: SYN = achar(int(z'16')) Synchronous idle character(len=1), public, parameter :: TAB = achar(int(z'09')) Horizontal tab character(len=1), public, parameter :: US = achar(int(z'1F')) Unit separator character(len=1), public, parameter :: VT = achar(int(z'0B')) Vertical tab character(len=*), public, parameter :: digits = hex_digits(1:10) 0 .. 9 character(len=*), public, parameter :: fullhex_digits = \"0123456789ABCDEFabcdef\" 0 .. 9A .. Fa .. f character(len=*), public, parameter :: hex_digits = fullhex_digits(1:16) 0 .. 9A .. F character(len=*), public, parameter :: letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" A .. Za .. z character(len=*), public, parameter :: lowercase = letters(27:) a .. z character(len=*), public, parameter :: lowerhex_digits = \"0123456789abcdef\" 0 .. 9a .. f character(len=*), public, parameter :: octal_digits = digits(1:8) 0 .. 7 character(len=*), public, parameter :: uppercase = letters(1:26) A .. Z character(len=*), public, parameter :: whitespace = \" \"//TAB//VT//CR//LF//FF ASCII _whitespace Functions public pure function is_alpha (c) Checks whether c is an ASCII letter (A .. Z, a .. z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_alphanum (c) Checks whether c is a letter or a number (0 .. 9, a .. z, A .. Z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_ascii (c) Checks whether or not c is in the ASCII character set - Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_blank (c) Checks whether or not c is a blank character. That includes the Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_control (c) Checks whether c is a control character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_digit (c) Checks whether c is a digit (0 .. 9). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_graphical (c) Checks whether or not c is a printable character other than the Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_hex_digit (c) Checks whether c is a digit in base 16 (0 .. 9, A .. F, a .. f). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_lower (c) Checks whether c is a lowercase ASCII letter (a .. z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_octal_digit (c) Checks whether c is a digit in base 8 (0 .. 7). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_printable (c) Checks whether or not c is a printable character - including the Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_punctuation (c) Checks whether or not c is a punctuation character. That includes Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_upper (c) Checks whether c is an uppercase ASCII letter (A .. Z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_white (c) Checks whether or not c is a whitespace character. That includes the Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function to_lower (c) result(t) Returns the corresponding lowercase letter, if c is an uppercase Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c A character. Return Value character(len=1) public pure function to_upper (c) result(t) Returns the corresponding uppercase letter, if c is a lowercase Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c A character. Return Value character(len=1)","tags":"","loc":"module/stdlib_ascii.html"},{"title":"stdlib_stats_corr – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_linalg stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_corr~~UsesGraph module~stdlib_stats_corr stdlib_stats_corr module~stdlib_stats stdlib_stats module~stdlib_stats_corr->module~stdlib_stats module~stdlib_linalg stdlib_linalg module~stdlib_stats_corr->module~stdlib_linalg module~stdlib_optval stdlib_optval module~stdlib_stats_corr->module~stdlib_optval ieee_arithmetic ieee_arithmetic module~stdlib_stats_corr->ieee_arithmetic module~stdlib_error stdlib_error module~stdlib_stats_corr->module~stdlib_error module~stdlib_kinds stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_linalg->module~stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_corr.html"},{"title":"stdlib_stats_cov – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_cov~~UsesGraph module~stdlib_stats_cov stdlib_stats_cov module~stdlib_error stdlib_error module~stdlib_stats_cov->module~stdlib_error module~stdlib_stats stdlib_stats module~stdlib_stats_cov->module~stdlib_stats module~stdlib_optval stdlib_optval module~stdlib_stats_cov->module~stdlib_optval ieee_arithmetic ieee_arithmetic module~stdlib_stats_cov->ieee_arithmetic module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_cov.html"},{"title":"stdlib_stats_moment – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_moment~~UsesGraph module~stdlib_stats_moment stdlib_stats_moment module~stdlib_error stdlib_error module~stdlib_stats_moment->module~stdlib_error module~stdlib_stats stdlib_stats module~stdlib_stats_moment->module~stdlib_stats module~stdlib_optval stdlib_optval module~stdlib_stats_moment->module~stdlib_optval ieee_arithmetic ieee_arithmetic module~stdlib_stats_moment->ieee_arithmetic module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_moment.html"},{"title":"stdlib_quadrature_simps – Fortran-lang/stdlib","text":"Uses stdlib_error Ancestors: stdlib_quadrature module~~stdlib_quadrature_simps~~UsesGraph module~stdlib_quadrature_simps stdlib_quadrature_simps module~stdlib_error stdlib_error module~stdlib_quadrature_simps->module~stdlib_error module~stdlib_quadrature stdlib_quadrature module~stdlib_quadrature_simps->module~stdlib_quadrature iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_optval stdlib_optval module~stdlib_error->module~stdlib_optval module~stdlib_kinds stdlib_kinds module~stdlib_quadrature->module~stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_quadrature_simps.html"},{"title":"stdlib_linalg_diag – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_linalg module~~stdlib_linalg_diag~~UsesGraph module~stdlib_linalg_diag stdlib_linalg_diag module~stdlib_linalg stdlib_linalg module~stdlib_linalg_diag->module~stdlib_linalg module~stdlib_kinds stdlib_kinds module~stdlib_linalg->module~stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_linalg_diag.html"},{"title":"stdlib_stats_mean – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_mean~~UsesGraph module~stdlib_stats_mean stdlib_stats_mean module~stdlib_error stdlib_error module~stdlib_stats_mean->module~stdlib_error module~stdlib_stats stdlib_stats module~stdlib_stats_mean->module~stdlib_stats module~stdlib_optval stdlib_optval module~stdlib_stats_mean->module~stdlib_optval ieee_arithmetic ieee_arithmetic module~stdlib_stats_mean->ieee_arithmetic module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_mean.html"},{"title":"estop – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_error module~~estop~~UsesGraph module~estop estop module~stdlib_error stdlib_error module~estop->module~stdlib_error iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_optval stdlib_optval module~stdlib_error->module~stdlib_optval module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/estop.html"},{"title":"stdlib_quadrature_trapz – Fortran-lang/stdlib","text":"Uses stdlib_error Ancestors: stdlib_quadrature module~~stdlib_quadrature_trapz~~UsesGraph module~stdlib_quadrature_trapz stdlib_quadrature_trapz module~stdlib_error stdlib_error module~stdlib_quadrature_trapz->module~stdlib_error module~stdlib_quadrature stdlib_quadrature module~stdlib_quadrature_trapz->module~stdlib_quadrature iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_optval stdlib_optval module~stdlib_error->module~stdlib_optval module~stdlib_kinds stdlib_kinds module~stdlib_quadrature->module~stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_quadrature_trapz.html"},{"title":"stdlib_stats_var – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_var~~UsesGraph module~stdlib_stats_var stdlib_stats_var module~stdlib_error stdlib_error module~stdlib_stats_var->module~stdlib_error module~stdlib_stats stdlib_stats module~stdlib_stats_var->module~stdlib_stats module~stdlib_optval stdlib_optval module~stdlib_stats_var->module~stdlib_optval ieee_arithmetic ieee_arithmetic module~stdlib_stats_var->ieee_arithmetic module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_var.html"},{"title":"estop – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_error module~~estop~2~~UsesGraph module~estop~2 estop module~stdlib_error stdlib_error module~estop~2->module~stdlib_error iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_optval stdlib_optval module~stdlib_error->module~stdlib_optval module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/estop~2.html"},{"title":"Contributing and specs – Fortran-lang/stdlib","text":"Warning This page is currently under construction! Todo Improve the title of this FORD \"pages\" section, and\nimprove the organization of pages\nto separate end-user, high-level documentation and examples from developer documentation and specs.","tags":"","loc":"page//index.html"},{"title":"Fortran stdlib License (MIT) – Fortran-lang/stdlib","text":"MIT License Copyright (c) 2019 Fortran stdlib developers Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","tags":"","loc":"page/./License.html"},{"title":"Contributing – Fortran-lang/stdlib","text":"This page aims to prodive information that are useful for stdlib contributors.\nIssues can be reported on GitHub .","tags":"","loc":"page/contributing/index.html"},{"title":"Contributor Code of Conduct – Fortran-lang/stdlib","text":"Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to make participation in our project and\nour community a harassment-free experience for everyone, regardless of age,\nbody size, disability, ethnicity, gender identity and expression, level of\nexperience, nationality, personal appearance, race, religion, or sexual\nidentity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment\ninclude: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or\nadvances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic\n  address, without explicit permission Other conduct which could reasonably be considered inappropriate in a\n  professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may\nbe further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing or otherwise unacceptable behavior may be\nreported by contacting one of the project maintainers at caomaco@gmail.com or \nondrej@certik.us. All complaints will be reviewed and investigated and will\nresult in a response that is deemed necessary and appropriate to the\ncircumstances. The project team is obligated to maintain confidentiality with\nregard to the reporter of an incident. Further details of specific enforcement\npolicies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4,\navailable at https://contributor-covenant.org/version/1/4","tags":"","loc":"page/contributing/CodeOfConduct.html"},{"title":"Style Guide – Fortran-lang/stdlib","text":"Note This is a living document.\nYou are welcome to propose changes to this workflow by opening an issue . Fortran stdlib Style Guide Use (modern) standard Fortran File naming conventions Indentation & whitespace Variable and procedure naming Attributes End  block closing statements Document public API code with FORD Fortran stdlib Style Guide Adopting a consistent style can improve code legibility through the choice of good naming conventions.\nIn addition, style checks will be run during CI to flag any severe non-conformance.\nThis allows code review discussions to focus on semantics and substance rather than pedantry.\nConsistent whitespace usage, and not polluting line endings with trailing white space makes git diff s considerably more legible.\nThis style guide is a living document and proposed changes may be adopted after discussing them and coming to a consensus. Use (modern) standard Fortran Do not use obsolescent or deleted language features\n  E.g., common , pause , entry , arithmetic if and computed goto Do not use vendor extensions in the form of non-standard syntax and vendor supplied intrinsic procedures\n  E.g., real*8 or etime() File naming conventions Source files should contain at most one program , module , or submodule The filename should match the program or module name and have the file extension .f90 or .F90 if preprocessing is required If the interface and implementation is split using submodules the implementation submodule file should have the same name as the\n  interface (parent) module but end in _implementation E.g., string_class.f90 and string_class_implementation.f90 Tests should be added in the tests subdirectory and have the same name as the module they are testing with the test_ prefix\n  added\n  E.g., string_class.f90 and tests/test_string_class.f90 Indentation & whitespace By setting and following a convention for indentation and whitespace, code reviews and git-diffs can\nfocus on the semantics of the proposed changes rather than style and formatting. The body of every Fortran construct should be indented by four (4) spaces Line length should be limited to 80 characters and must not exceed 132 Please do not use Tab characters for indentation Please remove trailing white space before committing code Variable and procedure naming Variable and procedure names, as well as Fortran keywords, should be written in lowercase Variable and procedure names should be made up of one or more full words separated by an underscore,\n  for example has_failed is preferred over hasfailed Where conventional and appropriate shortening of a word is used then the underscore may be omitted,\n  for example linspace is preferred over lin_space Attributes Always specify intent for dummy arguments. Don't use dimension attribute to declare arrays because it is less verbose.\n  Use this: real, allocatable :: a(:), b(:,:) instead of: real, dimension(:), allocatable :: a real, dimension(:,:), allocatable :: b When defining many arrays of the same dimension, dimension can be used as an exception if it makes the code less verbose. If the optional attribute is used to declare a dummy argument, it should follow the intent attribute. End block closing statements Fortran allows certain block constructs or scopes to include the name of the program unit in the end statement.\nThe convention adopted herein is to include procedure names, module names and program names in the end statement,\nunless the closing statement can reasonably be expected to be on the same screen or page, within about 25 lines. Document public API code with FORD Documentation strings should be provided for all public and protected entities and their arguments or parameters.\nThis is currently accomplished using the FORD tool .\nFor help writing FORD style documentation please see the FORD wiki .\nThe following two sections are most relevant for contributing new code: Writing Documentation Documentation Meta Data Limitations To write the \"spec\" (specification) for a new proposal, please place it in the FORD \"pages\" directory at doc/specs/ .\nTo get help please see the \"Writing Pages\" and \"Writing Documentation\" pages\non the FORD wiki .","tags":"","loc":"page/contributing/StyleGuide.html"},{"title":"Workflow for Contributors – Fortran-lang/stdlib","text":"Note This is a living document.\nYou are welcome to propose changes to this workflow by opening an issue . Workflow for the Fortran stdlib contributors This document describes our current workflow. We welcome everyone and anyone to participate and propose additions to stdlib.\nIt is okay if you do not have experience for specification or implementation,\nbut have an idea for stdlib. If the idea is popular among the community, more\nexperienced contributors will help it through all 5 steps. Idea : You have an idea or a proposal. Open an issue to discuss it. This\n   is on the level of \"is there interest in having image reader/writer\n   functions in stdlib?\" The goal of this step is to find out if the community\n   is interested in having this functionality as part of stdlib. API : When there seems to be significant interest in the proposal (vast\n   majority of participants think it is a good idea), move on to discuss the\n   specific API. It's OK to propose the API off the bat if you already have an\n   idea for it. This step is exploratory and its goal is to find out what the\n   API should look and feel like. Specification : Discuss the API and iterate. When there is vast majority\n   approval for the API, move on to implement it and submit a PR. Small PRs are\n   always better than large.  It is OK to implement only a few functions of a\n   new module, and continue work on the others in a later PR. All new\n   functionality goes into an \"experimental\" namespace\n   ( version: experimental ). As part of the PR, when submitting a new\n   public facing API, please provide the initial draft of the specification\n   document as well as the initial reference implementation of this\n   specification.  The specification is a document that describes the API and\n   the functionality, so that anyone can use it to create an implementation\n   from scratch without looking at stdlib . The stdlib library then provides\n   the reference implementation. Implementation in experimental: When opening a PR, request reviews from\n   one or more people that are most relevant to it. These are likely to be\n   people involved in prior steps of the workflow. Other contributors (not\n   explicitly invited) are encouraged to provide reviews and suggestions as\n   well. Iterate until all (or most) participants are on the same page.\n   A merge is permitted if there are unit tests for a majority of the possible\n   calling scenarios (with or without optional arguments, with arguments that\n   trigger an error) and if there is vast majority approval of the PR. Release : Moving from experimental to release. The experimental\n   \"namespace\" contains new functionality together with its specification. In\n   order to move from experimental to release, the specification document must\n   be approved by the wide community and the standards committee (informally).\n   If that happens, it has now been blessed for broad use and we can move the\n   code into the main section of stdlib , and the particular specification\n   document becomes part of the Fortran Standard Library. Note: the general term \"vast majority\" above means at least 80%, but ultimately\nit is left to our best judgement to ensure that the community agrees that each\nPR and proposal was approved by \"vast majority\". You are welcome to propose changes to this workflow by opening an issue .","tags":"","loc":"page/contributing/Workflow.html"},{"title":"Specifications (specs) – Fortran-lang/stdlib","text":"Fortran stdlib Specifications (specs) This is and index/directory of the specifications (specs) for each new module/feature as described in the workflow document . Fortran stdlib Specifications (specs) Experimental Features & Modules Missing specs Released/Stable Features & Modules Experimental Features & Modules error - Catching and handling errors IO - Input/output helper & convenience linalg - Linear Algebra optval - Fallback value for optional arguments quadrature - Numerical integration stats - Descriptive Statistics Missing specs ascii kinds Released/Stable Features & Modules (None yet)","tags":"","loc":"page/specs/index.html"},{"title":"error – Fortran-lang/stdlib","text":"Catching and handling errors Catching and handling errors check - Checks the value of a logical condition Status Description Syntax Arguments Return value Examples error_stop - aborts the program Status Description Syntax Arguments Output Examples check - Checks the value of a logical condition Status Experimental Description Checks the value of a logical condition. Syntax call check (condition, msg, code, warn) Arguments condition : Shall be a scalar of type logical . msg (optional): Shall be a character expression containing the message to be printed to stderr . The default msg is 'Check failed.'. code (optional): Shall be a scalar of type integer . The default code is 1 . warn (optional): Shall be a scalar of type logical . The default warn is .true. . Return value If condition is .false ., and: no other arguments are provided, this subroutine stops the program with the default message and exit code 1; msg is provided, this subroutine stops the program and it prints the value of msg ; code is provided, this subroutine stops the program with the given exit code; warn is provided and warn is .true. , this subroutine doesn't stop the program and prints the message. Examples program demo_check1 use stdlib_error , only : check implicit none integer :: a = 1 ! If a /= 5, stops the program with exit code 1 and prints 'Check failed.' call check ( a == 5 ) end program demo_check1 program demo_check2 use stdlib_error , only : check implicit none integer :: a = 1 ! If a /= 5, stops the program with exit code 1 and prints  'a == 5 failed.' call check ( a == 5 , msg = 'a == 5 failed.' ) end program demo_check2 program demo_check3 use stdlib_error , only : check implicit none integer :: a = 1 ! If a /= 5,  prints 'a == 5 failed.', but doesn't stop the program. call check ( a == 5 , msg = 'a == 5 failed.' , warn = . true .) end program demo_check2 program demo_check3 use stdlib_error , only : check implicit none integer :: a = 1 ! If a /= 5, stops the program with exit code 77 and prints 'a == 5 failed.' call check ( a == 5 , msg = 'a == 5 failed.' , code = 77 ) end program demo_check3 error_stop - aborts the program Status Experimental Description Aborts the program with a message and a nonzero exit code. Syntax call error_stop (msg, code) Arguments msg : Shall be a character expression containing the message to be printed to stderr . code (optional): Shall be a scalar of type integer to be returned as exit code. Output Aborts the program with printing the message msg to stderr and a nonzero exit code. The nonzero exit code is equal to code if provided, and 1 otherwise. Examples Without error code: program demo_error_stop1 use stdlib_error , only : error_stop implicit none call error_stop ( \"Invalid argument\" ) end program demo_error_stop1 With error code: program demo_error_stop2 use stdlib_error , only : error_stop implicit none call error_stop ( \"Invalid argument\" , code = 123 ) end program demo_error_stop2","tags":"","loc":"page/specs/stdlib_error.html"},{"title":"IO – Fortran-lang/stdlib","text":"IO IO loadtxt - load a 2D array from a text file Status Description Syntax Arguments Return value Example open - open a file Status Description Syntax Arguments Return value Example savetxt - save a 2D array into a text file Status Description Syntax Arguments Output Example loadtxt - load a 2D array from a text file Status Experimental Description Loads a rank-2 array from a text file. Syntax call loadtxt (filename, array) Arguments filename : Shall be  a character expression containing the file name from which to load the rank-2 array . array : Shall be an allocatable rank-2 array of type real , complex or integer . Return value Returns an allocated rank-2 array with the content of filename . Example program demo_loadtxt use stdlib_io , only : loadtxt implicit none real , allocatable :: x (:,:) call loadtxt ( 'example.dat' , x ) end program demo_loadtxt open - open a file Status Experimental Description Returns the unit number of a file opened to read, to write, or to read and write. The file might be a text file or a binary file. All files are opened using a streamed access. Syntax u = open (filename [, mode] [, iostat]) Arguments filename : Shall be a character expression containing the name of the file to open. mode (optional): Shall be a character expression containing characters describing the way in which the file will be used. The available modes are: Character Meaning 'r' open for reading (default) 'w' open for writing, truncating the file first 'x' open for exclusive creation, failing if the file already exists 'a' open for writing, appending to the end of the file if it exists '+' open for updating (reading and writing) 'b' binary mode 't' text mode (default) The default mode is 'rt' (i.e. open for reading a text file). The mode may include one of the four different methods for opening a file (i.e., 'r' , 'w' , 'x' , and 'a' ). These four methods can be associated with the character '+' to open the file for updating. In addition, it can be specified if the file should be handled as a binary file ( 'b' ) or a text file ( 't' ). iostat (optional): Shall be a scalar of type integer that receives the error status of open , if provided. If no error exists, iostat is zero. u : Shall be a scalar of type integer that specifies the unit number associated with the file filename . Return value The result is a scalar of type integer . Example program demo_open use stdlib_io , only : open implicit none integer :: u u = open ( 'example.dat' , 'wt' ) write ( u , '(a)' ) 'This is an example for open' close ( u ) end program demo_open savetxt - save a 2D array into a text file Status Experimental Description Saves a rank-2 array into a text file. Syntax call savetxt (filename, array) Arguments filename : Shall be  a character expression containing the name of the file that will contain the 2D array . array : Shall be a rank-2 array of type real , complex or integer . Output Provides a text file called filename that contains the rank-2 array . Example program demo_savetxt use stdlib_io , only : savetxt implicit none real :: x ( 3 , 2 ) = 1 call savetxt ( 'example.dat' , x ) end program demo_savetxt","tags":"","loc":"page/specs/stdlib_io.html"},{"title":"linalg – Fortran-lang/stdlib","text":"Linear Algebra Linear Algebra diag - Create a diagonal array or extract the diagonal elements of an array Status Description Syntax Arguments Return value Example eye - Construct the identity matrix Status Description Syntax Arguments Return value Example trace - Trace of a matrix Status Description Syntax Arguments Return value Example diag - Create a diagonal array or extract the diagonal elements of an array Status Experimental Description Create a diagonal array or extract the diagonal elements of an array Syntax d = diag (a [, k]) Arguments a : Shall be a rank-1 or or rank-2 array. If a is a rank-1 array (i.e. a vector) then diag returns a rank-2 array with the elements of a on the diagonal. If a is a rank-2 array (i.e. a matrix) then diag returns a rank-1 array of the diagonal elements. k (optional): Shall be a scalar of type integer and specifies the diagonal. The default k = 0 represents the main diagonal, k > 0 are diagonals above the main diagonal, k < 0 are diagonals below the main diagonal. Return value Returns a diagonal array or a vector with the extracted diagonal elements. Example program demo_diag1 use stdlib_linalg , only : diag implicit none real , allocatable :: A (:,:) integer :: i A = diag ([( 1 , i = 1 , 10 )]) ! creates a 10 by 10 identity matrix end program demo_diag1 program demo_diag2 use stdlib_linalg , only : diag implicit none real :: v (:) real , allocatable :: A (:,:) integer :: i v = [ 1 , 2 , 3 , 4 , 5 ] A = diag ( v ) ! creates a 5 by 5 matrix with elements of v on the diagonal end program demo_diag2 program demo_diag3 use stdlib_linalg , only : diag implicit none integer , parameter :: n = 10 real :: c ( n ), ul ( n - 1 ) real :: A ( n , n ) integer :: i c = 2 ul = - 1 A = diag ( ul , - 1 ) + diag ( c ) + diag ( ul , 1 ) ! Gil Strang's favorite matrix end program demo_diag3 program demo_diag4 use stdlib_linalg , only : diag implicit none integer , parameter :: n = 12 real :: A ( n , n ) real :: v ( n ) integer :: i call random_number ( A ) v = diag ( A ) ! v contains diagonal elements of A end program demo_diag4 program demo_diag5 use stdlib_linalg , only : diag implicit none integer , parameter :: n = 3 real :: A ( n , n ) real , allocatable :: v (:) integer :: i A = reshape ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ],[ n , n ]) v = diag ( A , - 1 ) ! v is [2,6] v = diag ( A , 1 ) ! v is [4,8] end program demo_diag5 eye - Construct the identity matrix Status Experimental Description Construct the identity matrix Syntax I = eye (n) Arguments n : Shall be a scalar of default type integer . Return value Returns the identity matrix, i.e. a square matrix with ones on the main diagonal and zeros elsewhere. The return value is of type integer(int8) . Example program demo_eye1 use stdlib_linalg , only : eye implicit none real :: a ( 3 , 3 ) A = eye ( 3 ) end program demo_eye1 program demo_eye2 use stdlib_linalg , only : eye , diag implicit none print * , all ( eye ( 4 ) == diag ([ 1 , 1 , 1 , 1 ])) ! prints .true. end program demo_eye2 trace - Trace of a matrix Status Experimental Description Trace of a matrix (rank-2 array) Syntax result = [stdlib_linalg(module):trace(interface)](A) Arguments A : Shall be a rank-2 array. If A is not square, then trace(A) will return the sum of diagonal values from the square sub-section of A . Return value Returns the trace of the matrix, i.e. the sum of diagonal elements. Example program demo_trace use stdlib_linalg , only : trace implicit none real :: A ( 3 , 3 ) A = reshape ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ],[ 3 , 3 ]) print * , trace ( A ) ! 1 + 5 + 9 end program demo_trace","tags":"","loc":"page/specs/stdlib_linalg.html"},{"title":"logger – Fortran-lang/stdlib","text":"Loggers Loggers Introduction The stdlib_logger constants The derived type: logger_type Status Description Syntax Private attributes The stdlib_logger variable Public logger_type methods Specification of the logger_type methods add_log_file - open a file and add its unit to self % log_units Status Description Syntax Class Arguments Example add_log_unit - add a unit to the array self % log_units Status Description Syntax Class. Arguments Example configuration - report a logger's configuration Status Description Syntax Class Arguments Example configure - configure the logging process Status Description Syntax Class Arguments Example log_error - Writes the string message to self % log_units Status Description Syntax Behavior Class Arguments Example log_information - Writes the string message to self % log_units Status Description Syntax Behavior Class Arguments Example log_io_error - Write the string message to self % log_units Status Description Behavior Syntax Class Arguments Example log_message - write the string message to self % log_units Status Description Behavior Syntax Class Arguments Example log_text_error - send a message to self % log_units describing an error Status Description Behavior Syntax Class Arguments Example log_units_assigned - returns the number of active I/O units Status Description Syntax Class Argument Result character Result value Example log_warning - write the string message to log_units Status Description Behavior Syntax Class Arguments Example remove_log_unit - remove unit from self % log_units Status Description Syntax Class Arguments Example Introduction This module defines a derived type, its methods, a variable, and\nconstants to be used for the reporting of errors and other\ninformation. The derived type, logger_type , is to be used to define\nboth global and local logger variables. The logger_type methods serve\nto configure the loggers and use the logger variables to report\nmessages to a variable specific list of I/O units termed log_units . The variable, global_logger , of type logger_type , is\nintended to serve as the default global logger. The constants serve as\nerror flags returned by the optional integer stat argument. The logger variables have the option to: change which units receive the log messages; report which units receive the log messages; precede messages by a blank line; precede messages by a time stamp of the form yyyy-mm-dd hh:mm:ss.sss ; precede messages with the names of a module and procedure; follow a message with the stat and errmsg of the error report\n  that prompted the log message; follow a message with the iostat and iomsg of the I/O error\n  report that prompted the log message; label a message with one of 'INFO: ' , 'WARN: ' , 'ERROR: ' , or 'I/O ERROR: ' ; indent subsequent lines of the messages; and format the text to fit within a maximum column width. Note: Loggers of type logger_type normally report their messages to I/O\nunits in the internal list termed log_units . However if log_units is empty then the messages go to the output_unit of the intrinsic\nmodule iso_fortran_env . The stdlib_logger constants The module defines nine distinct public integer constants for\nreporting errors in the stat arguments of some of the module's\nprocedures. The constants, termed error codes, are as follows: Error Code Description success no error was detected close_failure a close statement for an I/O unit failed index_invalid_error the column was invalid for the given line non_sequential_error the I/O unit did not have SEQUENTIAL access open_failure an open statement failed read_only_error an output unit did not have an access specifier of 'WRITE' or 'READWRITE' unformatted_in_error the unit did not have a form of 'FORMATTED' unopened_in_error the unit was not opened write_fault one of the writes to log_units failed The derived type: logger_type Status Experimental Description Serves to define 'logger' variables to be used in reporting\nsignificant events encountered during the execution of a program. Syntax type( logger_type ) :: variable Private attributes Attribute Type Description Initial value add_blank_line Logical Flag to precede output with a blank line .false. indent_lines Logical Flag to indent subsequent lines by four columns .true. log_units Integer array List of I/O units used for output empty max_width Integer Maximum column width of output 0 time_stamp Logical Flag to precede output by a time stamp .true. units Integer Count of the number of active output units 0 The stdlib_logger variable The module defines one public variable, global_logger , of type logger_type . As might be guessed from its name, global_logger is\nintended to serve as the default logger for use throughout an\napplication. Public logger_type methods The module defines twelve public procedures: one function and eleven\nsubroutines.  The\nmethods are: Method Class Description add_log_file Subroutine Opens a file using newunit , and adds the resulting unit to the log_units list add_log_unit Subroutine Adds an existing unit to the log_units list configuration Subroutine Reports the details of the logging configuration configure Subroutine Configures the details of the logging process log_error Subroutine Sends a message prepended by 'ERROR: ' optionally followed by a stat or errmsg log_information Subroutine Sends a message prepended by 'INFO: ' log_io_error Subroutine Sends a message prepended by 'I/O ERROR: ' optionally followed by an iostat or iomsg log_message Subroutine Sends a message log_text_error Subroutine Sends a message describing an error found in a line of text log_units_assigned Function Returns the number of active I/O units in log_units log_warning Subroutine Sends a message prepended by 'WARN: ' remove_log_unit Subroutine Removes the unit number from the log_units array Specification of the logger_type methods add_log_file - open a file and add its unit to self % log_units Status Experimental Description Opens a formatted, sequential access, output file, filename using newunit and adds the resulting unit number to the logger's log_units array. Syntax call self % add_log_file ( filename [, unit, action, position, status, stat ] ) Class Subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(inout) argument. It shall be the logger to add the file to its log_units . filename : shall be a scalar default character expression. It is\nan intent(in) argument. It shall be the name of the file to be opened. unit (optional): shall be a scalar default integer variable. It is an intent(out) argument. It will be the unit number returned by the newunit specifier of the open statement for filename . action (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It shall be the action specifier of the open statement and must have one of the values 'WRITE' or 'READWRITE' . It has the default value of 'WRITE' . position (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It shall be the position specifier of the open statement and must have one of\n  the values 'ASIS' , 'REWIND' , or 'APPEND' . It has the default\n  value of 'REWIND' . status (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It shall be the status specifier of the open statement and must have one of\n  the values 'OLD' , 'NEW' , 'REPLACE' , or 'UNKNOWN' . It has the\n  default value of 'REPLACE' . stat (optional): shall be a scalar default integer variable. It\n  is an intent(out) argument. If present, on return it will have the\n  value success if filename could be opened, the value read_only_error if the action specifier is \"READ\" , or the value open_failure if filename could not be opened. If absent and filename could not be opened then processing will stop with an informative message as the stop code. Example program demo_global_logger use stdlib_logger , global => global_logger integer :: unit , stat call global % add_log_file ( 'error_log.txt' , unit , & position = 'asis' , stat = stat ) if ( stat /= success ) then error stop 'Unable to open \"error_log.txt\".' end if end program demo_global_logger add_log_unit - add a unit to the array self % log_units Status Experimental Description Adds unit to the array of self % log_units . The unit shall\nbe the unit number for an opened, sequential, formatted file with an action specifier of 'WRITE' or 'READWRITE' . Failure of unit to meet\nthose requirements will cause stat , if present, to not be success and unit will not be added to log_units . In this case, if stat is\nnot present, cause processing to stop with an informative string as\nthe stop code. Syntax call self % add_log_unit ( unit [, stat ] ) Class. Subroutine. Arguments self : shall be a scalar variable of type logger_type . It is an intent(inout) argument. It shall be the logger to direct its output\nto unit . unit : shall be a scalar default integer expression. It is an intent(in) argument. It shall be the unit number for an opened,\n  sequential, formatted file with an action specifier of 'WRITE' or 'READWRITE' . stat (optional): shall be a scalar default integer variable. It is\n  an intent(out) argument. If absent  and unit could not be added\n  to self's log_units processing will stop with an informative\n  message as the stop code. If present it shall have the value of one\n  of the module's error codes indicating any errors found with unit . The codes are\n  * success - no problem found\n  * non_sequential_error - unit did not have an access specifier of 'SEQUENTIAL' * read_only_error - unit had an action specifier of 'READ' when it needs a specifier of 'WRITE' or 'READWRITE' * unformatted_in_error - unit did not have a form specifier of 'FORMATTED' * unopened_in_error - unit was not opened Example program demo_add_log_unit use stdlib_logger , only : global_logger , read_only_error character ( 256 ) :: iomsg integer :: iostat , unit , stat open ( newunit = unit , 'error_log.txt' , & form = 'formatted' , status = 'replace' , & position = 'rewind' , err = 999 , & action = 'read' , iostat = iostat , iomsg = iomsg ) call global_logger % add_log_unit ( unit , stat ) select case ( stat ) case ( read_only_error ) error stop 'Unable to write to \"error_log.txt\".' end select 999 error stop ' Unable to open \"error_log.txt\" . end program demo_add_log_unit configuration - report a logger's configuration Status Experimental Description Reports the configuration of a logger. Syntax call self % configuration ( [ add_blankline, indent, max_width, time_stamp, log_units ] ) Class Pure subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(in) argument. It shall be the logger whose configuration is reported. add_blank_line (optional): shall be a scalar default logical\n  variable. It is an intent(out) argument. A value of .true. starts output with a blank line, and .false. otherwise. indent (optional): shall be a scalar default logical variable. It\n  is an intent(out) argument. A value of .true. indents subsequent\n  lines by four spaces, and .false. otherwise. max_width (optional): shall be a scalar default integer\n  variable. It is an intent(out) argument. A positive value bigger\n  than four defines the maximum width of the output, otherwise there\n  is no maximum width. time_stamp (optional): shall be a scalar default logical\n  variable. It is an intent(out) argument. A value of .true. precedes output with a time stamp of the form 'yyyy-mm-dd\n  hh:mm:ss.sss', and .false. otherwise. log_units (optional): shall be a rank one allocatable array\n  variable of type default integer. It is an intent(out) argument. On return it shall be the elements of the self 's log_units array. Example module example_mod use stdlib_logger type ( logger_type ) :: logger contains subroutine example_sub ( unit , ...) integer , intent ( in ) :: unit integer , allocatable :: log_units (:) call logger % configuration ( log_units = log_units ) if ( size ( log_units ) == 0 ) then call add_logger_unit ( unit ) end if end subroutine example_sub end module example_mod configure - configure the logging process Status Experimental Description Configures the logging process for self. Syntax call self % configure ( [ add_blank_line, indent, max_width, time_stamp ] ) Class Pure subroutine Arguments self : shall be a scalar variable of type logger_type . It is an intent(inout) argument. It shall be the logger to be configured. add_blank_line (optional): shall be a scalar default logical\n  expression. It is an intent(in) argument. Set to .true. to start\n  output with a blank line, and to .false. otherwise. indent (optional): shall be a scalar default logical\n  expression. It is an intent(in) argument. Set to .true. to\n  indent subsequent lines by four spaces, and to .false. to\n  not indent. max_width (optional): shall be a scalar default integer\n  expression. It is an intent(in) argument. Set to a positive value\n  bigger than four to define the maximum width of the output,\n  otherwise there is no maximum width. time_stamp (optional): shall be a scalar default logical\n  expression. It is an intent(in) argument. Set to .true. to\n  precede output with a time stamp of the form 'yyyy-mm-dd\n  hh:mm:ss.sss', and to .false. otherwise. Example program demo_configure use stdlib_logger , only : global => global_logger call global % configure ( indent = . false ., max_width = 72 ) end program demo_configure log_error - Writes the string message to self % log_units Status Experimental Description Writes the string message to self % log_units with optional additional text. Syntax call self % log_error ( message [, module, procedure, stat, errmsg ] ) Behavior If time stamps are active for self , a time stamp is written,\nfollowed by module and procedure if present, then message is written with the prefix 'ERROR: ' , and then\nif stat or errmsg are present they are written. Class Subroutine Arguments self : shall be a scalar expression of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. module (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_error call. procedure (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_error call. stat (optional): shall be a scalar default integer expression. It\n  is an intent(in) argument. It should be the stat specifier of\n  the subroutine call or intrinsic statement that prompted the log_error call. errmsg (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the errmsg specifier of the subroutine call or intrinsic statement\n  that prompted the log_error call. Example module example_mod use stdlib_logger real , allocatable :: a (:) type ( logger_type ) :: logger contains subroutine example_sub ( size ) integer , intent ( in ) :: size character ( 128 ) :: errmsg , message integer :: stat allocate ( a ( size ), stat = stat , errmsg = errmsg ) if ( stat /= 0 ) then write ( message , '(a, i0)' ) & \"Allocation of A failed with SIZE = \" , size call logger % log_error ( message , & module = 'EXAMPLE_MOD' , & procedure = 'EXAMPLE_SUB' , & stat = stat , & errmsg = errmsg ) end if end subroutine example_sub end module example_mod log_information - Writes the string message to self % log_units Status Experimental Description Writes the string message to self % log_units with optional additional text. Syntax call self % log_information ( message [, module, procedure ] ) Behavior If time stamps are active, a time stamp is written, followed\nby module and procedure if present, and then message is written with the prefix 'INFO: ' . Class Subroutine Arguments self : shall be a scalar expression of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. module (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_information call. procedure (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_information call. Example module example_mod use stdlib_logger real , allocatable :: a (:) type ( logger_type ) :: logger contains subroutine example_sub ( selection ) integer , intent ( out ) :: selection character ( 128 ) :: errmsg , message integer :: stat write ( * , '(a)' ) \"Enter an integer to select a widget\" read ( * , '(i0)' ) selection write ( message , '(a, i0)' ) & \"The user selected \" , selection call logger % log_information ( message , & module = 'EXAMPLE_MOD' , procedure = 'EXAMPLE_SUB' ) end subroutine example_sub end module example_mod log_io_error - Write the string message to self % log_units Status Experimental Description Writes the string message to self % log_units with\noptional additional text. Behavior If time stamps are active, a time stamp is written\nfirst. Then if module or procedure are present, they are\nwritten. Then message is written with the prefix 'I/O ERROR: ' . Then if iostat or iomsg are present they are\nwritten. Syntax call self % log_io_error ( message [, module, procedure, iostat, iomsg ] ) Class Subroutine Arguments self : shall be a scalar expression of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. module (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_io_error call. procedure (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_io_error call. iostat (optional): shall be a scalar default integer\n  expression. It is an intent(in) argument. It should be the iostat specifier of the subroutine call or intrinsic statement\n  that prompted the log_io_error call. iomsg (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the iomsg specifier of the subroutine call or intrinsic statement\n  that prompted the log_io_error call. Example program demo_log_io_error use stdlib_logger , global => global_logger character ( * ), parameter :: filename = 'dummy.txt' integer :: iostat , lun character ( 128 ) :: iomsg character ( * ), parameter :: message = & 'Failure in opening \"dummy.txt\".' open ( newunit = lun , file = filename , form = 'formatted' , & status = 'old' , iostat = iostat , iomsg = iomsg ) if ( iostat /= 0 ) then call global % log_io_error ( message , & procedure = 'EXAMPLE' , & iostat = iostat , & iomsg = iomsg ) error stop 'Error on opening a file' end if end program demo_log_io_error log_message - write the string message to self % log_units Status Experimental Description Writes the string message to self % log_units with\n  optional additional text. Behavior If time stamps are active, a time stamp is written,\nthen module and procedure are written if present,\nfollowed by prefix \\\\ ': ' , if present, and finally message . Syntax call self % log_message ( message [, module, procedure, prefix ] ) Class Subroutine Arguments self : shall be a scalar expression of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. module (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_message call. procedure (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_message call. prefix (optional): shall be a scalar default character expression.\nIt is an intent(in) argument. It will precede message with an ': ' appended. Example module example_mod use stdlib_logger real , allocatable :: a (:) type ( logger_type ) :: logger contains subroutine example_sub ( selection ) integer , intent ( out ) :: selection integer :: stat write ( * , '(a)' ) \"Enter an integer to select a widget\" read ( * , '(i0)' ) selection write ( message , '(a, i0)' ) & \"The user selected \" , selection call logger % log_message ( message , & module = 'EXAMPLE_MOD' , & procedure = 'EXAMPLE_SUB' , & prefix = ` INFO ' ) end subroutine example_sub end module example_mod log_text_error - send a message to self % log_units describing an error Status Experimental Description log_text_error sends a message to self % log_units describing an error found in a line of text. Behavior If time stamps are active first a time stamp is\nwritten. Then if filename or line_number are present they are\nwritten with column . Then line is written. Then a caret, '&#94;', is\nwritten below line at the column indicated by column . Then summary is written below the caret. Syntax call self % log_text_error ( line, column, summary [, filename, line_number, caret, stat ] ) Class Subroutine Arguments self : shall be a scalar expression of type logger_type . It is an intent(in) argument. It is the logger used to send the message. line : shall be a scalar default character expression. It is an intent(in) argument. It should be the line of text in which the\n  error was found. column : shall be a scalar default integer expression. It is an intent(in) argument. It should be the one's based column at which\n  the error begins. summary : shall be a scalar default character expression. It is an intent(in) argument. It should be a description of the error in line . filename (optional): shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the file, if any, in which line was found. line_number (optional): shall be a scalar default integer\n  expression. It is an intent(in) argument. It should be the line\n  number in filename associated with line . caret (optional): shall be a scalar default single character\n  expression. It is an intent(in) argument. If present it will be\n  placed below line on output to indicate the starting location of\n  the error. It has a default value of '&#94;'. stat (optional): shall be a scalar default integer variable. It\n  is an intent(out) argument. If present it will have the value of success if no errors were encountered, the value index_invalid_error if column is less than one or greater than len(line)+1 , or the value write_fault if the writes to any of log_units failed. If stat is absent and would not have the value success then processing will stop with an informative stop code. Example program demo_log_text_error use stdlib_logger character ( * ), parameter :: filename = 'dummy.txt' integer :: col_no , line_no , lun character ( 128 ) :: line character ( * ), parameter :: message = 'Bad text found.' open ( newunit = lun , file = filename , statu = 'old' , & form = 'formatted' ) line_no = 0 do read ( lun , fmt = '(a)' , end = 900 ) line line_no = line_no + 1 call check_line ( line , status , col_no ) if ( status /= 0 ) call global_logger % log_text_error ( line , & col_no , message , filename , line_no ) error stop 'Error in reading ' // filename end if end do 900 continue end program demo_log_text_error log_units_assigned - returns the number of active I/O units Status Experimental Description Returns the number of active I/O units in self % log_units Syntax result = self % log_units_assigned () Class Elemental function Argument self : shall be a scalar expression of type logger_type . It is an intent(in) argument. It is the logger whose state is queried. Result character The result shall be a scalar of type default integer. Result value The result is the number of I/O units in self % log_units . Example module example_mod use stdlib_logger type ( logger_type ) :: logger contains subroutine example_sub ( unit , ...) integer , intent ( in ) :: unit integer , allocatable :: log_units (:) if ( logger % log_units_assigned () == 0 ) then call logger % add_log_unit ( unit ) end if end subroutine example_sub end module example_mod log_warning - write the string message to log_units Status Experimental Description Writes the string message to log_units with\n  optional additional text. Behavior If time stamps are active, a time stamp is written,\nthen module and procedure if present, then message is written with the prefix WARN: ' . Syntax call self % log_warning ( message [, module, procedure ] ) Class Subroutine Arguments self : shall be a scalar expression of type logger_type . It is an intent(in) argument. It is the logger used to send the message. message : shall be a scalar default character expression. It is an intent(in) argument. module : (optional) shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the module containing the log_warning call. procedure : (optional) shall be a scalar default character\n  expression. It is an intent(in) argument. It should be the name of\n  the procedure containing the log_warning call. Example module example_mod use stdlib_logger real , allocatable :: a (:) type ( logger_type ) :: logger contains subroutine example_sub ( size , stat ) integer , intent ( in ) :: size integer , intent ( out ) :: stat allocate ( a ( size ) ) if ( stat /= 0 ) then write ( message , '(a, i0)' ) & \"Allocation of A failed with SIZE = \" , size call logger % log_warning ( message , & module = 'EXAMPLE_MOD' , & procedure = 'EXAMPLE_SUB' ) end if end subroutine example_sub end module example_mod remove_log_unit - remove unit from self % log_units Status Experimental Description Remove unit from the self % log_units list. If close_unit is present and .true. then the corresponding file is\nclosed. If unit is not in self % log_units then nothing is done. Syntax call self % remove_log_unit ( unit [, close_unit, stat ] ) Class Subroutine Arguments self : shall be a scalar expression of type logger_type . It is an intent(inout) argument. It is the logger whose log_units is to be\nmodified. unit : shall be a scalar default integer expression. It is an intent(in) argument. It should be one of the I/O unit numbers\n  in self % log_units . If it is not, then nothing is done. close_unit (optional): shall be a scalar default logical\n  expression. It is an intent(in) argument. If .true and unit is\n  in self % log_units then unit will be closed, otherwise the I/O unit\n  will be unaffected. stat (optional): shall be a scalar default integer variable. It is\n  an intent(out) argument. If present it has the default value of success , but has the value close_failure if close_unit is\n  present with the value .true. , and unit is initially in log_units , and closing unit fails. If stat is absent and\n  closing the unit fails then processing stops with an informative\n  stop code. Example module example_mod use stdlib_logger , global => global_logger contains subroutine example_sub ( unit , ...) integer , intent ( in ) :: unit call global % remove_log_unit ( unit ) end subroutine example_sub end module example_mod","tags":"","loc":"page/specs/stdlib_logger.html"},{"title":"optval – Fortran-lang/stdlib","text":"Default values for optional arguments Default values for optional arguments optval - fallback value for optional arguments Status Description Syntax Arguments Return value Example optval - fallback value for optional arguments Status Experimental Description Returns x if it is present, otherwise default . This function is intended to be called in a procedure with one or more optional arguments, in order to conveniently fall back to a default value if an optional argument is not present. Syntax result = optval (x, default) Arguments x : Shall be of type integer , real , complex , or logical , or a scalar of type character . default : Shall have the same type, kind, and rank as x . Return value If x is present, the result is x , otherwise the result is default . Example program demo_optval use stdlib_optval , only : optval implicit none print * , root ( 6 4.0 ) ! 8.0 print * , root ( 6 4.0 , 3 ) ! 4.0 contains real function root ( x , n ) real , intent ( in ) :: x integer , intent ( in ), optional :: n root = x ** ( 1.0 / optval ( n , 2 )) end function root end program demo_optval","tags":"","loc":"page/specs/stdlib_optval.html"},{"title":"quadrature – Fortran-lang/stdlib","text":"Numerical integration Numerical integration trapz - integrate sampled values using trapezoidal rule Status Description Syntax Arguments Return value Example trapz_weights - trapezoidal rule weights for given abscissas Status Description Syntax Arguments Return value Example simps - integrate sampled values using Simpson's rule Status Description Syntax Arguments Return value Example simps_weights - Simpson's rule weights for given abscissas Status Description Syntax Arguments Return value Example trapz - integrate sampled values using trapezoidal rule Status Experimental Description Returns the trapezoidal rule integral of an array y representing discrete samples of a function. The integral is computed assuming either equidistant abscissas with spacing dx or arbitary abscissas x . Syntax result = trapz (y, x) result = trapz (y, dx) Arguments y : Shall be a rank-one array of type real . x : Shall be a rank-one array of type real having the same kind and size as y . dx : Shall be a scalar of type real having the same kind as y . Return value The result is a scalar of type real having the same kind as y . If the size of y is zero or one, the result is zero. Example program demo_trapz use stdlib_quadrature , only : trapz implicit none real :: x ( 5 ) = [ 0. , 1. , 2. , 3. , 4. ] real :: y ( 5 ) = x ** 2 print * , trapz ( y , x ) ! 22.0 print * , trapz ( y , 0.5 ) ! 11.0 end program demo_trapz trapz_weights - trapezoidal rule weights for given abscissas Status Experimental Description Given an array of abscissas x , computes the array of weights w such that if y represented function values tabulated at x , then sum(w*y) produces a trapezoidal rule approximation to the integral. Syntax result = trapz_weights (x) Arguments x : Shall be a rank-one array of type real . Return value The result is a real array with the same size and kind as x . If the size of x is one, then the sole element of the result is zero. Example program demo_trapz_weights use stdlib_quadrature , only : trapz_weights implicit none real :: x ( 5 ) = [ 0. , 1. , 2. , 3. , 4. ] real :: y ( 5 ) = x ** 2 real :: w ( 5 ) w = trapz_weights ( x ) print * , sum ( w * y ) ! 22.0 end program demo_trapz_weights simps - integrate sampled values using Simpson's rule Status Experimental Description Returns the Simpson's rule integral of an array y representing discrete samples of a function. The integral is computed assuming either equidistant abscissas with spacing dx or arbitary abscissas x . Simpson's ordinary (\"1/3\") rule is used for odd-length arrays. For even-length arrays, Simpson's 3/8 rule is also utilized in a way that depends on the value of even . If even is negative (positive), the 3/8 rule is used at the beginning (end) of the array. If even is zero or not present, the result is as if the 3/8 rule were first used at the beginning of the array, then at the end of the array, and these two results were averaged. Syntax result = simps (y, x [, even]) result = simps (y, dx [, even]) Arguments y : Shall be a rank-one array of type real . x : Shall be a rank-one array of type real having the same kind and size as y . dx : Shall be a scalar of type real having the same kind as y . even : (Optional) Shall be a default-kind integer . Return value The result is a scalar of type real having the same kind as y . If the size of y is zero or one, the result is zero. If the size of y is two, the result is the same as if trapz had been called instead. Example program demo_simps use stdlib_quadrature , only : simps implicit none real :: x ( 5 ) = [ 0. , 1. , 2. , 3. , 4. ] real :: y ( 5 ) = 3. * x ** 2 print * , simps ( y , x ) ! 64.0 print * , simps ( y , 0.5 ) ! 32.0 end program demo_simps simps_weights - Simpson's rule weights for given abscissas Status Experimental Description Given an array of abscissas x , computes the array of weights w such that if y represented function values tabulated at x , then sum(w*y) produces a Simpson's rule approximation to the integral. Simpson's ordinary (\"1/3\") rule is used for odd-length arrays. For even-length arrays, Simpson's 3/8 rule is also utilized in a way that depends on the value of even . If even is negative (positive), the 3/8 rule is used at the beginning (end) of the array and the 1/3 rule used elsewhere. If even is zero or not present, the result is as if the 3/8 rule were first used at the beginning of the array, then at the end of the array, and then these two results were averaged. Syntax result = simps_weights (x [, even]) Arguments x : Shall be a rank-one array of type real . even : (Optional) Shall be a default-kind integer . Return value The result is a real array with the same size and kind as x . If the size of x is one, then the sole element of the result is zero. If the size of x is two, then the result is the same as if trapz_weights had been called instead. Example program demo_simps_weights use stdlib_quadrature , only : simps_weights implicit none real :: x ( 5 ) = [ 0. , 1. , 2. , 3. , 4. ] real :: y ( 5 ) = 3. * x ** 2 real :: w ( 5 ) w = simps_weights ( x ) print * , sum ( w * y ) ! 64.0 end program demo_simps_weights","tags":"","loc":"page/specs/stdlib_quadrature.html"},{"title":"stats – Fortran-lang/stdlib","text":"Descriptive statistics Descriptive statistics corr - Pearson correlation of array elements Status Description Syntax Arguments Return value Example cov - covariance of array elements Status Description Syntax Arguments Return value Example mean - mean of array elements Status Description Syntax Arguments Return value Example moment - central moments of array elements Status Description Syntax Arguments Return value Example var - variance of array elements Status Description Syntax Arguments Return value Example corr - Pearson correlation of array elements Status Experimental Description Returns the Pearson correlation of the elements of array along dimension dim if the corresponding element in mask is true . The Pearson correlation between two rows (or columns), say x and y , of array is defined as: corr(x, y) = cov(x, y) / sqrt( var(x) * var(y)) Syntax result = corr (array, dim [, mask]) Arguments array : Shall be a rank-1 or a rank-2 array of type integer , real , or complex . dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . Return value If array is of rank 1 and of type real or complex , the result is of type real and has the same kind as array .\nIf array is of rank 2 and of type real or complex , the result is of the same type and kind as array .\nIf array is of type integer , the result is of type real(dp) . If array is of rank 1 and of size larger than 1, a scalar equal to 1 is returned. Otherwise, IEEE NaN is returned.\nIf array is of rank 2, a rank-2 array  with the corresponding correlations is returned. If mask is specified, the result is the Pearson correlation of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example program demo_corr use stdlib_stats , only : corr implicit none real :: x ( 1 : 6 ) = [ 1. , 2. , 3. , 4. , 5. , 6. ] real :: y ( 1 : 2 , 1 : 3 ) = reshape ([ - 1. , 4 0. , - 3. , 4. , 1 0. , 6. ], [ 2 , 3 ]) print * , corr ( x , 1 ) !returns 1. print * , corr ( y , 2 ) !returns reshape([ 1., -.32480, -.32480, 1. ], [ 2, 3]) end program demo_corr cov - covariance of array elements Status Experimental Description Returns the covariance of the elements of array along dimension dim if the corresponding element in mask is true . Per default, the covariance is defined as: cov(array) = 1/(n-1) sum_i (array(i) - mean(array) * (array(i) - mean(array))) where n is the number of elements. The scaling can be changed with the logical argument corrected . If corrected is .false. , then the sum is scaled with n , otherwise with n-1 . Syntax result = cov (array, dim [, mask [, corrected]]) Arguments array : Shall be a rank-1 or a rank-2 array of type integer , real , or complex . dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . corrected (optional): Shall be a scalar of type logical . If corrected is .true. (default value), the sum is scaled with n-1 . If corrected is .false. , then the sum is scaled with n . Return value If array is of rank 1 and of type real or complex , the result is of type real corresponding to the type of array .\nIf array is of rank 2 and of type real or complex , the result is of the same type as array .\nIf array is of type integer , the result is of type real(dp) . If array is of rank 1, a scalar with the covariance (that is the variance) of all elements in array is returned.\nIf array is of rank 2, a rank-2 array is returned. If mask is specified, the result is the covariance of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example program demo_cov use stdlib_stats , only : cov implicit none real :: x ( 1 : 6 ) = [ 1. , 2. , 3. , 4. , 5. , 6. ] real :: y ( 1 : 2 , 1 : 3 ) = reshape ([ 1. , 2. , 3. , 4. , 5. , 6. ], [ 2 , 3 ]) print * , cov ( x , 1 ) !returns 3.5 print * , cov ( x , 1 , corrected = . false .) !returns 2.9167 print * , cov ( y , 1 ) !returns a square matrix of size 3 with all elements equal to 0.5 end program demo_cov mean - mean of array elements Status Experimental Description Returns the mean of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . Syntax result = mean (array [, mask]) result = mean (array, dim [, mask]) Arguments array : Shall be an array of type integer , real , or complex . dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . Return value If array is of type real or complex , the result is of the same type as array .\nIf array is of type integer , the result is of type real(dp) . If dim is absent, a scalar with the mean of all elements in array is returned. Otherwise, an array of rank n-1 , where n equals the rank of array , and a shape similar to that of array with dimension dim dropped is returned. If mask is specified, the result is the mean of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example program demo_mean use stdlib_stats , only : mean implicit none real :: x ( 1 : 6 ) = [ 1. , 2. , 3. , 4. , 5. , 6. ] real :: y ( 1 : 2 , 1 : 3 ) = reshape ([ 1. , 2. , 3. , 4. , 5. , 6. ], [ 2 , 3 ]) print * , mean ( x ) !returns 3.5 print * , mean ( y ) !returns 3.5 print * , mean ( y , 1 ) !returns [ 1.5, 3.5, 5.5 ] print * , mean ( y , 1 , y > 3. ) !returns [ NaN, 4.0, 5.5 ] end program demo_mean moment - central moments of array elements Status Experimental Description Returns the k -th order central moment of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . If a scalar or an array center is provided, the function returns the k -th order moment about 'center', of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . The k -th order central moment is defined as : moment(array) = 1/n sum_i (array(i) - mean(array))&#94;k where n is the number of elements. The k -th order moment about center is defined as : moment(array) = 1/n sum_i (array(i) - center)&#94;k Syntax result = moment (array, order [, center [, mask]]) result = moment (array, order, dim [, center [, mask]]) Arguments array : Shall be an array of type integer , real , or complex . order : Shall be an scalar of type integer . dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . center (optional): Shall be a scalar of the same type of result if dim is not provided. If dim is provided, center shall be a scalar or an array (with a shape similar to that of array with dimension dim dropped) of the same type of result . mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . Return value If array is of type real or complex , the result is of the same type as array .\nIf array is of type integer , the result is of type real(dp) . If dim is absent, a scalar with the k -th (central) moment of all elements in array is returned. Otherwise, an array of rank n-1 , where n equals the rank of array , and a shape similar to that of array with dimension dim dropped is returned. If mask is specified, the result is the k -th  (central) moment of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example program demo_moment use stdlib_stats , only : moment implicit none real :: x ( 1 : 6 ) = [ 1. , 2. , 3. , 4. , 5. , 6. ] real :: y ( 1 : 2 , 1 : 3 ) = reshape ([ 1. , 2. , 3. , 4. , 5. , 6. ], [ 2 , 3 ]) print * , moment ( x , 2 ) !returns 2.9167 print * , moment ( y , 2 ) !returns 2.9167 print * , moment ( y , 2 , 1 ) !returns [0.25, 0.25, 0.25] print * , moment ( y , 2 , 1 , mask = ( y > 3. )) !returns [NaN, 0., 0.25] print * , moment ( x , 2 , center = 0. ) !returns 15.1667 print * , moment ( y , 1 , 1 , center = 0. ) !returns [1.5, 3.5, 5.5] end program demo_moment var - variance of array elements Status Experimental Description Returns the variance of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . Per default, the variance is defined as the best unbiased estimator and is computed as: var(array) = 1/(n-1) sum_i (array(i) - mean(array))&#94;2 where n is the number of elements. The use of the term n-1 for scaling is called Bessel 's correction. The scaling can be changed with the logical argument corrected . If corrected is .false. , then the sum is scaled with n , otherwise with n-1 . Syntax result = var (array [, mask [, corrected]]) result = var (array, dim [, mask [, corrected]]) Arguments array : Shall be an array of type integer , real , or complex . dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . corrected (optional): Shall be a scalar of type logical . If corrected is .true. (default value), the sum is scaled with n-1 . If corrected is .false. , then the sum is scaled with n . Return value If array is of type real or complex , the result is of type real corresponding to the type of array .\nIf array is of type integer , the result is of type real(dp) . If dim is absent, a scalar with the variance of all elements in array is returned. Otherwise, an array of rank n-1 , where n equals the rank of array , and a shape similar to that of array with dimension dim dropped is returned. If mask is specified, the result is the variance of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . If the variance is computed with only one single element, then the result is IEEE NaN if corrected is .true. and is 0. if corrected is .false. . Example program demo_var use stdlib_stats , only : var implicit none real :: x ( 1 : 6 ) = [ 1. , 2. , 3. , 4. , 5. , 6. ] real :: y ( 1 : 2 , 1 : 3 ) = reshape ([ 1. , 2. , 3. , 4. , 5. , 6. ], [ 2 , 3 ]) print * , var ( x ) !returns 3.5 print * , var ( x , corrected = . false .) !returns 2.9167 print * , var ( y ) !returns 3.5 print * , var ( y , 1 ) !returns [0.5, 0.5, 0.5] print * , var ( y , 1 , y > 3. ) !returns [NaN, NaN, 0.5] print * , var ( y , 1 , y > 3. , corrected = . false .) !returns [NaN, 0., 0.25] end program demo_var","tags":"","loc":"page/specs/stdlib_stats.html"}]}