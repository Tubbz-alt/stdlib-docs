var tipuesearch = {"pages":[{"title":" Fortran-lang/stdlib ","text":"Fortran-lang/stdlib Fortran stdlib API Documentation Goals and Motivation Scope Code of Conduct License Warning This API documentation for the Fortran-lang/stdlib is a work in progress Note Use the navigation bar at the top of the screen to browse modules, procedures, source files, etc.\nThe listings near the bottom of the page are incomplete. Fortran stdlib API Documentation This is the main API documentation landing page generated by FORD .\nThe documentation for comment markup in source code, running FORD and the FORD project file are all maintained on the FORD wiki . Goals and Motivation The Fortran Standard, as published by the ISO (https://wg5-fortran.org/), does\nnot have a Standard Library. The goal of this project is to provide a community\ndriven and agreed upon de facto \"standard\" library for Fortran, called a\nFortran Standard Library ( stdlib ). We have a rigorous process how stdlib is\ndeveloped as documented in our Workflow . stdlib is both a\nspecification and a reference implementation. We are cooperating with the\nFortran Standards Committee (e.g., the effort started at the J3\ncommittee repository) and the plan is to continue working with the Committee in\nthe future (such as in the step 5. in the Workflow document), so\nthat if the Committee wants to standardize some feature already available in stdlib , it would\nbase it on stdlib 's implementation. Scope The goal of the Fortran Standard Library is to achieve the following general scope: Utilities (containers, strings, files, OS/environment integration, unit\n  testing & assertions, logging,  ...) Algorithms (searching and sorting, merging, ...) Mathematics (linear algebra, sparse matrices, special functions, fast Fourier\n  transform, random numbers, statistics, ordinary differential equations,\n  numerical integration, optimization, ...) Code of Conduct In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Please read first this Code of Conduct License The stdlib source code and related files and documentation are distributed under the MIT license . Developer Info fortran-lang/stdlib contributors","tags":"home","loc":"index.html"},{"title":"stdlib_stats_corr.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_corr.fypp~~EfferentGraph sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_linalg.fypp stdlib_linalg.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_linalg.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_corr Source Code stdlib_stats_corr.fypp Source Code #:include \"common.fypp\" #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_corr use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_linalg , only : diag use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( ${ k1 }$ ) :: res if (. not . optval ( mask , . true .) . or . size ( x ) < 2 ) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if res = 1 end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res if (. not . optval ( mask , . true .) . or . size ( x ) < 2 ) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if res = 1 end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) real ( ${ k1 }$ ) :: res if ( count ( mask ) < 2 ) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if res = 1 end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) real ( dp ) :: res if ( count ( mask ) < 2 ) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if res = 1 end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j ${ t1 }$ :: mean_ ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) ${ t1 }$ :: center ( size ( x , 1 ), size ( x , 2 )) if (. not . optval ( mask , . true .) . or . size ( x ) < 2 ) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if mean_ = mean ( x , dim ) select case ( dim ) case ( 1 ) do i = 1 , size ( x , 1 ) center ( i , :) = x ( i , :) - mean_ end do # : if t1 [ 0 ] == 'r' res = matmul ( transpose ( center ), center ) # : else res = matmul ( transpose ( conjg ( center )), center ) # : endif case ( 2 ) do i = 1 , size ( x , 2 ) center (:, i ) = x (:, i ) - mean_ end do # : if t1 [ 0 ] == 'r' res = matmul ( center , transpose ( center )) # : else res = matmul ( center , transpose ( conjg ( center ))) # : endif case default call error_stop ( \"ERROR (corr): wrong dimension\" ) end select mean_ = 1 / sqrt ( diag ( res )) do i = 1 , size ( res , 1 ) do j = 1 , size ( res , 2 ) res ( j , i ) = res ( j , i ) * mean_ ( i ) * mean_ ( j ) end do end do end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j real ( dp ) :: mean_ ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) real ( dp ) :: center ( size ( x , 1 ), size ( x , 2 )) if (. not . optval ( mask , . true .) . or . size ( x ) < 2 ) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if mean_ = mean ( x , dim ) select case ( dim ) case ( 1 ) do i = 1 , size ( x , 1 ) center ( i , :) = real ( x ( i , :), dp ) - mean_ end do res = matmul ( transpose ( center ), center ) case ( 2 ) do i = 1 , size ( x , 2 ) center (:, i ) = real ( x (:, i ), dp ) - mean_ end do res = matmul ( center , transpose ( center )) case default call error_stop ( \"ERROR (corr): wrong dimension\" ) end select mean_ = 1 / sqrt ( diag ( res )) do i = 1 , size ( res , 1 ) do j = 1 , size ( res , 2 ) res ( j , i ) = res ( j , i ) * mean_ ( i ) * mean_ ( j ) end do end do end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j ${ t1 }$ :: centeri_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) ${ t1 }$ :: centerj_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) logical :: mask_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) select case ( dim ) case ( 1 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask (:, i ) . and . mask (:, j )) centeri_ = merge ( x (:, i ) - mean ( x (:, i ), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) centerj_ = merge ( x (:, j ) - mean ( x (:, j ), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) res ( j , i ) = dot_product ( centerj_ , centeri_ )& / sqrt ( dot_product ( centeri_ , centeri_ ) * & dot_product ( centerj_ , centerj_ )) end do end do case ( 2 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask ( i , :) . and . mask ( j , :)) centeri_ = merge ( x ( i , :) - mean ( x ( i , :), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) centerj_ = merge ( x ( j , :) - mean ( x ( j , :), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) res ( j , i ) = dot_product ( centeri_ , centerj_ )& / sqrt ( dot_product ( centeri_ , centeri_ ) * & dot_product ( centerj_ , centerj_ )) end do end do case default call error_stop ( \"ERROR (corr): wrong dimension\" ) end select end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j real ( dp ) :: centeri_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) real ( dp ) :: centerj_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) logical :: mask_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) select case ( dim ) case ( 1 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask (:, i ) . and . mask (:, j )) centeri_ = merge ( x (:, i ) - mean ( x (:, i ), mask = mask_ ),& 0._dp , mask_ ) centerj_ = merge ( x (:, j ) - mean ( x (:, j ), mask = mask_ ),& 0._dp , mask_ ) res ( j , i ) = dot_product ( centerj_ , centeri_ )& / sqrt ( dot_product ( centeri_ , centeri_ ) * & dot_product ( centerj_ , centerj_ )) end do end do case ( 2 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask ( i , :) . and . mask ( j , :)) centeri_ = merge ( x ( i , :) - mean ( x ( i , :), mask = mask_ ),& 0._dp , mask_ ) centerj_ = merge ( x ( j , :) - mean ( x ( j , :), mask = mask_ ),& 0._dp , mask_ ) res ( j , i ) = dot_product ( centeri_ , centerj_ )& / sqrt ( dot_product ( centeri_ , centeri_ ) * & dot_product ( centerj_ , centerj_ )) end do end do case default call error_stop ( \"ERROR (corr): wrong dimension\" ) end select end function ${ RName }$ # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_corr.fypp.html"},{"title":"stdlib_stats_cov.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_cov.fypp~~EfferentGraph sourcefile~stdlib_stats_cov.fypp stdlib_stats_cov.fypp sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_cov Source Code stdlib_stats_cov.fypp Source Code #:include \"common.fypp\" #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_cov use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if res = var ( x , dim , corrected = optval ( corrected , . true .)) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if res = var ( x , dim , corrected = optval ( corrected , . true .)) end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res res = var ( x , dim , mask , corrected = optval ( corrected , . true .)) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) logical , intent ( in ), optional :: corrected real ( dp ) :: res res = var ( x , dim , mask , corrected = optval ( corrected , . true .)) end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i ${ t1 }$ :: mean_ ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) ${ t1 }$ :: center ( size ( x , 1 ), size ( x , 2 )) if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if mean_ = mean ( x , dim ) select case ( dim ) case ( 1 ) do i = 1 , size ( x , 1 ) center ( i , :) = x ( i , :) - mean_ end do # : if t1 [ 0 ] == 'r' res = matmul ( transpose ( center ), center ) # : else res = matmul ( transpose ( conjg ( center )), center ) # : endif case ( 2 ) do i = 1 , size ( x , 2 ) center (:, i ) = x (:, i ) - mean_ end do # : if t1 [ 0 ] == 'r' res = matmul ( center , transpose ( center )) # : else res = matmul ( center , transpose ( conjg ( center ))) # : endif case default call error_stop ( \"ERROR (cov): wrong dimension\" ) end select res = res / ( size ( x , dim ) - merge ( 1 , 0 , optval ( corrected , . true .))) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i real ( dp ) :: mean_ ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) real ( dp ) :: center ( size ( x , 1 ), size ( x , 2 )) if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if mean_ = mean ( x , dim ) select case ( dim ) case ( 1 ) do i = 1 , size ( x , 1 ) center ( i , :) = real ( x ( i , :), dp ) - mean_ end do res = matmul ( transpose ( center ), center ) case ( 2 ) do i = 1 , size ( x , 2 ) center (:, i ) = real ( x (:, i ), dp ) - mean_ end do res = matmul ( center , transpose ( center )) case default call error_stop ( \"ERROR (cov): wrong dimension\" ) end select res = res / ( size ( x , dim ) - merge ( 1 , 0 , optval ( corrected , . true .))) end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) logical , intent ( in ), optional :: corrected ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j , n ${ t1 }$ :: centeri_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) ${ t1 }$ :: centerj_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) logical :: mask_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) select case ( dim ) case ( 1 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask (:, i ) . and . mask (:, j )) centeri_ = merge ( x (:, i ) - mean ( x (:, i ), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) centerj_ = merge ( x (:, j ) - mean ( x (:, j ), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) n = count ( mask_ ) res ( j , i ) = dot_product ( centerj_ , centeri_ )& / ( n - merge ( 1 , 0 ,& optval ( corrected , . true .) . and . n > 0 )) end do end do case ( 2 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask ( i , :) . and . mask ( j , :)) centeri_ = merge ( x ( i , :) - mean ( x ( i , :), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) centerj_ = merge ( x ( j , :) - mean ( x ( j , :), mask = mask_ ),& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask_ ) n = count ( mask_ ) res ( j , i ) = dot_product ( centeri_ , centerj_ )& / ( n - merge ( 1 , 0 ,& optval ( corrected , . true .) . and . n > 0 )) end do end do case default call error_stop ( \"ERROR (cov): wrong dimension\" ) end select end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) logical , intent ( in ), optional :: corrected real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) integer :: i , j , n real ( dp ) :: centeri_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) real ( dp ) :: centerj_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) logical :: mask_ ( merge ( size ( x , 2 ), size ( x , 1 ), mask = 1 < dim )) select case ( dim ) case ( 1 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask (:, i ) . and . mask (:, j )) centeri_ = merge ( x (:, i ) - mean ( x (:, i ), mask = mask_ ),& 0._dp , mask_ ) centerj_ = merge ( x (:, j ) - mean ( x (:, j ), mask = mask_ ),& 0._dp , mask_ ) n = count ( mask_ ) res ( j , i ) = dot_product ( centerj_ , centeri_ )& / ( n - merge ( 1 , 0 ,& optval ( corrected , . true .) . and . n > 0 )) end do end do case ( 2 ) do i = 1 , size ( res , 2 ) do j = 1 , size ( res , 1 ) mask_ = merge (. true ., . false ., mask ( i , :) . and . mask ( j , :)) centeri_ = merge ( x ( i , :) - mean ( x ( i , :), mask = mask_ ),& 0._dp , mask_ ) centerj_ = merge ( x ( j , :) - mean ( x ( j , :), mask = mask_ ),& 0._dp , mask_ ) n = count ( mask_ ) res ( j , i ) = dot_product ( centeri_ , centerj_ )& / ( n - merge ( 1 , 0 ,& optval ( corrected , . true .) . and . n > 0 )) end do end do case default call error_stop ( \"ERROR (cov): wrong dimension\" ) end select end function ${ RName }$ # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_cov.fypp.html"},{"title":"common.fypp – Fortran-lang/stdlib","text":"Contents Source Code common.fypp Source Code #:mute #! Real kinds to be considered during templating #:set REAL_KINDS = [\"sp\", \"dp\", \"qp\"] #! Real types to be considere during templating #:set REAL_TYPES = [\"real({})\".format(k) for k in REAL_KINDS] #! Collected (kind, type) tuples for real types #:set REAL_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES)) #! Complex kinds to be considered during templating #:set CMPLX_KINDS = [\"sp\", \"dp\", \"qp\"] #! Complex types to be considere during templating #:set CMPLX_TYPES = [\"complex({})\".format(k) for k in CMPLX_KINDS] #! Collected (kind, type) tuples for complex types #:set CMPLX_KINDS_TYPES = list(zip(CMPLX_KINDS, CMPLX_TYPES)) #! Integer kinds to be considered during templating #:set INT_KINDS = [\"int8\", \"int16\", \"int32\", \"int64\"] #! Integer types to be considere during templating #:set INT_TYPES = [\"integer({})\".format(k) for k in INT_KINDS] #! Collected (kind, type) tuples for integer types #:set INT_KINDS_TYPES = list(zip(INT_KINDS, INT_TYPES)) #! Whether Fortran 90 compatible code should be generated #:set VERSION90 = defined('VERSION90') #! Ranks to be generated when templates are created #:if not defined('MAXRANK') # : if VERSION90 # : set MAXRANK = 7 # : else # : set MAXRANK = 15 # : endif #:endif #! Generates an array rank suffix. #! #! Args: #!     rank (int): Rank of the variable #! #! Returns: #!     Array rank suffix string (e.g. (:,:) if rank = 2) #! #:def ranksuffix(rank) #{if rank > 0}#(${\":\" + \",:\" * (rank - 1)}$)#{endif}# #:enddef #! Joins stripped lines with given character string #! #! Args: #!   txt (str): Text to process #!   joinstr (str): String to use as connector #!   prefix (str): String to add as prefix before the joined text #!   suffix (str): String to add as suffix after the joined text #! #! Returns: #!   Lines stripped and joined with the given string. #! #:def join_lines(txt, joinstr, prefix=\"\", suffix=\"\") ${ prefix + joinstr . join ([ line . strip () for line in txt . split ( \"\\n\" )]) + suffix }$ #:enddef #! Brace enclosed, comma separated Fortran expressions for a reduced shape. #! #! Rank of the original variable will be reduced by one. The routine generates #! for each dimension a Fortan expression using merge(), which calculates the #! size of the array for that dimension. #! #! Args: #!   varname (str): Name of the variable to be used as origin #!   origrank (int): Rank of the original variable #!   idim (int): Index of the reduced dimension #! #! Returns: #!   Shape expression enclosed in braces, so that it can be used as suffix to #!   define array shapes in declarations. #! #:def reduced_shape(varname, origrank, idim) # : assert origrank > 0 # : if origrank > 1 # : call join_lines ( joinstr = \", \" , prefix = \"(\" , suffix = \")\" ) # : for i in range ( 1 , origrank ) merge ( size ( ${ varname }$ , ${ i }$ ), size ( ${ varname }$ , ${ i + 1 }$ ), mask = ${ i }$ < ${ idim }$ ) # : endfor # : endcall # : endif #:enddef #! Generates a routine name from a generic name, rank, type and kind #! #! Args: #!   gname (str): Generic name #!   rank (integer): Rank if exist #!   type (str): Type of the input #!   kind (str): kind of inputs variable #!   suffix (str): other identifier (could be used for output type/kind) #! #! Returns: #!   A string with a new name #! #:def rname(gname, rank, type, kind, suffix='') $ : \"{0}_{1}_{2}{3}_{2}{3}\" . format ( gname , rank , type [ 0 ], kind ) if suffix == '' else \"{0}_{1}_{2}{3}_{4}\" . format ( gname , rank , type [ 0 ], kind , suffix ) #:enddef #! Generates an array rank suffix for subarrays reducing the dimension #! #! Args: #!   rank (int): Rank of the original variable #!   selectors (array): Dimension and name of the variable(s) #! #! Returns: #!   Array rank suffix string enclosed in braces #! #! E.g., #!   select_subarray(5 , [(4, 'i'), (5, 'j')])}$ #!   -> (:, :, :, i, j) #! #:def select_subarray(rank, selectors) # : assert rank > 0 # : set seldict = dict ( selectors ) # : call join_lines ( joinstr = \", \" , prefix = \"(\" , suffix = \")\" ) # : for i in range ( 1 , rank + 1 ) $ : seldict . get ( i , \":\" ) # : endfor # : endcall #:enddef #:endmute","tags":"","loc":"sourcefile/common.fypp.html"},{"title":"stdlib_stats_moment.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_moment.fypp~~EfferentGraph sourcefile~stdlib_stats_moment.fypp stdlib_stats_moment.fypp sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_moment Source Code stdlib_stats_moment.fypp Source Code #:include \"common.fypp\" #:set RANKS = range(1, MAXRANK + 1) #:set REDRANKS = range(2, MAXRANK + 1) #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_moment use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order ${ t1 }$ , intent ( in ), optional :: center logical , intent ( in ), optional :: mask ${ t1 }$ :: res real ( ${ k1 }$ ) :: n if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if n = size ( x , kind = int64 ) if ( present ( center )) then res = sum (( x - center ) ** order ) / n else res = sum (( x - mean ( x )) ** order ) / n end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order real ( dp ), intent ( in ), optional :: center logical , intent ( in ), optional :: mask real ( dp ) :: res real ( dp ) :: n if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if n = size ( x , kind = int64 ) if ( present ( center )) then res = sum (( real ( x , dp ) - center ) ** order ) / n else res = sum (( real ( x , dp ) - mean ( x )) ** order ) / n end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_scalar\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ) :: center logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum (( x - center ) ** order , dim ) / size ( x , dim ) else call error_stop ( \"ERROR (moment): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( ${ k1 }$ ) :: n ${ t1 }$ , allocatable :: mean_$ { ranksuffix ( rank - 1 ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if n = size ( x , dim ) res = 0 select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) if ( present ( center )) then do i = 1 , size ( x , ${ fi }$ ) res = res + ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - center ) ** order end do else allocate ( mean_ , source = mean ( x , ${ fi }$ )) do i = 1 , size ( x , ${ fi }$ ) res = res + ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean_ ) ** order end do deallocate ( mean_ ) end if # : endfor case default call error_stop ( \"ERROR (moment): wrong dimension\" ) end select res = res / n end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_scalar\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ) :: center logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum ( ( real ( x , dp ) - center ) ** order , dim ) / size ( x , dim ) else call error_stop ( \"ERROR (moment): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( dp ) :: n real ( dp ), allocatable :: mean_$ { ranksuffix ( rank - 1 ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if n = size ( x , dim ) res = 0 select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) if ( present ( center )) then do i = 1 , size ( x , ${ fi }$ ) res = res + ( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - & center ) ** order end do else allocate ( mean_ , source = mean ( x , ${ fi }$ )) do i = 1 , size ( x , ${ fi }$ ) res = res + ( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - mean_ ) ** order end do deallocate ( mean_ ) end if # : endfor case default call error_stop ( \"ERROR (moment): wrong dimension\" ) end select res = res / n end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order ${ t1 }$ , intent ( in ), optional :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res real ( ${ k1 }$ ) :: n n = count ( mask , kind = int64 ) if ( present ( center )) then res = sum (( x - center ) ** order , mask ) / n else res = sum (( x - mean ( x , mask )) ** order , mask ) / n end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order real ( dp ), intent ( in ), optional :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res real ( dp ) :: n n = count ( mask , kind = int64 ) if ( present ( center )) then res = sum (( real ( x , dp ) - center ) ** order , mask ) / n else res = sum (( real ( x , dp ) - mean ( x , mask )) ** order , mask ) / n end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_mask_scalar\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ) :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum (( x - center ) ** order , dim , mask ) / count ( mask , dim ) else call error_stop ( \"ERROR (moment): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( ${ k1 }$ ) :: n$ { reduced_shape ( 'x' , rank , 'dim' ) }$ ${ t1 }$ , allocatable :: mean_$ { ranksuffix ( rank - 1 ) }$ n = count ( mask , dim ) res = 0 select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) if ( present ( center )) then do i = 1 , size ( x , ${ fi }$ ) res = res + merge ( ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - & center ) ** order ,& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do else allocate ( mean_ , source = mean ( x , ${ fi }$ , mask )) do i = 1 , size ( x , ${ fi }$ ) res = res + merge ( ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean_ ) ** order ,& # : if t1 [ 0 ] == 'r' 0. _${ k1 }$ ,& # : else cmplx ( 0 , 0 , kind = ${ k1 }$ ),& # : endif mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do deallocate ( mean_ ) end if # : endfor case default call error_stop ( \"ERROR (moment): wrong dimension\" ) end select res = res / n end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_mask_scalar\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ) :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum (( real ( x , dp ) - center ) ** order , dim , mask ) / count ( mask , dim ) else call error_stop ( \"ERROR (moment): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( dp ) :: n$ { reduced_shape ( 'x' , rank , 'dim' ) }$ real ( dp ), allocatable :: mean_$ { ranksuffix ( rank - 1 ) }$ n = count ( mask , dim ) res = 0 select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) if ( present ( center )) then do i = 1 , size ( x , ${ fi }$ ) res = res + merge (( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - & center ) ** order ,& 0._dp , mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do else allocate ( mean_ , source = mean ( x , ${ fi }$ , mask )) do i = 1 , size ( x , ${ fi }$ ) res = res + merge (( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - mean_ )& ** order ,& 0._dp , mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do deallocate ( mean_ ) end if # : endfor case default call error_stop ( \"ERROR (moment): wrong dimension\" ) end select res = res / n end function ${ RName }$ # : endfor # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_moment.fypp.html"},{"title":"stdlib_linalg.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_linalg.fypp~~EfferentGraph sourcefile~stdlib_linalg.fypp stdlib_linalg.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_linalg.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_linalg.fypp~~AfferentGraph sourcefile~stdlib_linalg.fypp stdlib_linalg.fypp sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_linalg_diag.fypp stdlib_linalg_diag.fypp sourcefile~stdlib_linalg_diag.fypp->sourcefile~stdlib_linalg.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_linalg Source Code stdlib_linalg.fypp Source Code #:include \"common.fypp\" #:set RCI_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES + INT_KINDS_TYPES module stdlib_linalg !!Provides a support for various linear algebra procedures !! ([Specification](../page/specs/stdlib_linalg.html)) use stdlib_kinds , only : sp , dp , qp , & int8 , int16 , int32 , int64 implicit none private public :: diag public :: eye public :: trace interface diag !! version: experimental !! !! Creates a diagonal array or extract the diagonal elements of an array !! ([Specification](../page/specs/stdlib_linalg.html#description)) ! ! Vector to matrix ! # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$ ( v ) result ( res ) ${ t1 }$ , intent ( in ) :: v (:) ${ t1 }$ :: res ( size ( v ), size ( v )) end function diag_$ { t1 [ 0 ] }{ k1 }$ # : endfor # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ k ( v , k ) result ( res ) ${ t1 }$ , intent ( in ) :: v (:) integer , intent ( in ) :: k ${ t1 }$ :: res ( size ( v ) + abs ( k ), size ( v ) + abs ( k )) end function diag_$ { t1 [ 0 ] }{ k1 }$_ k # : endfor ! ! Matrix to vector ! # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ mat ( A ) result ( res ) ${ t1 }$ , intent ( in ) :: A (:,:) ${ t1 }$ :: res ( minval ( shape ( A ))) end function diag_$ { t1 [ 0 ] }{ k1 }$_ mat # : endfor # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ mat_k ( A , k ) result ( res ) ${ t1 }$ , intent ( in ) :: A (:,:) integer , intent ( in ) :: k ${ t1 }$ :: res ( minval ( shape ( A )) - abs ( k )) end function diag_$ { t1 [ 0 ] }{ k1 }$_ mat_k # : endfor end interface ! Matrix trace interface trace !! version: experimental !! !! Computes the trace of a matrix !! ([Specification](../page/specs/stdlib_linalg.html#description_2)) # : for k1 , t1 in RCI_KINDS_TYPES module procedure trace_$ { t1 [ 0 ] }{ k1 }$ # : endfor end interface contains function eye ( n ) result ( res ) !! version: experimental !! !! Constructs the identity matrix !! ([Specification](../page/specs/stdlib_linalg.html#description_1)) integer , intent ( in ) :: n integer ( int8 ) :: res ( n , n ) integer :: i res = 0 do i = 1 , n res ( i , i ) = 1 end do end function eye # : for k1 , t1 in RCI_KINDS_TYPES function trace_$ { t1 [ 0 ] }{ k1 }$ ( A ) result ( res ) ${ t1 }$ , intent ( in ) :: A (:,:) ${ t1 }$ :: res integer :: i res = 0 do i = 1 , minval ( shape ( A )) res = res + A ( i , i ) end do end function trace_$ { t1 [ 0 ] }{ k1 }$ # : endfor end module","tags":"","loc":"sourcefile/stdlib_linalg.fypp.html"},{"title":"stdlib_optval.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_optval.fypp~~EfferentGraph sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_optval.fypp~~AfferentGraph sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_io.fypp stdlib_io.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_io.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_cov.fypp stdlib_stats_cov.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_var.fypp stdlib_stats_var.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_moment.fypp stdlib_stats_moment.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_mean.fypp stdlib_stats_mean.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_quadrature_simps.fypp stdlib_quadrature_simps.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_error.f90 sourcefile~f08estop.f90 f08estop.f90 sourcefile~f08estop.f90->sourcefile~stdlib_error.f90 sourcefile~f18estop.f90 f18estop.f90 sourcefile~f18estop.f90->sourcefile~stdlib_error.f90 sourcefile~stdlib_quadrature_trapz.fypp stdlib_quadrature_trapz.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_optval Source Code stdlib_optval.fypp Source Code #:include \"common.fypp\" #:set KINDS_TYPES = REAL_KINDS_TYPES + INT_KINDS_TYPES + CMPLX_KINDS_TYPES + & & [( 'l1' , 'logical' )] module stdlib_optval !! !! Provides a generic function `optval`, which can be used to !! conveniently implement fallback values for optional arguments !! to subprograms !! ([Specification](../page/specs/stdlib_optval.html)) !! !! If `x` is an `optional` parameter of a !! subprogram, then the expression `optval(x, default)` inside that !! subprogram evaluates to `x` if it is present, otherwise `default`. !! !! It is an error to call `optval` with a single actual argument. !! use stdlib_kinds , only : sp , dp , qp , int8 , int16 , int32 , int64 implicit none private public :: optval interface optval !! version: experimental !! !! Fallback value for optional arguments !! ([Specification](../page/specs/stdlib_optval.html#description)) # : for k1 , t1 in KINDS_TYPES module procedure optval_$ { t1 [ 0 ] }{ k1 }$ # : endfor module procedure optval_character ! TODO: differentiate ascii & ucs char kinds end interface optval contains # : for k1 , t1 in KINDS_TYPES pure elemental function optval_$ { t1 [ 0 ] }{ k1 }$ ( x , default ) result ( y ) ${ t1 }$ , intent ( in ), optional :: x ${ t1 }$ , intent ( in ) :: default ${ t1 }$ :: y if ( present ( x )) then y = x else y = default end if end function optval_$ { t1 [ 0 ] }{ k1 }$ # : endfor ! Cannot be made elemental pure function optval_character ( x , default ) result ( y ) character ( len =* ), intent ( in ), optional :: x character ( len =* ), intent ( in ) :: default character ( len = :), allocatable :: y if ( present ( x )) then y = x else y = default end if end function optval_character end module stdlib_optval","tags":"","loc":"sourcefile/stdlib_optval.fypp.html"},{"title":"stdlib_stats.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats.fypp~~EfferentGraph sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_stats.fypp~~AfferentGraph sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_cov.fypp stdlib_stats_cov.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_var.fypp stdlib_stats_var.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_moment.fypp stdlib_stats_moment.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_mean.fypp stdlib_stats_mean.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_stats.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_stats Source Code stdlib_stats.fypp Source Code #:include \"common.fypp\" #:set RANKS = range(1, MAXRANK + 1) #:set REDRANKS = range(2, MAXRANK + 1) #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES module stdlib_stats !! Provides support for various statistical methods. This includes currently !! descriptive statistics !! ([Specification](../page/specs/stdlib_stats.html)) use stdlib_kinds , only : sp , dp , qp , & int8 , int16 , int32 , int64 implicit none private ! Public API public :: corr , cov , mean , moment , var interface corr !! version: experimental !! !! Pearson correlation of array elements !! ([Specification](../page/specs/stdlib_stats.html#description)) # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) real ( dp ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"corr_mask\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor end interface corr interface cov !! version: experimental !! !! Covariance of array elements !! ([Specification](../page/specs/stdlib_stats.html#description_1)) # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 1 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 1 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:) logical , intent ( in ), optional :: corrected real ( dp ) :: res end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 2 , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) logical , intent ( in ), optional :: corrected ${ t1 }$ :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : set RName = rname ( \"cov_mask\" , 2 , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x (:, :) integer , intent ( in ) :: dim logical , intent ( in ) :: mask (:,:) logical , intent ( in ), optional :: corrected real ( dp ) :: res ( merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )& , merge ( size ( x , 1 ), size ( x , 2 ), mask = 1 < dim )) end function ${ RName }$ # : endfor end interface cov interface mean !! version: experimental !! !! Mean of array elements !! ([Specification](../page/specs/stdlib_stats.html#description_2)) # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask ${ t1 }$ :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_all' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask_all' , rank , t1 , k1 ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask_all' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask' , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor end interface mean interface var !! version: experimental !! !! Variance of array elements !! ([Specification](../page/specs/stdlib_stats.html#description_4)) # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor end interface var interface moment !! version: experimental !! !! Central moment of array elements !! ([Specification](../page/specs/stdlib_stats.html#description_3)) # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order ${ t1 }$ , intent ( in ), optional :: center logical , intent ( in ), optional :: mask ${ t1 }$ :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order real ( dp ), intent ( in ), optional :: center logical , intent ( in ), optional :: mask real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_scalar\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ) :: center logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_scalar\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ) :: center logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order ${ t1 }$ , intent ( in ), optional :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order real ( dp ), intent ( in ), optional :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_mask_scalar\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ) :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask\" , rank , t1 , k1 ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim ${ t1 }$ , intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in REDRANKS # : set RName = rname ( \"moment_mask_scalar\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ) :: center logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"moment_mask\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , order , dim , center , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: order integer , intent ( in ) :: dim real ( dp ), intent ( in ), optional :: center$ { reduced_shape ( 'x' , rank , 'dim' ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ end function ${ RName }$ # : endfor # : endfor end interface moment end module stdlib_stats","tags":"","loc":"sourcefile/stdlib_stats.fypp.html"},{"title":"stdlib_io.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_io.fypp~~EfferentGraph sourcefile~stdlib_io.fypp stdlib_io.fypp sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_io.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_io.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_ascii.f90 stdlib_ascii.f90 sourcefile~stdlib_io.fypp->sourcefile~stdlib_ascii.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_io Source Code stdlib_io.fypp Source Code #:include \"common.fypp\" #:set KINDS_TYPES = REAL_KINDS_TYPES + INT_KINDS_TYPES + CMPLX_KINDS_TYPES module stdlib_io !! Provides a support for file handling !! ([Specification](../page/specs/stdlib_io.html)) use stdlib_kinds , only : sp , dp , qp , & int8 , int16 , int32 , int64 use stdlib_error , only : error_stop use stdlib_optval , only : optval use stdlib_ascii , only : is_blank implicit none private ! Public API public :: loadtxt , savetxt , open ! Private API that is exposed so that we can test it in tests public :: parse_mode interface loadtxt !! version: experimental !! !! Loads a 2D array from a text file !! ([Specification](../page/specs/stdlib_io.html#description)) # : for k1 , t1 in KINDS_TYPES module procedure loadtxt_$ { t1 [ 0 ] }{ k1 }$ # : endfor end interface loadtxt interface savetxt !! version: experimental !! !! Saves a 2D array into a text file !! ([Specification](../page/specs/stdlib_io.html#description_2)) # : for k1 , t1 in KINDS_TYPES module procedure savetxt_$ { t1 [ 0 ] }{ k1 }$ # : endfor end interface contains # : for k1 , t1 in KINDS_TYPES subroutine loadtxt_$ { t1 [ 0 ] }{ k1 }$ ( filename , d ) !! version: experimental !! !! Loads a 2D array from a text file. !! !! Arguments !! --------- !! !! Filename to load the array from character ( len =* ), intent ( in ) :: filename !! The array 'd' will be automatically allocated with the correct dimensions ${ t1 }$ , allocatable , intent ( out ) :: d (:,:) !! !! Example !! ------- !! !!```fortran !! ${t1}$, allocatable :: data(:, :) !! call loadtxt(\"log.txt\", data)  ! 'data' will be automatically allocated !!``` !! !! Where 'log.txt' contains for example:: !! !!     1 2 3 !!     2 4 6 !!     8 9 10 !!     11 12 13 !!     ... !! integer :: s integer :: nrow , ncol , i s = open ( filename ) ! determine number of columns ncol = number_of_columns ( s ) ! determine number or rows nrow = number_of_rows_numeric ( s ) allocate ( d ( nrow , ncol )) do i = 1 , nrow read ( s , * ) d ( i , :) end do close ( s ) end subroutine loadtxt_$ { t1 [ 0 ] }{ k1 }$ # : endfor # : for k1 , t1 in KINDS_TYPES subroutine savetxt_$ { t1 [ 0 ] }{ k1 }$ ( filename , d ) !! version: experimental !! !! Saves a 2D array into a text file. !! !! Arguments !! --------- !! character ( len =* ), intent ( in ) :: filename ! File to save the array to ${ t1 }$ , intent ( in ) :: d (:,:) ! The 2D array to save !! !! Example !! ------- !! !!```fortran !! ${t1}$ :: data(3, 2) !! call savetxt(\"log.txt\", data) !!``` !! integer :: s , i s = open ( filename , \"w\" ) do i = 1 , size ( d , 1 ) write ( s , * ) d ( i , :) end do close ( s ) end subroutine savetxt_$ { t1 [ 0 ] }{ k1 }$ # : endfor integer function number_of_columns ( s ) !! version: experimental !! !! determine number of columns integer , intent ( in ) :: s integer :: ios character :: c logical :: lastblank rewind ( s ) number_of_columns = 0 lastblank = . true . do read ( s , '(a)' , advance = 'no' , iostat = ios ) c if ( ios /= 0 ) exit if ( lastblank . and . . not . is_blank ( c )) number_of_columns = number_of_columns + 1 lastblank = is_blank ( c ) end do rewind ( s ) end function number_of_columns integer function number_of_rows_numeric ( s ) result ( nrows ) !! version: experimental !! !! determine number or rows integer , intent ( in ) :: s integer :: ios real :: r complex :: z rewind ( s ) nrows = 0 do read ( s , * , iostat = ios ) r if ( ios /= 0 ) exit nrows = nrows + 1 end do rewind ( s ) ! If there are no rows of real numbers, it may be that they are complex if ( nrows == 0 ) then do read ( s , * , iostat = ios ) z if ( ios /= 0 ) exit nrows = nrows + 1 end do rewind ( s ) end if end function number_of_rows_numeric integer function open ( filename , mode , iostat ) result ( u ) !! version: experimental !! !! Opens a file !! ([Specification](../page/specs/stdlib_io.html#description_1)) !! !!##### Behavior !! !! !! To open a file to read: !! !!```fortran !! u = open(\"somefile.txt\")        ! The default `mode` is \"rt\" !! u = open(\"somefile.txt\", \"r\") !!``` !! !! To open a file to write: !! !!```fortran !! u = open(\"somefile.txt\", \"w\") !!``` !! !! To append to the end of the file if it exists: !! !!```fortran !! u = open(\"somefile.txt\", \"a\") !!``` character ( * ), intent ( in ) :: filename character ( * ), intent ( in ), optional :: mode integer , intent ( out ), optional :: iostat character ( 3 ) :: mode_ character (:), allocatable :: action_ , position_ , status_ , access_ , form_ mode_ = parse_mode ( optval ( mode , \"\" )) select case ( mode_ ( 1 : 2 )) case ( 'r' ) action_ = 'read' position_ = 'asis' status_ = 'old' case ( 'w' ) action_ = 'write' position_ = 'asis' status_ = 'replace' case ( 'a' ) action_ = 'write' position_ = 'append' status_ = 'old' case ( 'x' ) action_ = 'write' position_ = 'asis' status_ = 'new' case ( 'r+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'old' case ( 'w+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'replace' case ( 'a+' ) action_ = 'readwrite' position_ = 'append' status_ = 'old' case ( 'x+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'new' case default call error_stop ( \"Unsupported mode: \" // mode_ ( 1 : 2 )) end select select case ( mode_ ( 3 : 3 )) case ( 't' ) form_ = 'formatted' case ( 'b' ) form_ = 'unformatted' case default call error_stop ( \"Unsupported mode: \" // mode_ ( 3 : 3 )) end select access_ = 'stream' if ( present ( iostat )) then open ( newunit = u , file = filename , & action = action_ , position = position_ , status = status_ , & access = access_ , form = form_ , & iostat = iostat ) else open ( newunit = u , file = filename , & action = action_ , position = position_ , status = status_ , & access = access_ , form = form_ ) end if end function open character ( 3 ) function parse_mode ( mode ) result ( mode_ ) character ( * ), intent ( in ) :: mode integer :: i character (:), allocatable :: a logical :: lfirst ( 3 ) mode_ = 'r t' if ( len_trim ( mode ) == 0 ) return a = trim ( adjustl ( mode )) lfirst = . true . do i = 1 , len ( a ) if ( lfirst ( 1 ) & . and . ( a ( i : i ) == 'r' . or . a ( i : i ) == 'w' . or . a ( i : i ) == 'a' . or . a ( i : i ) == 'x' ) & ) then mode_ ( 1 : 1 ) = a ( i : i ) lfirst ( 1 ) = . false . else if ( lfirst ( 2 ) . and . a ( i : i ) == '+' ) then mode_ ( 2 : 2 ) = a ( i : i ) lfirst ( 2 ) = . false . else if ( lfirst ( 3 ) . and . ( a ( i : i ) == 't' . or . a ( i : i ) == 'b' )) then mode_ ( 3 : 3 ) = a ( i : i ) lfirst ( 3 ) = . false . else if ( a ( i : i ) == ' ' ) then cycle else if ( any (. not . lfirst )) then call error_stop ( \"Wrong mode: \" // trim ( a )) else call error_stop ( \"Wrong character: \" // a ( i : i )) endif end do end function parse_mode end module","tags":"","loc":"sourcefile/stdlib_io.fypp.html"},{"title":"stdlib_quadrature_simps.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_quadrature_simps.fypp~~EfferentGraph sourcefile~stdlib_quadrature_simps.fypp stdlib_quadrature_simps.fypp sourcefile~stdlib_quadrature.fypp stdlib_quadrature.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_quadrature.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_quadrature_simps Source Code stdlib_quadrature_simps.fypp Source Code #:include \"common.fypp\" submodule ( stdlib_quadrature ) stdlib_quadrature_simps use stdlib_error , only : check implicit none ! internal use only interface simps38 # : for k1 , t1 in REAL_KINDS_TYPES module procedure simps38_dx_$ { k1 }$ module procedure simps38_x_$ { k1 }$ # : endfor end interface simps38 ! internal use only interface simps38_weights # : for k1 , t1 in REAL_KINDS_TYPES module procedure simps38_weights_$ { k1 }$ # : endfor end interface simps38_weights contains #:for k1, t1 in REAL_KINDS_TYPES pure recursive module function simps_dx_$ { k1 }$ ( y , dx , even ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , intent ( in ) :: dx integer , intent ( in ), optional :: even ${ t1 }$ :: integral integer :: n n = size ( y ) select case ( n ) case ( 0 : 1 ) integral = 0.0 _${ k1 }$ case ( 2 ) integral = 0.5 _${ k1 }$ * dx * ( y ( 1 ) + y ( 2 )) case ( 3 ) integral = dx / 3.0 _${ k1 }$ * ( y ( 1 ) + 4 * y ( 2 ) + y ( 3 )) case ( 4 ) integral = simps38 ( y , dx ) ! case (5) not needed; handled by default case ( 6 ) ! needs special handling because of averaged 3/8's rule case if ( present ( even )) then if ( even < 0 ) then ! 3/8 rule on left integral = simps38 ( y ( 1 : 4 ), dx ) + simps ( y ( 4 : 6 ), dx ) return else if ( even > 0 ) then ! 3/8 rule on right integral = simps ( y ( 1 : 3 ), dx ) + simps38 ( y ( 3 : 6 ), dx ) return else ! fall through end if end if ! either `even` not present or is zero ! equivalent to averaging left and right integral = dx / 4 8.0 _${ k1 }$ * ( 17 * ( y ( 1 ) + y ( 6 )) + 59 * ( y ( 2 ) + y ( 5 )) + 44 * ( y ( 3 ) + y ( 4 ))) case default if ( mod ( n , 2 ) == 1 ) then integral = dx / 3.0 _${ k1 }$ * ( y ( 1 ) + 4 * sum ( y ( 2 : n - 1 : 2 )) + 2 * sum ( y ( 3 : n - 2 : 2 )) + y ( n )) else if ( present ( even )) then if ( even < 0 ) then ! 3/8th rule on left integral = simps38 ( y ( 1 : 4 ), dx ) + simps ( y ( 4 : n ), dx ) return else if ( even > 0 ) then ! 3/8 rule on right integral = simps ( y ( 1 : n - 3 ), dx ) + simps38 ( y ( n - 3 : n ), dx ) return else ! fall through end if end if ! either `even` not present or is zero ! equivalent to averaging left and right integral = dx / 4 8.0 _${ k1 }$ * ( 17 * ( y ( 1 ) + y ( n )) + 59 * ( y ( 2 ) + y ( n - 1 )) & + 43 * ( y ( 3 ) + y ( n - 2 )) + 49 * ( y ( 4 ) + y ( n - 3 )) + 48 * sum ( y ( 5 : n - 4 ))) end if end select end function simps_dx_$ { k1 }$ #:endfor #:for k1, t1 in REAL_KINDS_TYPES recursive module function simps_x_$ { k1 }$ ( y , x , even ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: even ${ t1 }$ :: integral integer :: i integer :: n ${ t1 }$ :: h1 , h2 ${ t1 }$ :: a , b , c n = size ( y ) call check ( size ( x ) == n , \"simps: Arguments `x` and `y` must be the same size.\" ) select case ( n ) case ( 0 : 1 ) integral = 0.0 _${ k1 }$ case ( 2 ) integral = 0.5 _${ k1 }$ * ( x ( 2 ) - x ( 1 )) * ( y ( 1 ) + y ( 2 )) case ( 3 ) h1 = x ( 2 ) - x ( 1 ) h2 = x ( 3 ) - x ( 2 ) a = ( 2 * h1 ** 2 + h1 * h2 - h2 ** 2 ) / ( 6 * h1 ) b = ( h1 + h2 ) ** 3 / ( 6 * h1 * h2 ) c = ( 2 * h2 ** 2 + h1 * h2 - h1 ** 2 ) / ( 6 * h2 ) integral = a * y ( 1 ) + b * y ( 2 ) + c * y ( 3 ) case ( 4 ) integral = simps38 ( y , x ) ! case (6) unneeded; handled by default case default if ( mod ( n , 2 ) == 1 ) then integral = 0.0 _${ k1 }$ do i = 1 , n - 2 , 2 h1 = x ( i + 1 ) - x ( i ) h2 = x ( i + 2 ) - x ( i + 1 ) a = ( 2 * h1 ** 2 + h1 * h2 - h2 ** 2 ) / ( 6 * h1 ) b = ( h1 + h2 ) ** 3 / ( 6 * h1 * h2 ) c = ( 2 * h2 ** 2 + h1 * h2 - h1 ** 2 ) / ( 6 * h2 ) integral = integral + a * y ( i ) + b * y ( i + 1 ) + c * y ( i + 2 ) end do else if ( present ( even )) then if ( even < 0 ) then ! 3/8 rule on left integral = simps38 ( y ( 1 : 4 ), x ( 1 : 4 )) + simps ( y ( 4 : n ), x ( 4 : n )) return else if ( even > 0 ) then ! 3/8 rule on right integral = simps ( y ( 1 : n - 3 ), x ( 1 : n - 3 )) + simps38 ( y ( n - 3 : n ), x ( n - 3 : n )) return else ! fall through end if end if ! either `even` not present or is zero integral = 0.5 _${ k1 }$ * ( simps38 ( y ( 1 : 4 ), x ( 1 : 4 )) + simps ( y ( 4 : n ), x ( 4 : n )) & + simps ( y ( 1 : n - 3 ), x ( 1 : n - 3 )) + simps38 ( y ( n - 3 : n ), x ( n - 3 : n )) ) end if end select end function simps_x_$ { k1 }$ #:endfor #:for k1, t1 in REAL_KINDS_TYPES pure recursive module function simps_weights_$ { k1 }$ ( x , even ) result ( w ) ${ t1 }$ , dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: even ${ t1 }$ , dimension ( size ( x )) :: w integer :: i , n ${ t1 }$ :: h1 , h2 n = size ( x ) select case ( n ) case ( 0 ) ! no action needed case ( 1 ) w ( 1 ) = 0.0 _${ k1 }$ case ( 2 ) w = 0.5 _${ k1 }$ * ( x ( 2 ) - x ( 1 )) case ( 3 ) h1 = x ( 2 ) - x ( 1 ) h2 = x ( 3 ) - x ( 2 ) w ( 1 ) = ( 2 * h1 ** 2 + h1 * h2 - h2 ** 2 ) / ( 6 * h1 ) w ( 2 ) = ( h1 + h2 ) ** 3 / ( 6 * h1 * h2 ) w ( 3 ) = ( 2 * h2 ** 2 + h1 * h2 - h1 ** 2 ) / ( 6 * h2 ) case ( 4 ) w = simps38_weights ( x ) case default if ( mod ( n , 2 ) == 1 ) then w = 0.0 _${ k1 }$ do i = 1 , n - 2 , 2 h1 = x ( i + 1 ) - x ( i ) h2 = x ( i + 2 ) - x ( i + 1 ) w ( i ) = w ( i ) + ( 2 * h1 ** 2 + h1 * h2 - h2 ** 2 ) / ( 6 * h1 ) w ( i + 1 ) = w ( i + 1 ) + ( h1 + h2 ) ** 3 / ( 6 * h1 * h2 ) w ( i + 2 ) = w ( i + 2 ) + ( 2 * h2 ** 2 + h1 * h2 - h1 ** 2 ) / ( 6 * h2 ) end do else if ( present ( even )) then if ( even < 0 ) then ! 3/8 rule on left w = 0.0 _${ k1 }$ w ( 1 : 4 ) = simps38_weights ( x ( 1 : 4 )) w ( 4 : n ) = w ( 4 : n ) + simps_weights ( x ( 4 : n )) ! position 4 needs both rules return else if ( even > 0 ) then ! 3/8 rule on right w = 0.0 _${ k1 }$ w ( 1 : n - 3 ) = simps_weights ( x ( 1 : n - 3 )) w ( n - 3 : n ) = w ( n - 3 : n ) + simps38_weights ( x ( n - 3 : n )) ! position n-3 needs both rules return else ! fall through end if end if ! either `even` not present or is zero w = 0.0 _${ k1 }$ ! 3/8 rule on left w ( 1 : 4 ) = simps38_weights ( x ( 1 : 4 )) w ( 4 : n ) = w ( 4 : n ) + simps_weights ( x ( 4 : n )) ! 3/8 rule on right w ( 1 : n - 3 ) = w ( 1 : n - 3 ) + simps_weights ( x ( 1 : n - 3 )) w ( n - 3 : n ) = w ( n - 3 : n ) + simps38_weights ( x ( n - 3 : n )) ! average w = 0.5 _${ k1 }$ * w end if end select end function simps_weights_$ { k1 }$ #:endfor #:for k1, t1 in REAL_KINDS_TYPES pure function simps38_dx_$ { k1 }$ ( y , dx ) result ( integral ) ${ t1 }$ , dimension ( 4 ), intent ( in ) :: y ${ t1 }$ , intent ( in ) :: dx ${ t1 }$ :: integral integral = 3.0 _${ k1 }$ * dx / 8.0 _${ k1 }$ * ( y ( 1 ) + y ( 4 ) + 3 * ( y ( 2 ) + y ( 3 ))) end function simps38_dx_$ { k1 }$ #:endfor #: for k1, t1 in REAL_KINDS_TYPES pure function simps38_x_$ { k1 }$ ( y , x ) result ( integral ) ${ t1 }$ , dimension ( 4 ), intent ( in ) :: y ${ t1 }$ , dimension ( 4 ), intent ( in ) :: x ${ t1 }$ :: integral ${ t1 }$ :: h1 , h2 , h3 ${ t1 }$ :: a , b , c , d h1 = x ( 2 ) - x ( 1 ) h2 = x ( 3 ) - x ( 2 ) h3 = x ( 4 ) - x ( 3 ) a = ( h1 + h2 + h3 ) * ( 3 * h1 ** 2 + 2 * h1 * h2 - 2 * h1 * h3 - h2 ** 2 + h3 ** 2 ) / ( 12 * h1 * ( h1 + h2 )) b = ( h1 + h2 - h3 ) * ( h1 + h2 + h3 ) ** 3 / ( 12 * h1 * h2 * ( h2 + h3 )) c = ( h2 + h3 - h1 ) * ( h1 + h2 + h3 ) ** 3 / ( 12 * h2 * h3 * ( h1 + h2 )) d = ( h1 + h2 + h3 ) * ( 3 * h3 ** 2 + 2 * h2 * h3 - 2 * h1 * h3 - h2 ** 2 + h1 ** 2 ) / ( 12 * h3 * ( h2 + h3 )) integral = a * y ( 1 ) + b * y ( 2 ) + c * y ( 3 ) + d * y ( 4 ) end function simps38_x_$ { k1 }$ #:endfor #:for k1, t1 in REAL_KINDS_TYPES pure function simps38_weights_$ { k1 }$ ( x ) result ( w ) ${ t1 }$ , intent ( in ) :: x ( 4 ) ${ t1 }$ :: w ( size ( x )) ${ t1 }$ :: h1 , h2 , h3 h1 = x ( 2 ) - x ( 1 ) h2 = x ( 3 ) - x ( 2 ) h3 = x ( 4 ) - x ( 3 ) w ( 1 ) = ( h1 + h2 + h3 ) * ( 3 * h1 ** 2 + 2 * h1 * h2 - 2 * h1 * h3 - h2 ** 2 + h3 ** 2 ) / ( 12 * h1 * ( h1 + h2 )) w ( 2 ) = ( h1 + h2 - h3 ) * ( h1 + h2 + h3 ) ** 3 / ( 12 * h1 * h2 * ( h2 + h3 )) w ( 3 ) = ( h2 + h3 - h1 ) * ( h1 + h2 + h3 ) ** 3 / ( 12 * h2 * h3 * ( h1 + h2 )) w ( 4 ) = ( h1 + h2 + h3 ) * ( 3 * h3 ** 2 + 2 * h2 * h3 - 2 * h1 * h3 - h2 ** 2 + h1 ** 2 ) / ( 12 * h3 * ( h2 + h3 )) end function simps38_weights_$ { k1 }$ #:endfor end submodule stdlib_quadrature_simps","tags":"","loc":"sourcefile/stdlib_quadrature_simps.fypp.html"},{"title":"stdlib_error.f90 – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_error.f90~~EfferentGraph sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_error.f90~~AfferentGraph sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_io.fypp stdlib_io.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_quadrature_simps.fypp stdlib_quadrature_simps.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_cov.fypp stdlib_stats_cov.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_quadrature_trapz.fypp stdlib_quadrature_trapz.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_var.fypp stdlib_stats_var.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_moment.fypp stdlib_stats_moment.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_error.f90 sourcefile~f18estop.f90 f18estop.f90 sourcefile~f18estop.f90->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_mean.fypp stdlib_stats_mean.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_error.f90 sourcefile~f08estop.f90 f08estop.f90 sourcefile~f08estop.f90->sourcefile~stdlib_error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_error Source Code stdlib_error.f90 Source Code module stdlib_error !! Provides support for catching and handling errors !! ([Specification](../page/specs/stdlib_error.html)) use , intrinsic :: iso_fortran_env , only : stderr => error_unit use stdlib_optval , only : optval implicit none private interface ! f{08,18}estop.f90 module subroutine error_stop ( msg , code ) !! version: experimental !! !! Provides a call to `error stop` and allows the user to specify a code and message !! ([Specification](..//page/specs/stdlib_error.html#description_1)) character ( * ), intent ( in ) :: msg integer , intent ( in ), optional :: code end subroutine error_stop end interface public :: check , error_stop contains subroutine check ( condition , msg , code , warn ) !! version: experimental !! !! Checks the value of a logical condition !! ([Specification](../page/specs/stdlib_error.html#description)) !! !!##### Behavior !! !! If `condition == .false.` and: !! !!   * No other arguments are provided, it stops the program with the default !!     message and exit code `1`; !!   * `msg` is provided, it prints the value of `msg`; !!   * `code` is provided, it stops the program with the given exit code; !!   * `warn` is provided and `.true.`, it doesn't stop the program and prints !!     the message. !! !!##### Examples !! !!* If `a /= 5`, stops the program with exit code `1` !!  and prints `Check failed.` !!``` fortran !!  call check(a == 5) !!``` !! !!* As above, but prints `a == 5 failed`. !!``` fortran !!  call check(a == 5, msg='a == 5 failed.') !!``` !! !!* As above, but doesn't stop the program. !!``` fortran !!  call check(a == 5, msg='a == 5 failed.', warn=.true.) !!``` !! !!* As example #2, but stops the program with exit code `77` !!``` fortran !!  call check(a == 5, msg='a == 5 failed.', code=77) !!``` ! ! Arguments ! --------- logical , intent ( in ) :: condition character ( * ), intent ( in ), optional :: msg integer , intent ( in ), optional :: code logical , intent ( in ), optional :: warn character ( * ), parameter :: msg_default = 'Check failed.' if (. not . condition ) then if ( optval ( warn , . false .)) then write ( stderr , * ) optval ( msg , msg_default ) else call error_stop ( optval ( msg , msg_default ), optval ( code , 1 )) end if end if end subroutine check end module stdlib_error","tags":"","loc":"sourcefile/stdlib_error.f90.html"},{"title":"stdlib_linalg_diag.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_linalg_diag.fypp~~EfferentGraph sourcefile~stdlib_linalg_diag.fypp stdlib_linalg_diag.fypp sourcefile~stdlib_linalg.fypp stdlib_linalg.fypp sourcefile~stdlib_linalg_diag.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_linalg.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_linalg_diag Source Code stdlib_linalg_diag.fypp Source Code #:include \"common.fypp\" #:set RCI_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES + INT_KINDS_TYPES submodule ( stdlib_linalg ) stdlib_linalg_diag implicit none contains # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$ ( v ) result ( res ) ${ t1 }$ , intent ( in ) :: v (:) ${ t1 }$ :: res ( size ( v ), size ( v )) integer :: i res = 0 do i = 1 , size ( v ) res ( i , i ) = v ( i ) end do end function diag_$ { t1 [ 0 ] }{ k1 }$ # : endfor # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ k ( v , k ) result ( res ) ${ t1 }$ , intent ( in ) :: v (:) integer , intent ( in ) :: k ${ t1 }$ :: res ( size ( v ) + abs ( k ), size ( v ) + abs ( k )) integer :: i , sz sz = size ( v ) res = 0 if ( k > 0 ) then do i = 1 , sz res ( i , k + i ) = v ( i ) end do else if ( k < 0 ) then do i = 1 , sz res ( i + abs ( k ), i ) = v ( i ) end do else do i = 1 , sz res ( i , i ) = v ( i ) end do end if end function diag_$ { t1 [ 0 ] }{ k1 }$_ k # : endfor # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ mat ( A ) result ( res ) ${ t1 }$ , intent ( in ) :: A (:,:) ${ t1 }$ :: res ( minval ( shape ( A ))) integer :: i do i = 1 , minval ( shape ( A )) res ( i ) = A ( i , i ) end do end function diag_$ { t1 [ 0 ] }{ k1 }$_ mat # : endfor # : for k1 , t1 in RCI_KINDS_TYPES module function diag_$ { t1 [ 0 ] }{ k1 }$_ mat_k ( A , k ) result ( res ) ${ t1 }$ , intent ( in ) :: A (:,:) integer , intent ( in ) :: k ${ t1 }$ :: res ( minval ( shape ( A )) - abs ( k )) integer :: i , sz sz = minval ( shape ( A )) - abs ( k ) if ( k > 0 ) then do i = 1 , sz res ( i ) = A ( i , k + i ) end do else if ( k < 0 ) then do i = 1 , sz res ( i ) = A ( i + abs ( k ), i ) end do else do i = 1 , sz res ( i ) = A ( i , i ) end do end if end function diag_$ { t1 [ 0 ] }{ k1 }$_ mat_k # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_linalg_diag.fypp.html"},{"title":"stdlib_quadrature.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_quadrature.fypp~~EfferentGraph sourcefile~stdlib_quadrature.fypp stdlib_quadrature.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_quadrature.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~stdlib_quadrature.fypp~~AfferentGraph sourcefile~stdlib_quadrature.fypp stdlib_quadrature.fypp sourcefile~stdlib_quadrature_simps.fypp stdlib_quadrature_simps.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_quadrature_trapz.fypp stdlib_quadrature_trapz.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_quadrature.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_quadrature Source Code stdlib_quadrature.fypp Source Code #:include \"common.fypp\" module stdlib_quadrature !! ([Specification](../page/specs/stdlib_quadrature.html#description)) use stdlib_kinds , only : sp , dp , qp implicit none private ! array integration public :: trapz public :: trapz_weights public :: simps public :: simps_weights interface trapz !! version: experimental !! !! Integrates sampled values using trapezoidal rule !! ([Specification](../page/specs/stdlib_quadrature.html#description)) # : for k1 , t1 in REAL_KINDS_TYPES pure module function trapz_dx_$ { k1 }$ ( y , dx ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , intent ( in ) :: dx ${ t1 }$ :: integral end function trapz_dx_$ { k1 }$ # : endfor # : for k1 , t1 in REAL_KINDS_TYPES module function trapz_x_$ { k1 }$ ( y , x ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , dimension (:), intent ( in ) :: x ${ t1 }$ :: integral end function trapz_x_$ { k1 }$ # : endfor end interface trapz interface trapz_weights !! version: experimental !! !! Integrates sampled values using trapezoidal rule weights for given abscissas !! ([Specification](../page/specs/stdlib_quadrature.html#description_1)) # : for k1 , t1 in REAL_KINDS_TYPES pure module function trapz_weights_$ { k1 }$ ( x ) result ( w ) ${ t1 }$ , dimension (:), intent ( in ) :: x ${ t1 }$ , dimension ( size ( x )) :: w end function trapz_weights_$ { k1 }$ # : endfor end interface trapz_weights interface simps !! version: experimental !! !! Integrates sampled values using Simpson's rule !! ([Specification](../page/specs/stdlib_quadrature.html#description_3)) ! \"recursive\" is an implementation detail # : for k1 , t1 in REAL_KINDS_TYPES pure recursive module function simps_dx_$ { k1 }$ ( y , dx , even ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , intent ( in ) :: dx integer , intent ( in ), optional :: even ${ t1 }$ :: integral end function simps_dx_$ { k1 }$ # : endfor # : for k1 , t1 in REAL_KINDS_TYPES recursive module function simps_x_$ { k1 }$ ( y , x , even ) result ( integral ) ${ t1 }$ , dimension (:), intent ( in ) :: y ${ t1 }$ , dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: even ${ t1 }$ :: integral end function simps_x_$ { k1 }$ # : endfor end interface simps interface simps_weights !! version: experimental !! !! Integrates sampled values using trapezoidal rule weights for given abscissas !! ([Specification](../page/specs/stdlib_quadrature.html#description_3)) # : for k1 , t1 in REAL_KINDS_TYPES pure recursive module function simps_weights_$ { k1 }$ ( x , even ) result ( w ) ${ t1 }$ , dimension (:), intent ( in ) :: x integer , intent ( in ), optional :: even ${ t1 }$ , dimension ( size ( x )) :: w end function simps_weights_$ { k1 }$ # : endfor end interface simps_weights ! Interface for a simple f(x)-style integrand function. ! Could become fancier as we learn about the performance ! ramifications of different ways to do callbacks. abstract interface # : for k1 , t1 in REAL_KINDS_TYPES pure function integrand_$ { k1 }$ ( x ) result ( f ) import :: ${ k1 }$ ${ t1 }$ , intent ( in ) :: x ${ t1 }$ :: f end function integrand_$ { k1 }$ # : endfor end interface end module stdlib_quadrature","tags":"","loc":"sourcefile/stdlib_quadrature.fypp.html"},{"title":"stdlib_stats_mean.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_mean.fypp~~EfferentGraph sourcefile~stdlib_stats_mean.fypp stdlib_stats_mean.fypp sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_mean Source Code stdlib_stats_mean.fypp Source Code #:include \"common.fypp\" #:set RANKS = range(1, MAXRANK + 1) #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_mean use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask ${ t1 }$ :: res if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if res = sum ( x ) / real ( size ( x , kind = int64 ), ${ k1 }$ ) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_all' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask real ( dp ) :: res if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if res = sum ( real ( x , dp )) / real ( size ( x , kind = int64 ), dp ) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum ( x , dim ) / real ( size ( x , dim ), ${ k1 }$ ) else call error_stop ( \"ERROR (mean): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"mean\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum ( real ( x , dp ), dim ) / real ( size ( x , dim ), dp ) else call error_stop ( \"ERROR (mean): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask_all' , rank , t1 , k1 ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res res = sum ( x , mask ) / real ( count ( mask , kind = int64 ), ${ k1 }$ ) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask_all' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res res = sum ( real ( x , dp ), mask ) / real ( count ( mask , kind = int64 ), dp ) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask' , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ ${ t1 }$ :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum ( x , dim , mask ) / real ( count ( mask , dim ), ${ k1 }$ ) else call error_stop ( \"ERROR (mean): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( 'mean_mask' , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if ( dim >= 1 . and . dim <= ${ rank }$ ) then res = sum ( real ( x , dp ), dim , mask ) / real ( count ( mask , dim ), dp ) else call error_stop ( \"ERROR (mean): wrong dimension\" ) end if end function ${ RName }$ # : endfor # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_mean.fypp.html"},{"title":"stdlib_kinds.f90 – Fortran-lang/stdlib","text":"Files dependent on this one sourcefile~~stdlib_kinds.f90~~AfferentGraph sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_io.fypp stdlib_io.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_io.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_quadrature.fypp stdlib_quadrature.fypp sourcefile~stdlib_quadrature.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_linalg.fypp stdlib_linalg.fypp sourcefile~stdlib_linalg.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_stats_corr.fypp stdlib_stats_corr.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_stats_corr.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_linalg_diag.fypp stdlib_linalg_diag.fypp sourcefile~stdlib_linalg_diag.fypp->sourcefile~stdlib_linalg.fypp sourcefile~stdlib_quadrature_simps.fypp stdlib_quadrature_simps.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_quadrature_simps.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_cov.fypp stdlib_stats_cov.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_cov.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_quadrature_trapz.fypp stdlib_quadrature_trapz.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_var.fypp stdlib_stats_var.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_moment.fypp stdlib_stats_moment.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_moment.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_stats_mean.fypp stdlib_stats_mean.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats_mean.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~f18estop.f90 f18estop.f90 sourcefile~f18estop.f90->sourcefile~stdlib_error.f90 sourcefile~f08estop.f90 f08estop.f90 sourcefile~f08estop.f90->sourcefile~stdlib_error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_kinds Source Code stdlib_kinds.f90 Source Code module stdlib_kinds !! version: experimental use iso_fortran_env , only : sp => real32 , dp => real64 , qp => real128 use iso_fortran_env , only : int8 , int16 , int32 , int64 ! If we decide later to use iso_c_binding instead of iso_fortran_env: !use iso_c_binding, only: sp=>c_float, dp=>c_double, qp=>c_float128 !use iso_c_binding, only: int8=>c_int8_t, int16=>c_int16_t, int32=>c_int32_t, int64=>c_int64_t implicit none private public sp , dp , qp , int8 , int16 , int32 , int64 end module stdlib_kinds","tags":"","loc":"sourcefile/stdlib_kinds.f90.html"},{"title":"stdlib_ascii.f90 – Fortran-lang/stdlib","text":"Files dependent on this one sourcefile~~stdlib_ascii.f90~~AfferentGraph sourcefile~stdlib_ascii.f90 stdlib_ascii.f90 sourcefile~stdlib_io.fypp stdlib_io.fypp sourcefile~stdlib_io.fypp->sourcefile~stdlib_ascii.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules stdlib_ascii Source Code stdlib_ascii.f90 Source Code module stdlib_ascii implicit none private ! Character validation functions public :: is_alpha , is_alphanum public :: is_digit , is_hex_digit , is_octal_digit public :: is_control , is_white , is_blank public :: is_ascii , is_punctuation public :: is_graphical , is_printable public :: is_lower , is_upper ! Character conversion functions public :: to_lower , to_upper ! All control characters in the ASCII table (see www.asciitable.com). character ( len = 1 ), public , parameter :: NUL = achar ( int ( z '00' )) !! Null character ( len = 1 ), public , parameter :: SOH = achar ( int ( z '01' )) !! Start of heading character ( len = 1 ), public , parameter :: STX = achar ( int ( z '02' )) !! Start of text character ( len = 1 ), public , parameter :: ETX = achar ( int ( z '03' )) !! End of text character ( len = 1 ), public , parameter :: EOT = achar ( int ( z '04' )) !! End of transmission character ( len = 1 ), public , parameter :: ENQ = achar ( int ( z '05' )) !! Enquiry character ( len = 1 ), public , parameter :: ACK = achar ( int ( z '06' )) !! Acknowledge character ( len = 1 ), public , parameter :: BEL = achar ( int ( z '07' )) !! Bell character ( len = 1 ), public , parameter :: BS = achar ( int ( z '08' )) !! Backspace character ( len = 1 ), public , parameter :: TAB = achar ( int ( z '09' )) !! Horizontal tab character ( len = 1 ), public , parameter :: LF = achar ( int ( z '0A' )) !! NL line feed, new line character ( len = 1 ), public , parameter :: VT = achar ( int ( z '0B' )) !! Vertical tab character ( len = 1 ), public , parameter :: FF = achar ( int ( z '0C' )) !! NP form feed, new page character ( len = 1 ), public , parameter :: CR = achar ( int ( z '0D' )) !! Carriage return character ( len = 1 ), public , parameter :: SO = achar ( int ( z '0E' )) !! Shift out character ( len = 1 ), public , parameter :: SI = achar ( int ( z '0F' )) !! Shift in character ( len = 1 ), public , parameter :: DLE = achar ( int ( z '10' )) !! Data link escape character ( len = 1 ), public , parameter :: DC1 = achar ( int ( z '11' )) !! Device control 1 character ( len = 1 ), public , parameter :: DC2 = achar ( int ( z '12' )) !! Device control 2 character ( len = 1 ), public , parameter :: DC3 = achar ( int ( z '13' )) !! Device control 3 character ( len = 1 ), public , parameter :: DC4 = achar ( int ( z '14' )) !! Device control 4 character ( len = 1 ), public , parameter :: NAK = achar ( int ( z '15' )) !! Negative acknowledge character ( len = 1 ), public , parameter :: SYN = achar ( int ( z '16' )) !! Synchronous idle character ( len = 1 ), public , parameter :: ETB = achar ( int ( z '17' )) !! End of transmission block character ( len = 1 ), public , parameter :: CAN = achar ( int ( z '18' )) !! Cancel character ( len = 1 ), public , parameter :: EM = achar ( int ( z '19' )) !! End of medium character ( len = 1 ), public , parameter :: SUB = achar ( int ( z '1A' )) !! Substitute character ( len = 1 ), public , parameter :: ESC = achar ( int ( z '1B' )) !! Escape character ( len = 1 ), public , parameter :: FS = achar ( int ( z '1C' )) !! File separator character ( len = 1 ), public , parameter :: GS = achar ( int ( z '1D' )) !! Group separator character ( len = 1 ), public , parameter :: RS = achar ( int ( z '1E' )) !! Record separator character ( len = 1 ), public , parameter :: US = achar ( int ( z '1F' )) !! Unit separator character ( len = 1 ), public , parameter :: DEL = achar ( int ( z '7F' )) !! Delete ! Constant character sequences character ( len =* ), public , parameter :: fullhex_digits = \"0123456789ABCDEFabcdef\" !! 0 .. 9A .. Fa .. f character ( len =* ), public , parameter :: hex_digits = fullhex_digits ( 1 : 16 ) !! 0 .. 9A .. F character ( len =* ), public , parameter :: lowerhex_digits = \"0123456789abcdef\" !! 0 .. 9a .. f character ( len =* ), public , parameter :: digits = hex_digits ( 1 : 10 ) !! 0 .. 9 character ( len =* ), public , parameter :: octal_digits = digits ( 1 : 8 ) !! 0 .. 7 character ( len =* ), public , parameter :: letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" !! A .. Za .. z character ( len =* ), public , parameter :: uppercase = letters ( 1 : 26 ) !! A .. Z character ( len =* ), public , parameter :: lowercase = letters ( 27 :) !! a .. z character ( len =* ), public , parameter :: whitespace = \" \" // TAB // VT // CR // LF // FF !! ASCII _whitespace contains !> Checks whether `c` is an ASCII letter (A .. Z, a .. z). pure logical function is_alpha ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_alpha = ( c >= 'A' . and . c <= 'Z' ) . or . ( c >= 'a' . and . c <= 'z' ) end function !> Checks whether `c` is a letter or a number (0 .. 9, a .. z, A .. Z). pure logical function is_alphanum ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_alphanum = ( c >= '0' . and . c <= '9' ) . or . ( c >= 'a' . and . c <= 'z' ) & . or . ( c >= 'A' . and . c <= 'Z' ) end function !> Checks whether or not `c` is in the ASCII character set - !  i.e. in the range 0 .. 0x7F. pure logical function is_ascii ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_ascii = iachar ( c ) <= int ( z '7F' ) end function !> Checks whether `c` is a control character. pure logical function is_control ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) is_control = ic < int ( z '20' ) . or . ic == int ( z '7F' ) end function !> Checks whether `c` is a digit (0 .. 9). pure logical function is_digit ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_digit = ( '0' <= c ) . and . ( c <= '9' ) end function !> Checks whether `c` is a digit in base 8 (0 .. 7). pure logical function is_octal_digit ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_octal_digit = ( c >= '0' ) . and . ( c <= '7' ); end function !> Checks whether `c` is a digit in base 16 (0 .. 9, A .. F, a .. f). pure logical function is_hex_digit ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_hex_digit = ( c >= '0' . and . c <= '9' ) . or . ( c >= 'a' . and . c <= 'f' ) & . or . ( c >= 'A' . and . c <= 'F' ) end function !> Checks whether or not `c` is a punctuation character. That includes !  all ASCII characters which are not control characters, letters, !  digits, or whitespace. pure logical function is_punctuation ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) !       '~'                 '!' is_punctuation = ( ic <= int ( z '7E' )) . and . ( ic >= int ( z '21' )) . and . & (. not . is_alphanum ( c )) end function !> Checks whether or not `c` is a printable character other than the !  space character. pure logical function is_graphical ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) !  '!'                     '~' is_graphical = ( int ( z '21' ) <= ic ) . and . ( ic <= int ( z '7E' )) end function !> Checks whether or not `c` is a printable character - including the !  space character. pure logical function is_printable ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) ! '~' is_printable = c >= ' ' . and . ic <= int ( z '7E' ) end function !> Checks whether `c` is a lowercase ASCII letter (a .. z). pure logical function is_lower ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_lower = ( c >= 'a' ) . and . ( c <= 'z' ) end function !> Checks whether `c` is an uppercase ASCII letter (A .. Z). pure logical function is_upper ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_upper = ( c >= 'A' ) . and . ( c <= 'Z' ) end function !> Checks whether or not `c` is a whitespace character. That includes the !  space, tab, vertical tab, form feed, carriage return, and linefeed !  characters. pure logical function is_white ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) ! TAB, LF, VT, FF, CR is_white = ( c == ' ' ) . or . ( ic >= int ( z '09' ) . and . ic <= int ( z '0D' )); end function !> Checks whether or not `c` is a blank character. That includes the !  only the space and tab characters pure logical function is_blank ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) ! TAB is_blank = ( c == ' ' ) . or . ( ic == int ( z '09' )); end function !> Returns the corresponding lowercase letter, if `c` is an uppercase !  ASCII character, otherwise `c` itself. pure function to_lower ( c ) result ( t ) character ( len = 1 ), intent ( in ) :: c !! A character. character ( len = 1 ) :: t integer :: diff diff = iachar ( 'A' ) - iachar ( 'a' ) t = c ! if uppercase, make lowercase if ( is_upper ( t )) t = achar ( iachar ( t ) - diff ) end function !> Returns the corresponding uppercase letter, if `c` is a lowercase !  ASCII character, otherwise `c` itself. pure function to_upper ( c ) result ( t ) character ( len = 1 ), intent ( in ) :: c !! A character. character ( len = 1 ) :: t integer :: diff diff = iachar ( 'A' ) - iachar ( 'a' ) t = c ! if lowercase, make uppercase if ( is_lower ( t )) t = achar ( iachar ( t ) + diff ) end function end module","tags":"","loc":"sourcefile/stdlib_ascii.f90.html"},{"title":"f08estop.f90 – Fortran-lang/stdlib","text":"This file depends on sourcefile~~f08estop.f90~~EfferentGraph sourcefile~f08estop.f90 f08estop.f90 sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~f08estop.f90->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules estop Source Code f08estop.f90 Source Code submodule ( stdlib_error ) estop implicit none contains module procedure error_stop ! Aborts the program with nonzero exit code ! this is a fallback for Fortran 2008 error stop (e.g. Intel 19.1/2020 compiler) ! ! The \"stop <character>\" statement generally has return code 0. ! To allow non-zero return code termination with character message, ! error_stop() uses the statement \"error stop\", which by default ! has exit code 1 and prints the message to stderr. ! An optional integer return code \"code\" may be specified. ! ! Example ! ------- ! ! call error_stop(\"Invalid argument\") write ( stderr , * ) msg if ( present ( code )) then select case ( code ) case ( 1 ) error stop 1 case ( 2 ) error stop 2 case ( 77 ) error stop 77 case default write ( stderr , * ) 'ERROR: code ' , code , ' was specified.' error stop end select else error stop endif end procedure end submodule","tags":"","loc":"sourcefile/f08estop.f90.html"},{"title":"stdlib_quadrature_trapz.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_quadrature_trapz.fypp~~EfferentGraph sourcefile~stdlib_quadrature_trapz.fypp stdlib_quadrature_trapz.fypp sourcefile~stdlib_quadrature.fypp stdlib_quadrature.fypp sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_quadrature.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_quadrature_trapz.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_quadrature.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_quadrature_trapz Source Code stdlib_quadrature_trapz.fypp Source Code #:include \"common.fypp\" submodule ( stdlib_quadrature ) stdlib_quadrature_trapz use stdlib_error , only : check implicit none contains # : for KIND in REAL_KINDS pure module function trapz_dx_$ { KIND }$ ( y , dx ) result ( integral ) real ( ${ KIND }$ ), dimension (:), intent ( in ) :: y real ( ${ KIND }$ ), intent ( in ) :: dx real ( ${ KIND }$ ) :: integral integer :: n n = size ( y ) select case ( n ) case ( 0 : 1 ) integral = 0.0 _${ KIND }$ case ( 2 ) integral = 0.5 _${ KIND }$ * dx * ( y ( 1 ) + y ( 2 )) case default integral = dx * ( sum ( y ( 2 : n - 1 )) + 0.5 _${ KIND }$ * ( y ( 1 ) + y ( n ))) end select end function trapz_dx_$ { KIND }$ # : endfor # : for KIND in REAL_KINDS module function trapz_x_$ { KIND }$ ( y , x ) result ( integral ) real ( ${ KIND }$ ), dimension (:), intent ( in ) :: y real ( ${ KIND }$ ), dimension (:), intent ( in ) :: x real ( ${ KIND }$ ) :: integral integer :: i integer :: n n = size ( y ) call check ( size ( x ) == n , \"trapz: Arguments `x` and `y` must be the same size.\" ) select case ( n ) case ( 0 : 1 ) integral = 0.0 _${ KIND }$ case ( 2 ) integral = 0.5 _${ KIND }$ * ( x ( 2 ) - x ( 1 )) * ( y ( 1 ) + y ( 2 )) case default integral = 0.0 _${ KIND }$ do i = 2 , n integral = integral + ( x ( i ) - x ( i - 1 )) * ( y ( i ) + y ( i - 1 )) end do integral = 0.5 _${ KIND }$ * integral end select end function trapz_x_$ { KIND }$ # : endfor # : for KIND in REAL_KINDS pure module function trapz_weights_$ { KIND }$ ( x ) result ( w ) real ( ${ KIND }$ ), dimension (:), intent ( in ) :: x real ( ${ KIND }$ ), dimension ( size ( x )) :: w integer :: i integer :: n n = size ( x ) select case ( n ) case ( 0 ) ! no action needed case ( 1 ) w ( 1 ) = 0.0 _${ KIND }$ case ( 2 ) w = 0.5 _${ KIND }$ * ( x ( 2 ) - x ( 1 )) case default w ( 1 ) = 0.5 _${ KIND }$ * ( x ( 2 ) - x ( 1 )) w ( n ) = 0.5 _${ KIND }$ * ( x ( n ) - x ( n - 1 )) do i = 2 , size ( x ) - 1 w ( i ) = 0.5 _${ KIND }$ * ( x ( i + 1 ) - x ( i - 1 )) end do end select end function trapz_weights_$ { KIND }$ #:endfor end submodule stdlib_quadrature_trapz","tags":"","loc":"sourcefile/stdlib_quadrature_trapz.fypp.html"},{"title":"stdlib_stats_var.fypp – Fortran-lang/stdlib","text":"This file depends on sourcefile~~stdlib_stats_var.fypp~~EfferentGraph sourcefile~stdlib_stats_var.fypp stdlib_stats_var.fypp sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_optval.fypp sourcefile~stdlib_stats.fypp stdlib_stats.fypp sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_stats.fypp sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~stdlib_stats_var.fypp->sourcefile~stdlib_error.f90 sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_stats.fypp->sourcefile~stdlib_kinds.f90 sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules stdlib_stats_var Source Code stdlib_stats_var.fypp Source Code #:include \"common.fypp\" #:set RANKS = range(1, MAXRANK + 1) #:set RC_KINDS_TYPES = REAL_KINDS_TYPES + CMPLX_KINDS_TYPES submodule ( stdlib_stats ) stdlib_stats_var use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan use stdlib_error , only : error_stop use stdlib_optval , only : optval implicit none contains # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res real ( ${ k1 }$ ) :: n ${ t1 }$ :: mean if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if n = size ( x , kind = int64 ) mean = sum ( x ) / n # : if t1 [ 0 ] == 'r' res = sum (( x - mean ) ** 2 ) / ( n - merge ( 1 , 0 , optval ( corrected , . true .))) # : else res = sum ( abs ( x - mean ) ** 2 ) / ( n - merge ( 1 , 0 , optval ( corrected , . true .))) # : endif end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res real ( dp ) :: n , mean if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if n = size ( x , kind = int64 ) mean = sum ( real ( x , dp )) / n res = sum (( real ( x , dp ) - mean ) ** 2 ) / ( n - merge ( 1 , 0 , optval ( corrected , . true .))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( ${ k1 }$ ) :: n ${ t1 }$ :: mean$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1. _${ k1 }$ , ieee_quiet_nan ) return end if res = 0. _${ k1 }$ select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) n = size ( x , dim ) mean = sum ( x , dim ) / n do i = 1 , size ( x , dim ) # : if t1 [ 0 ] == 'r' res = res + ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean ) ** 2 # : else res = res + abs ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean ) ** 2 # : endif end do # : endfor case default call error_stop ( \"ERROR (var): wrong dimension\" ) end select res = res / ( n - merge ( 1 , 0 , optval ( corrected , . true .))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ), optional :: mask logical , intent ( in ), optional :: corrected real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( dp ) :: n real ( dp ) :: mean$ { reduced_shape ( 'x' , rank , 'dim' ) }$ if (. not . optval ( mask , . true .)) then res = ieee_value ( 1._dp , ieee_quiet_nan ) return end if res = 0._dp select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) n = size ( x , dim ) mean = sum ( real ( x , dp ), dim ) / n do i = 1 , size ( x , dim ) res = res + ( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - mean ) ** 2 end do # : endfor case default call error_stop ( \"ERROR (var): wrong dimension\" ) end select res = res / ( n - merge ( 1 , 0 , optval ( corrected , . true .))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask_all\" , rank , t1 , k1 ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res real ( ${ k1 }$ ) :: n ${ t1 }$ :: mean n = count ( mask , kind = int64 ) mean = sum ( x , mask ) / n # : if t1 [ 0 ] == 'r' res = sum (( x - mean ) ** 2 , mask ) / ( n - & # : else res = sum ( abs ( x - mean ) ** 2 , mask ) / ( n - & # : endif merge ( 1 , 0 , ( optval ( corrected , . true .) . and . n > 0 ))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask_all\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( dp ) :: res real ( dp ) :: n , mean n = count ( mask , kind = int64 ) mean = sum ( real ( x , dp ), mask ) / n res = sum (( real ( x , dp ) - mean ) ** 2 , mask ) / ( n - & merge ( 1 , 0 , ( optval ( corrected , . true .) . and . n > 0 ))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in RC_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask\" , rank , t1 , k1 ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( ${ k1 }$ ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( ${ k1 }$ ) :: n$ { reduced_shape ( 'x' , rank , 'dim' ) }$ ${ t1 }$ :: mean$ { reduced_shape ( 'x' , rank , 'dim' ) }$ res = 0. _${ k1 }$ select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) n = count ( mask , dim ) mean = sum ( x , dim , mask ) / n do i = 1 , size ( x , dim ) # : if t1 [ 0 ] == 'r' res = res + merge ( ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean ) ** 2 ,& # : else res = res + merge ( abs ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ - mean ) ** 2 ,& # : endif 0. _${ k1 }$ ,& mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do # : endfor case default call error_stop ( \"ERROR (var): wrong dimension\" ) end select res = res / ( n - merge ( 1 , 0 , ( optval ( corrected , . true .) . and . n > 0 ))) end function ${ RName }$ # : endfor # : endfor # : for k1 , t1 in INT_KINDS_TYPES # : for rank in RANKS # : set RName = rname ( \"var_mask\" , rank , t1 , k1 , 'dp' ) module function ${ RName }$ ( x , dim , mask , corrected ) result ( res ) ${ t1 }$ , intent ( in ) :: x$ { ranksuffix ( rank ) }$ integer , intent ( in ) :: dim logical , intent ( in ) :: mask$ { ranksuffix ( rank ) }$ logical , intent ( in ), optional :: corrected real ( dp ) :: res$ { reduced_shape ( 'x' , rank , 'dim' ) }$ integer :: i real ( dp ) :: n$ { reduced_shape ( 'x' , rank , 'dim' ) }$ real ( dp ) :: mean$ { reduced_shape ( 'x' , rank , 'dim' ) }$ res = 0._dp select case ( dim ) # : for fi in range ( 1 , rank + 1 ) case ( ${ fi }$ ) n = count ( mask , dim ) mean = sum ( real ( x , dp ), dim , mask ) / n do i = 1 , size ( x , dim ) res = res + merge (( real ( x$ { select_subarray ( rank , [( fi , 'i' )]) }$ , dp ) - mean ) ** 2 ,& 0._dp , mask$ { select_subarray ( rank , [( fi , 'i' )]) }$ ) end do # : endfor case default call error_stop ( \"ERROR (var): wrong dimension\" ) end select res = res / ( n - merge ( 1 , 0 , ( optval ( corrected , . true .) . and . n > 0 ))) end function ${ RName }$ # : endfor # : endfor end submodule","tags":"","loc":"sourcefile/stdlib_stats_var.fypp.html"},{"title":"f18estop.f90 – Fortran-lang/stdlib","text":"This file depends on sourcefile~~f18estop.f90~~EfferentGraph sourcefile~f18estop.f90 f18estop.f90 sourcefile~stdlib_error.f90 stdlib_error.f90 sourcefile~f18estop.f90->sourcefile~stdlib_error.f90 sourcefile~stdlib_optval.fypp stdlib_optval.fypp sourcefile~stdlib_error.f90->sourcefile~stdlib_optval.fypp sourcefile~stdlib_kinds.f90 stdlib_kinds.f90 sourcefile~stdlib_optval.fypp->sourcefile~stdlib_kinds.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Submodules estop Source Code f18estop.f90 Source Code submodule ( stdlib_error ) estop implicit none contains module procedure error_stop ! Aborts the program with nonzero exit code ! ! The \"stop <character>\" statement generally has return code 0. ! To allow non-zero return code termination with character message, ! error_stop() uses the statement \"error stop\", which by default ! has exit code 1 and prints the message to stderr. ! An optional integer return code \"code\" may be specified. ! ! Example ! ------- ! ! call error_stop(\"Invalid argument\") if ( present ( code )) then write ( stderr , * ) msg error stop code else error stop msg endif end procedure end submodule estop","tags":"","loc":"sourcefile/f18estop.f90.html"},{"title":"eye – Fortran-lang/stdlib","text":"public function eye(n) result(res) Constructs the identity matrix\n ( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer(kind=int8)\n  (n,n) Contents Variables i Source Code eye Variables Type Visibility Attributes Name Initial integer, public :: i Source Code function eye ( n ) result ( res ) !! version: experimental !! !! Constructs the identity matrix !! ([Specification](../page/specs/stdlib_linalg.html#description_1)) integer , intent ( in ) :: n integer ( int8 ) :: res ( n , n ) integer :: i res = 0 do i = 1 , n res ( i , i ) = 1 end do end function eye","tags":"","loc":"proc/eye.html"},{"title":"diag – Fortran-lang/stdlib","text":"public interface diag Creates a diagonal array or extract the diagonal elements of an array\n ( Specification ) Contents Functions diag_cdp diag_cdp_k diag_cdp_mat diag_cdp_mat_k diag_cqp diag_cqp_k diag_cqp_mat diag_cqp_mat_k diag_csp diag_csp_k diag_csp_mat diag_csp_mat_k diag_iint16 diag_iint16_k diag_iint16_mat diag_iint16_mat_k diag_iint32 diag_iint32_k diag_iint32_mat diag_iint32_mat_k diag_iint64 diag_iint64_k diag_iint64_mat diag_iint64_mat_k diag_iint8 diag_iint8_k diag_iint8_mat diag_iint8_mat_k diag_rdp diag_rdp_k diag_rdp_mat diag_rdp_mat_k diag_rqp diag_rqp_k diag_rqp_mat diag_rqp_mat_k diag_rsp diag_rsp_k diag_rsp_mat diag_rsp_mat_k Functions public function diag_cdp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: v (:) Return Value complex(kind=dp)\n  (size(v),size(v)) public function diag_cdp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=dp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_cdp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value complex(kind=dp)\n  (minval(shape(A))) public function diag_cdp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=dp)\n  (minval(shape(A))-abs(k)) public function diag_cqp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: v (:) Return Value complex(kind=qp)\n  (size(v),size(v)) public function diag_cqp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=qp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_cqp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) Return Value complex(kind=qp)\n  (minval(shape(A))) public function diag_cqp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=qp)\n  (minval(shape(A))-abs(k)) public function diag_csp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: v (:) Return Value complex(kind=sp)\n  (size(v),size(v)) public function diag_csp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=sp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_csp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value complex(kind=sp)\n  (minval(shape(A))) public function diag_csp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=sp)\n  (minval(shape(A))-abs(k)) public function diag_iint16(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: v (:) Return Value integer(kind=int16)\n  (size(v),size(v)) public function diag_iint16_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int16)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint16_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) Return Value integer(kind=int16)\n  (minval(shape(A))) public function diag_iint16_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int16)\n  (minval(shape(A))-abs(k)) public function diag_iint32(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: v (:) Return Value integer(kind=int32)\n  (size(v),size(v)) public function diag_iint32_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int32)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint32_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) Return Value integer(kind=int32)\n  (minval(shape(A))) public function diag_iint32_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int32)\n  (minval(shape(A))-abs(k)) public function diag_iint64(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: v (:) Return Value integer(kind=int64)\n  (size(v),size(v)) public function diag_iint64_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int64)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint64_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) Return Value integer(kind=int64)\n  (minval(shape(A))) public function diag_iint64_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int64)\n  (minval(shape(A))-abs(k)) public function diag_iint8(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: v (:) Return Value integer(kind=int8)\n  (size(v),size(v)) public function diag_iint8_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int8)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint8_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) Return Value integer(kind=int8)\n  (minval(shape(A))) public function diag_iint8_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int8)\n  (minval(shape(A))-abs(k)) public function diag_rdp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) Return Value real(kind=dp)\n  (size(v),size(v)) public function diag_rdp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=dp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rdp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp)\n  (minval(shape(A))) public function diag_rdp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=dp)\n  (minval(shape(A))-abs(k)) public function diag_rqp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: v (:) Return Value real(kind=qp)\n  (size(v),size(v)) public function diag_rqp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=qp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rqp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) Return Value real(kind=qp)\n  (minval(shape(A))) public function diag_rqp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=qp)\n  (minval(shape(A))-abs(k)) public function diag_rsp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: v (:) Return Value real(kind=sp)\n  (size(v),size(v)) public function diag_rsp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=sp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rsp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value real(kind=sp)\n  (minval(shape(A))) public function diag_rsp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=sp)\n  (minval(shape(A))-abs(k))","tags":"","loc":"interface/diag.html"},{"title":"trace – Fortran-lang/stdlib","text":"public interface trace Computes the trace of a matrix\n ( Specification ) Contents Module Procedures trace_rsp trace_rdp trace_rqp trace_csp trace_cdp trace_cqp trace_iint8 trace_iint16 trace_iint32 trace_iint64 Module Procedures private function trace_rsp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value real(kind=sp) private function trace_rdp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp) private function trace_rqp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) Return Value real(kind=qp) private function trace_csp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value complex(kind=sp) private function trace_cdp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value complex(kind=dp) private function trace_cqp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) Return Value complex(kind=qp) private function trace_iint8(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) Return Value integer(kind=int8) private function trace_iint16(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) Return Value integer(kind=int16) private function trace_iint32(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) Return Value integer(kind=int32) private function trace_iint64(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) Return Value integer(kind=int64)","tags":"","loc":"interface/trace.html"},{"title":"optval – Fortran-lang/stdlib","text":"public interface optval Fallback value for optional arguments\n ( Specification ) Called by interface~~optval~~CalledByGraph interface~optval optval proc~check check proc~check->interface~optval proc~open open proc~open->interface~optval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures optval_rsp optval_rdp optval_rqp optval_iint8 optval_iint16 optval_iint32 optval_iint64 optval_csp optval_cdp optval_cqp optval_ll1 optval_character Module Procedures private pure elemental function optval_rsp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), optional :: x real(kind=sp), intent(in) :: default Return Value real(kind=sp) private pure elemental function optval_rdp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional :: x real(kind=dp), intent(in) :: default Return Value real(kind=dp) private pure elemental function optval_rqp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), optional :: x real(kind=qp), intent(in) :: default Return Value real(kind=qp) private pure elemental function optval_iint8(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), optional :: x integer(kind=int8), intent(in) :: default Return Value integer(kind=int8) private pure elemental function optval_iint16(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), optional :: x integer(kind=int16), intent(in) :: default Return Value integer(kind=int16) private pure elemental function optval_iint32(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), optional :: x integer(kind=int32), intent(in) :: default Return Value integer(kind=int32) private pure elemental function optval_iint64(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), optional :: x integer(kind=int64), intent(in) :: default Return Value integer(kind=int64) private pure elemental function optval_csp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), optional :: x complex(kind=sp), intent(in) :: default Return Value complex(kind=sp) private pure elemental function optval_cdp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), optional :: x complex(kind=dp), intent(in) :: default Return Value complex(kind=dp) private pure elemental function optval_cqp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), optional :: x complex(kind=qp), intent(in) :: default Return Value complex(kind=qp) private pure elemental function optval_ll1(x, default) result(y) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: x logical, intent(in) :: default Return Value logical private pure function optval_character(x, default) result(y) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: x character(len=*), intent(in) :: default Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/optval.html"},{"title":"corr – Fortran-lang/stdlib","text":"public interface corr Pearson correlation of array elements\n ( Specification ) Contents Functions corr_1_cdp_cdp corr_1_cqp_cqp corr_1_csp_csp corr_1_iint16_dp corr_1_iint32_dp corr_1_iint64_dp corr_1_iint8_dp corr_1_rdp_rdp corr_1_rqp_rqp corr_1_rsp_rsp corr_2_cdp_cdp corr_2_cqp_cqp corr_2_csp_csp corr_2_iint16_dp corr_2_iint32_dp corr_2_iint64_dp corr_2_iint8_dp corr_2_rdp_rdp corr_2_rqp_rqp corr_2_rsp_rsp corr_mask_1_cdp_cdp corr_mask_1_cqp_cqp corr_mask_1_csp_csp corr_mask_1_iint16_dp corr_mask_1_iint32_dp corr_mask_1_iint64_dp corr_mask_1_iint8_dp corr_mask_1_rdp_rdp corr_mask_1_rqp_rqp corr_mask_1_rsp_rsp corr_mask_2_cdp_cdp corr_mask_2_cqp_cqp corr_mask_2_csp_csp corr_mask_2_iint16_dp corr_mask_2_iint32_dp corr_mask_2_iint64_dp corr_mask_2_iint8_dp corr_mask_2_rdp_rdp corr_mask_2_rqp_rqp corr_mask_2_rsp_rsp Functions public function corr_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function corr_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function corr_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function corr_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function corr_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function corr_mask_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function corr_mask_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function corr_mask_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function corr_mask_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1","tags":"","loc":"interface/corr.html"},{"title":"cov – Fortran-lang/stdlib","text":"public interface cov Covariance of array elements\n ( Specification ) Contents Functions cov_1_cdp_cdp cov_1_cqp_cqp cov_1_csp_csp cov_1_iint16_dp cov_1_iint32_dp cov_1_iint64_dp cov_1_iint8_dp cov_1_rdp_rdp cov_1_rqp_rqp cov_1_rsp_rsp cov_2_cdp_cdp cov_2_cqp_cqp cov_2_csp_csp cov_2_iint16_dp cov_2_iint32_dp cov_2_iint64_dp cov_2_iint8_dp cov_2_rdp_rdp cov_2_rqp_rqp cov_2_rsp_rsp cov_mask_1_cdp_cdp cov_mask_1_cqp_cqp cov_mask_1_csp_csp cov_mask_1_iint16_dp cov_mask_1_iint32_dp cov_mask_1_iint64_dp cov_mask_1_iint8_dp cov_mask_1_rdp_rdp cov_mask_1_rqp_rqp cov_mask_1_rsp_rsp cov_mask_2_cdp_cdp cov_mask_2_cqp_cqp cov_mask_2_csp_csp cov_mask_2_iint16_dp cov_mask_2_iint32_dp cov_mask_2_iint64_dp cov_mask_2_iint8_dp cov_mask_2_rdp_rdp cov_mask_2_rqp_rqp cov_mask_2_rsp_rsp Functions public function cov_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_mask_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_mask_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_mask_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_mask_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1","tags":"","loc":"interface/cov.html"},{"title":"mean – Fortran-lang/stdlib","text":"public interface mean Mean of array elements\n ( Specification ) Contents Functions mean_1_cdp_cdp mean_1_cqp_cqp mean_1_csp_csp mean_1_iint16_dp mean_1_iint32_dp mean_1_iint64_dp mean_1_iint8_dp mean_1_rdp_rdp mean_1_rqp_rqp mean_1_rsp_rsp mean_2_cdp_cdp mean_2_cqp_cqp mean_2_csp_csp mean_2_iint16_dp mean_2_iint32_dp mean_2_iint64_dp mean_2_iint8_dp mean_2_rdp_rdp mean_2_rqp_rqp mean_2_rsp_rsp mean_3_cdp_cdp mean_3_cqp_cqp mean_3_csp_csp mean_3_iint16_dp mean_3_iint32_dp mean_3_iint64_dp mean_3_iint8_dp mean_3_rdp_rdp mean_3_rqp_rqp mean_3_rsp_rsp mean_all_1_cdp_cdp mean_all_1_cqp_cqp mean_all_1_csp_csp mean_all_1_iint16_dp mean_all_1_iint32_dp mean_all_1_iint64_dp mean_all_1_iint8_dp mean_all_1_rdp_rdp mean_all_1_rqp_rqp mean_all_1_rsp_rsp mean_all_2_cdp_cdp mean_all_2_cqp_cqp mean_all_2_csp_csp mean_all_2_iint16_dp mean_all_2_iint32_dp mean_all_2_iint64_dp mean_all_2_iint8_dp mean_all_2_rdp_rdp mean_all_2_rqp_rqp mean_all_2_rsp_rsp mean_all_3_cdp_cdp mean_all_3_cqp_cqp mean_all_3_csp_csp mean_all_3_iint16_dp mean_all_3_iint32_dp mean_all_3_iint64_dp mean_all_3_iint8_dp mean_all_3_rdp_rdp mean_all_3_rqp_rqp mean_all_3_rsp_rsp mean_mask_1_cdp_cdp mean_mask_1_cqp_cqp mean_mask_1_csp_csp mean_mask_1_iint16_dp mean_mask_1_iint32_dp mean_mask_1_iint64_dp mean_mask_1_iint8_dp mean_mask_1_rdp_rdp mean_mask_1_rqp_rqp mean_mask_1_rsp_rsp mean_mask_2_cdp_cdp mean_mask_2_cqp_cqp mean_mask_2_csp_csp mean_mask_2_iint16_dp mean_mask_2_iint32_dp mean_mask_2_iint64_dp mean_mask_2_iint8_dp mean_mask_2_rdp_rdp mean_mask_2_rqp_rqp mean_mask_2_rsp_rsp mean_mask_3_cdp_cdp mean_mask_3_cqp_cqp mean_mask_3_csp_csp mean_mask_3_iint16_dp mean_mask_3_iint32_dp mean_mask_3_iint64_dp mean_mask_3_iint8_dp mean_mask_3_rdp_rdp mean_mask_3_rqp_rqp mean_mask_3_rsp_rsp mean_mask_all_1_cdp_cdp mean_mask_all_1_cqp_cqp mean_mask_all_1_csp_csp mean_mask_all_1_iint16_dp mean_mask_all_1_iint32_dp mean_mask_all_1_iint64_dp mean_mask_all_1_iint8_dp mean_mask_all_1_rdp_rdp mean_mask_all_1_rqp_rqp mean_mask_all_1_rsp_rsp mean_mask_all_2_cdp_cdp mean_mask_all_2_cqp_cqp mean_mask_all_2_csp_csp mean_mask_all_2_iint16_dp mean_mask_all_2_iint32_dp mean_mask_all_2_iint64_dp mean_mask_all_2_iint8_dp mean_mask_all_2_rdp_rdp mean_mask_all_2_rqp_rqp mean_mask_all_2_rsp_rsp mean_mask_all_3_cdp_cdp mean_mask_all_3_cqp_cqp mean_mask_all_3_csp_csp mean_mask_all_3_iint16_dp mean_mask_all_3_iint32_dp mean_mask_all_3_iint64_dp mean_mask_all_3_iint8_dp mean_mask_all_3_rdp_rdp mean_mask_all_3_rqp_rqp mean_mask_all_3_rsp_rsp Functions public function mean_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_all_1_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_1_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_1_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_1_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_1_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_all_2_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_2_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_2_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_2_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_2_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_all_3_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_3_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_3_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_3_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_3_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_mask_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function mean_mask_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function mean_mask_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function mean_mask_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function mean_mask_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function mean_mask_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_all_1_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function mean_mask_all_1_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function mean_mask_all_1_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function mean_mask_all_1_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=qp) public function mean_mask_all_1_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=sp) public function mean_mask_all_2_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=dp) public function mean_mask_all_2_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=qp) public function mean_mask_all_2_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=sp) public function mean_mask_all_2_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=qp) public function mean_mask_all_2_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=sp) public function mean_mask_all_3_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp) public function mean_mask_all_3_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp) public function mean_mask_all_3_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp) public function mean_mask_all_3_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp) public function mean_mask_all_3_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)","tags":"","loc":"interface/mean.html"},{"title":"moment – Fortran-lang/stdlib","text":"public interface moment Central moment of array elements\n ( Specification ) Contents Functions moment_1_cdp_cdp moment_1_cqp_cqp moment_1_csp_csp moment_1_iint16_dp moment_1_iint32_dp moment_1_iint64_dp moment_1_iint8_dp moment_1_rdp_rdp moment_1_rqp_rqp moment_1_rsp_rsp moment_2_cdp_cdp moment_2_cqp_cqp moment_2_csp_csp moment_2_iint16_dp moment_2_iint32_dp moment_2_iint64_dp moment_2_iint8_dp moment_2_rdp_rdp moment_2_rqp_rqp moment_2_rsp_rsp moment_3_cdp_cdp moment_3_cqp_cqp moment_3_csp_csp moment_3_iint16_dp moment_3_iint32_dp moment_3_iint64_dp moment_3_iint8_dp moment_3_rdp_rdp moment_3_rqp_rqp moment_3_rsp_rsp moment_all_1_cdp_cdp moment_all_1_cqp_cqp moment_all_1_csp_csp moment_all_1_iint16_dp moment_all_1_iint32_dp moment_all_1_iint64_dp moment_all_1_iint8_dp moment_all_1_rdp_rdp moment_all_1_rqp_rqp moment_all_1_rsp_rsp moment_all_2_cdp_cdp moment_all_2_cqp_cqp moment_all_2_csp_csp moment_all_2_iint16_dp moment_all_2_iint32_dp moment_all_2_iint64_dp moment_all_2_iint8_dp moment_all_2_rdp_rdp moment_all_2_rqp_rqp moment_all_2_rsp_rsp moment_all_3_cdp_cdp moment_all_3_cqp_cqp moment_all_3_csp_csp moment_all_3_iint16_dp moment_all_3_iint32_dp moment_all_3_iint64_dp moment_all_3_iint8_dp moment_all_3_rdp_rdp moment_all_3_rqp_rqp moment_all_3_rsp_rsp moment_mask_1_cdp_cdp moment_mask_1_cqp_cqp moment_mask_1_csp_csp moment_mask_1_iint16_dp moment_mask_1_iint32_dp moment_mask_1_iint64_dp moment_mask_1_iint8_dp moment_mask_1_rdp_rdp moment_mask_1_rqp_rqp moment_mask_1_rsp_rsp moment_mask_2_cdp_cdp moment_mask_2_cqp_cqp moment_mask_2_csp_csp moment_mask_2_iint16_dp moment_mask_2_iint32_dp moment_mask_2_iint64_dp moment_mask_2_iint8_dp moment_mask_2_rdp_rdp moment_mask_2_rqp_rqp moment_mask_2_rsp_rsp moment_mask_3_cdp_cdp moment_mask_3_cqp_cqp moment_mask_3_csp_csp moment_mask_3_iint16_dp moment_mask_3_iint32_dp moment_mask_3_iint64_dp moment_mask_3_iint8_dp moment_mask_3_rdp_rdp moment_mask_3_rqp_rqp moment_mask_3_rsp_rsp moment_mask_all_1_cdp_cdp moment_mask_all_1_cqp_cqp moment_mask_all_1_csp_csp moment_mask_all_1_iint16_dp moment_mask_all_1_iint32_dp moment_mask_all_1_iint64_dp moment_mask_all_1_iint8_dp moment_mask_all_1_rdp_rdp moment_mask_all_1_rqp_rqp moment_mask_all_1_rsp_rsp moment_mask_all_2_cdp_cdp moment_mask_all_2_cqp_cqp moment_mask_all_2_csp_csp moment_mask_all_2_iint16_dp moment_mask_all_2_iint32_dp moment_mask_all_2_iint64_dp moment_mask_all_2_iint8_dp moment_mask_all_2_rdp_rdp moment_mask_all_2_rqp_rqp moment_mask_all_2_rsp_rsp moment_mask_all_3_cdp_cdp moment_mask_all_3_cqp_cqp moment_mask_all_3_csp_csp moment_mask_all_3_iint16_dp moment_mask_all_3_iint32_dp moment_mask_all_3_iint64_dp moment_mask_all_3_iint8_dp moment_mask_all_3_rdp_rdp moment_mask_all_3_rqp_rqp moment_mask_all_3_rsp_rsp moment_mask_scalar_2_cdp_cdp moment_mask_scalar_2_cqp_cqp moment_mask_scalar_2_csp_csp moment_mask_scalar_2_iint16_dp moment_mask_scalar_2_iint32_dp moment_mask_scalar_2_iint64_dp moment_mask_scalar_2_iint8_dp moment_mask_scalar_2_rdp_rdp moment_mask_scalar_2_rqp_rqp moment_mask_scalar_2_rsp_rsp moment_mask_scalar_3_cdp_cdp moment_mask_scalar_3_cqp_cqp moment_mask_scalar_3_csp_csp moment_mask_scalar_3_iint16_dp moment_mask_scalar_3_iint32_dp moment_mask_scalar_3_iint64_dp moment_mask_scalar_3_iint8_dp moment_mask_scalar_3_rdp_rdp moment_mask_scalar_3_rqp_rqp moment_mask_scalar_3_rsp_rsp moment_scalar_2_cdp_cdp moment_scalar_2_cqp_cqp moment_scalar_2_csp_csp moment_scalar_2_iint16_dp moment_scalar_2_iint32_dp moment_scalar_2_iint64_dp moment_scalar_2_iint8_dp moment_scalar_2_rdp_rdp moment_scalar_2_rqp_rqp moment_scalar_2_rsp_rsp moment_scalar_3_cdp_cdp moment_scalar_3_cqp_cqp moment_scalar_3_csp_csp moment_scalar_3_iint16_dp moment_scalar_3_iint32_dp moment_scalar_3_iint64_dp moment_scalar_3_iint8_dp moment_scalar_3_rdp_rdp moment_scalar_3_rqp_rqp moment_scalar_3_rsp_rsp Functions public function moment_1_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_1_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_1_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_1_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_1_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_all_1_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_1_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_1_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_1_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_1_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_all_2_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_2_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_2_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_2_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_2_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_all_3_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_3_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_3_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_3_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_3_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_mask_1_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function moment_mask_1_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function moment_mask_1_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function moment_mask_1_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=qp) public function moment_mask_1_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=sp) public function moment_mask_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_all_1_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function moment_mask_all_1_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function moment_mask_all_1_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function moment_mask_all_1_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=qp) public function moment_mask_all_1_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=sp) public function moment_mask_all_2_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=dp) public function moment_mask_all_2_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=qp) public function moment_mask_all_2_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=sp) public function moment_mask_all_2_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=qp) public function moment_mask_all_2_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=sp) public function moment_mask_all_3_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp) public function moment_mask_all_3_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp) public function moment_mask_all_3_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp) public function moment_mask_all_3_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp) public function moment_mask_all_3_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp) public function moment_mask_scalar_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1","tags":"","loc":"interface/moment.html"},{"title":"var – Fortran-lang/stdlib","text":"public interface var Variance of array elements\n ( Specification ) Contents Functions var_1_cdp_cdp var_1_cqp_cqp var_1_csp_csp var_1_iint16_dp var_1_iint32_dp var_1_iint64_dp var_1_iint8_dp var_1_rdp_rdp var_1_rqp_rqp var_1_rsp_rsp var_2_cdp_cdp var_2_cqp_cqp var_2_csp_csp var_2_iint16_dp var_2_iint32_dp var_2_iint64_dp var_2_iint8_dp var_2_rdp_rdp var_2_rqp_rqp var_2_rsp_rsp var_3_cdp_cdp var_3_cqp_cqp var_3_csp_csp var_3_iint16_dp var_3_iint32_dp var_3_iint64_dp var_3_iint8_dp var_3_rdp_rdp var_3_rqp_rqp var_3_rsp_rsp var_all_1_cdp_cdp var_all_1_cqp_cqp var_all_1_csp_csp var_all_1_iint16_dp var_all_1_iint32_dp var_all_1_iint64_dp var_all_1_iint8_dp var_all_1_rdp_rdp var_all_1_rqp_rqp var_all_1_rsp_rsp var_all_2_cdp_cdp var_all_2_cqp_cqp var_all_2_csp_csp var_all_2_iint16_dp var_all_2_iint32_dp var_all_2_iint64_dp var_all_2_iint8_dp var_all_2_rdp_rdp var_all_2_rqp_rqp var_all_2_rsp_rsp var_all_3_cdp_cdp var_all_3_cqp_cqp var_all_3_csp_csp var_all_3_iint16_dp var_all_3_iint32_dp var_all_3_iint64_dp var_all_3_iint8_dp var_all_3_rdp_rdp var_all_3_rqp_rqp var_all_3_rsp_rsp var_mask_1_cdp_cdp var_mask_1_cqp_cqp var_mask_1_csp_csp var_mask_1_iint16_dp var_mask_1_iint32_dp var_mask_1_iint64_dp var_mask_1_iint8_dp var_mask_1_rdp_rdp var_mask_1_rqp_rqp var_mask_1_rsp_rsp var_mask_2_cdp_cdp var_mask_2_cqp_cqp var_mask_2_csp_csp var_mask_2_iint16_dp var_mask_2_iint32_dp var_mask_2_iint64_dp var_mask_2_iint8_dp var_mask_2_rdp_rdp var_mask_2_rqp_rqp var_mask_2_rsp_rsp var_mask_3_cdp_cdp var_mask_3_cqp_cqp var_mask_3_csp_csp var_mask_3_iint16_dp var_mask_3_iint32_dp var_mask_3_iint64_dp var_mask_3_iint8_dp var_mask_3_rdp_rdp var_mask_3_rqp_rqp var_mask_3_rsp_rsp var_mask_all_1_cdp_cdp var_mask_all_1_cqp_cqp var_mask_all_1_csp_csp var_mask_all_1_iint16_dp var_mask_all_1_iint32_dp var_mask_all_1_iint64_dp var_mask_all_1_iint8_dp var_mask_all_1_rdp_rdp var_mask_all_1_rqp_rqp var_mask_all_1_rsp_rsp var_mask_all_2_cdp_cdp var_mask_all_2_cqp_cqp var_mask_all_2_csp_csp var_mask_all_2_iint16_dp var_mask_all_2_iint32_dp var_mask_all_2_iint64_dp var_mask_all_2_iint8_dp var_mask_all_2_rdp_rdp var_mask_all_2_rqp_rqp var_mask_all_2_rsp_rsp var_mask_all_3_cdp_cdp var_mask_all_3_cqp_cqp var_mask_all_3_csp_csp var_mask_all_3_iint16_dp var_mask_all_3_iint32_dp var_mask_all_3_iint64_dp var_mask_all_3_iint8_dp var_mask_all_3_rdp_rdp var_mask_all_3_rqp_rqp var_mask_all_3_rsp_rsp Functions public function var_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_all_1_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_1_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_1_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_1_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_2_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_2_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_2_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_2_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_3_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_3_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_3_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_3_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_all_1_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_1_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_1_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_1_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_2_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_2_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_2_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_2_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_3_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_3_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_3_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_3_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)","tags":"","loc":"interface/var.html"},{"title":"open – Fortran-lang/stdlib","text":"public function open(filename, mode, iostat) result(u) Opens a file\n ( Specification ) Behavior To open a file to read: u = open ( \"somefile.txt\" ) ! The default `mode` is \"rt\" u = open ( \"somefile.txt\" , \"r\" ) To open a file to write: u = open ( \"somefile.txt\" , \"w\" ) To append to the end of the file if it exists: u = open ( \"somefile.txt\" , \"a\" ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: mode integer, intent(out), optional :: iostat Return Value integer Calls proc~~open~~CallsGraph proc~open open interface~optval optval proc~open->interface~optval proc~parse_mode parse_mode proc~open->proc~parse_mode Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables access_ action_ form_ mode_ position_ status_ Source Code open Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: access_ character(len=:), public, allocatable :: action_ character(len=:), public, allocatable :: form_ character(len=3), public :: mode_ character(len=:), public, allocatable :: position_ character(len=:), public, allocatable :: status_ Source Code integer function open ( filename , mode , iostat ) result ( u ) !! version: experimental !! !! Opens a file !! ([Specification](../page/specs/stdlib_io.html#description_1)) !! !!##### Behavior !! !! !! To open a file to read: !! !!```fortran !! u = open(\"somefile.txt\")        ! The default `mode` is \"rt\" !! u = open(\"somefile.txt\", \"r\") !!``` !! !! To open a file to write: !! !!```fortran !! u = open(\"somefile.txt\", \"w\") !!``` !! !! To append to the end of the file if it exists: !! !!```fortran !! u = open(\"somefile.txt\", \"a\") !!``` character ( * ), intent ( in ) :: filename character ( * ), intent ( in ), optional :: mode integer , intent ( out ), optional :: iostat character ( 3 ) :: mode_ character (:), allocatable :: action_ , position_ , status_ , access_ , form_ mode_ = parse_mode ( optval ( mode , \"\" )) select case ( mode_ ( 1 : 2 )) case ( 'r' ) action_ = 'read' position_ = 'asis' status_ = 'old' case ( 'w' ) action_ = 'write' position_ = 'asis' status_ = 'replace' case ( 'a' ) action_ = 'write' position_ = 'append' status_ = 'old' case ( 'x' ) action_ = 'write' position_ = 'asis' status_ = 'new' case ( 'r+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'old' case ( 'w+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'replace' case ( 'a+' ) action_ = 'readwrite' position_ = 'append' status_ = 'old' case ( 'x+' ) action_ = 'readwrite' position_ = 'asis' status_ = 'new' case default call error_stop ( \"Unsupported mode: \" // mode_ ( 1 : 2 )) end select select case ( mode_ ( 3 : 3 )) case ( 't' ) form_ = 'formatted' case ( 'b' ) form_ = 'unformatted' case default call error_stop ( \"Unsupported mode: \" // mode_ ( 3 : 3 )) end select access_ = 'stream' if ( present ( iostat )) then open ( newunit = u , file = filename , & action = action_ , position = position_ , status = status_ , & access = access_ , form = form_ , & iostat = iostat ) else open ( newunit = u , file = filename , & action = action_ , position = position_ , status = status_ , & access = access_ , form = form_ ) end if end function open","tags":"","loc":"proc/open.html"},{"title":"parse_mode – Fortran-lang/stdlib","text":"public function parse_mode(mode) result(mode_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mode Return Value character(len=3) Called by proc~~parse_mode~~CalledByGraph proc~parse_mode parse_mode proc~open open proc~open->proc~parse_mode Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables a i lfirst Source Code parse_mode Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: a integer, public :: i logical, public :: lfirst (3) Source Code character ( 3 ) function parse_mode ( mode ) result ( mode_ ) character ( * ), intent ( in ) :: mode integer :: i character (:), allocatable :: a logical :: lfirst ( 3 ) mode_ = 'r t' if ( len_trim ( mode ) == 0 ) return a = trim ( adjustl ( mode )) lfirst = . true . do i = 1 , len ( a ) if ( lfirst ( 1 ) & . and . ( a ( i : i ) == 'r' . or . a ( i : i ) == 'w' . or . a ( i : i ) == 'a' . or . a ( i : i ) == 'x' ) & ) then mode_ ( 1 : 1 ) = a ( i : i ) lfirst ( 1 ) = . false . else if ( lfirst ( 2 ) . and . a ( i : i ) == '+' ) then mode_ ( 2 : 2 ) = a ( i : i ) lfirst ( 2 ) = . false . else if ( lfirst ( 3 ) . and . ( a ( i : i ) == 't' . or . a ( i : i ) == 'b' )) then mode_ ( 3 : 3 ) = a ( i : i ) lfirst ( 3 ) = . false . else if ( a ( i : i ) == ' ' ) then cycle else if ( any (. not . lfirst )) then call error_stop ( \"Wrong mode: \" // trim ( a )) else call error_stop ( \"Wrong character: \" // a ( i : i )) endif end do end function parse_mode","tags":"","loc":"proc/parse_mode.html"},{"title":"loadtxt – Fortran-lang/stdlib","text":"public interface loadtxt Loads a 2D array from a text file\n ( Specification ) Contents Module Procedures loadtxt_rsp loadtxt_rdp loadtxt_rqp loadtxt_iint8 loadtxt_iint16 loadtxt_iint32 loadtxt_iint64 loadtxt_csp loadtxt_cdp loadtxt_cqp Module Procedures private subroutine loadtxt_rsp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=sp), intent(out), allocatable :: d (:,:) Example real ( sp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_rdp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=dp), intent(out), allocatable :: d (:,:) Example real ( dp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_rqp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=qp), intent(out), allocatable :: d (:,:) Example real ( qp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint8(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int8), intent(out), allocatable :: d (:,:) Example integer ( int8 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint16(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int16), intent(out), allocatable :: d (:,:) Example integer ( int16 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint32(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int32), intent(out), allocatable :: d (:,:) Example integer ( int32 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint64(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int64), intent(out), allocatable :: d (:,:) Example integer ( int64 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_csp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=sp), intent(out), allocatable :: d (:,:) Example complex ( sp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_cdp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=dp), intent(out), allocatable :: d (:,:) Example complex ( dp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_cqp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=qp), intent(out), allocatable :: d (:,:) Example complex ( qp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ...","tags":"","loc":"interface/loadtxt.html"},{"title":"savetxt – Fortran-lang/stdlib","text":"public interface savetxt Saves a 2D array into a text file\n ( Specification ) Contents Module Procedures savetxt_rsp savetxt_rdp savetxt_rqp savetxt_iint8 savetxt_iint16 savetxt_iint32 savetxt_iint64 savetxt_csp savetxt_cdp savetxt_cqp Module Procedures private subroutine savetxt_rsp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(in) :: d (:,:) Example real ( sp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_rdp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in) :: d (:,:) Example real ( dp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_rqp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(in) :: d (:,:) Example real ( qp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint8(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(in) :: d (:,:) Example integer ( int8 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint16(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(in) :: d (:,:) Example integer ( int16 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint32(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(in) :: d (:,:) Example integer ( int32 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint64(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(in) :: d (:,:) Example integer ( int64 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_csp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(in) :: d (:,:) Example complex ( sp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_cdp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(in) :: d (:,:) Example complex ( dp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_cqp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(in) :: d (:,:) Example complex ( qp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data )","tags":"","loc":"interface/savetxt.html"},{"title":"check – Fortran-lang/stdlib","text":"public subroutine check(condition, msg, code, warn) Checks the value of a logical condition\n ( Specification ) Behavior If condition == .false. and: No other arguments are provided, it stops the program with the default\n     message and exit code 1 ; msg is provided, it prints the value of msg ; code is provided, it stops the program with the given exit code; warn is provided and .true. , it doesn't stop the program and prints\n     the message. Examples If a /= 5 , stops the program with exit code 1 and prints Check failed. call check ( a == 5 ) As above, but prints a == 5 failed . call check ( a == 5 , msg = 'a == 5 failed.' ) As above, but doesn't stop the program. call check ( a == 5 , msg = 'a == 5 failed.' , warn = . true .) As example #2, but stops the program with exit code 77 call check ( a == 5 , msg = 'a == 5 failed.' , code = 77 ) Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in), optional :: msg integer, intent(in), optional :: code logical, intent(in), optional :: warn Calls proc~~check~~CallsGraph proc~check check interface~optval optval proc~check->interface~optval Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables msg_default Source Code check Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: msg_default = 'Check failed.' Source Code subroutine check ( condition , msg , code , warn ) !! version: experimental !! !! Checks the value of a logical condition !! ([Specification](../page/specs/stdlib_error.html#description)) !! !!##### Behavior !! !! If `condition == .false.` and: !! !!   * No other arguments are provided, it stops the program with the default !!     message and exit code `1`; !!   * `msg` is provided, it prints the value of `msg`; !!   * `code` is provided, it stops the program with the given exit code; !!   * `warn` is provided and `.true.`, it doesn't stop the program and prints !!     the message. !! !!##### Examples !! !!* If `a /= 5`, stops the program with exit code `1` !!  and prints `Check failed.` !!``` fortran !!  call check(a == 5) !!``` !! !!* As above, but prints `a == 5 failed`. !!``` fortran !!  call check(a == 5, msg='a == 5 failed.') !!``` !! !!* As above, but doesn't stop the program. !!``` fortran !!  call check(a == 5, msg='a == 5 failed.', warn=.true.) !!``` !! !!* As example #2, but stops the program with exit code `77` !!``` fortran !!  call check(a == 5, msg='a == 5 failed.', code=77) !!``` ! ! Arguments ! --------- logical , intent ( in ) :: condition character ( * ), intent ( in ), optional :: msg integer , intent ( in ), optional :: code logical , intent ( in ), optional :: warn character ( * ), parameter :: msg_default = 'Check failed.' if (. not . condition ) then if ( optval ( warn , . false .)) then write ( stderr , * ) optval ( msg , msg_default ) else call error_stop ( optval ( msg , msg_default ), optval ( code , 1 )) end if end if end subroutine check","tags":"","loc":"proc/check.html"},{"title":"error_stop – Fortran-lang/stdlib","text":"interface public module subroutine error_stop(msg, code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg integer, intent(in), optional :: code Description Provides a call to error stop and allows the user to specify a code and message\n ( Specification )","tags":"","loc":"interface/error_stop.html"},{"title":"simps – Fortran-lang/stdlib","text":"public interface simps Integrates sampled values using Simpson's rule\n ( Specification ) Contents Functions simps_dx_dp simps_dx_qp simps_dx_sp simps_x_dp simps_x_qp simps_x_sp Functions public pure recursive function simps_dx_dp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=dp) public pure recursive function simps_dx_qp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=qp) public pure recursive function simps_dx_sp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=sp) public recursive function simps_x_dp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=dp) public recursive function simps_x_qp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=qp) public recursive function simps_x_sp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=sp)","tags":"","loc":"interface/simps.html"},{"title":"simps_weights – Fortran-lang/stdlib","text":"public interface simps_weights Integrates sampled values using trapezoidal rule weights for given abscissas\n ( Specification ) Contents Functions simps_weights_dp simps_weights_qp simps_weights_sp Functions public pure recursive function simps_weights_dp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=dp),\n  dimension(size(x)) public pure recursive function simps_weights_qp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=qp),\n  dimension(size(x)) public pure recursive function simps_weights_sp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=sp),\n  dimension(size(x))","tags":"","loc":"interface/simps_weights.html"},{"title":"trapz – Fortran-lang/stdlib","text":"public interface trapz Integrates sampled values using trapezoidal rule\n ( Specification ) Contents Functions trapz_dx_dp trapz_dx_qp trapz_dx_sp trapz_x_dp trapz_x_qp trapz_x_sp Functions public pure function trapz_dx_dp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in) :: dx Return Value real(kind=dp) public pure function trapz_dx_qp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in) :: dx Return Value real(kind=qp) public pure function trapz_dx_sp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in) :: dx Return Value real(kind=sp) public function trapz_x_dp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp) public function trapz_x_qp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in), dimension(:) :: x Return Value real(kind=qp) public function trapz_x_sp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in), dimension(:) :: x Return Value real(kind=sp)","tags":"","loc":"interface/trapz.html"},{"title":"trapz_weights – Fortran-lang/stdlib","text":"public interface trapz_weights Integrates sampled values using trapezoidal rule weights for given abscissas\n ( Specification ) Contents Functions trapz_weights_dp trapz_weights_qp trapz_weights_sp Functions public pure function trapz_weights_dp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp),\n  dimension(size(x)) public pure function trapz_weights_qp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x Return Value real(kind=qp),\n  dimension(size(x)) public pure function trapz_weights_sp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x Return Value real(kind=sp),\n  dimension(size(x))","tags":"","loc":"interface/trapz_weights.html"},{"title":"is_alpha – Fortran-lang/stdlib","text":"public pure function is_alpha(c) Checks whether c is an ASCII letter (A .. Z, a .. z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents None","tags":"","loc":"proc/is_alpha.html"},{"title":"is_alphanum – Fortran-lang/stdlib","text":"public pure function is_alphanum(c) Checks whether c is a letter or a number (0 .. 9, a .. z, A .. Z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Called by proc~~is_alphanum~~CalledByGraph proc~is_alphanum is_alphanum proc~is_punctuation is_punctuation proc~is_punctuation->proc~is_alphanum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/is_alphanum.html"},{"title":"is_ascii – Fortran-lang/stdlib","text":"public pure function is_ascii(c) Checks whether or not c is in the ASCII character set - Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents None","tags":"","loc":"proc/is_ascii.html"},{"title":"is_blank – Fortran-lang/stdlib","text":"public pure function is_blank(c) Checks whether or not c is a blank character. That includes the Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_blank.html"},{"title":"is_control – Fortran-lang/stdlib","text":"public pure function is_control(c) Checks whether c is a control character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_control.html"},{"title":"is_digit – Fortran-lang/stdlib","text":"public pure function is_digit(c) Checks whether c is a digit (0 .. 9). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents None","tags":"","loc":"proc/is_digit.html"},{"title":"is_graphical – Fortran-lang/stdlib","text":"public pure function is_graphical(c) Checks whether or not c is a printable character other than the Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_graphical.html"},{"title":"is_hex_digit – Fortran-lang/stdlib","text":"public pure function is_hex_digit(c) Checks whether c is a digit in base 16 (0 .. 9, A .. F, a .. f). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents None","tags":"","loc":"proc/is_hex_digit.html"},{"title":"is_lower – Fortran-lang/stdlib","text":"public pure function is_lower(c) Checks whether c is a lowercase ASCII letter (a .. z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Called by proc~~is_lower~~CalledByGraph proc~is_lower is_lower proc~to_upper to_upper proc~to_upper->proc~is_lower Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/is_lower.html"},{"title":"is_octal_digit – Fortran-lang/stdlib","text":"public pure function is_octal_digit(c) Checks whether c is a digit in base 8 (0 .. 7). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents None","tags":"","loc":"proc/is_octal_digit.html"},{"title":"is_printable – Fortran-lang/stdlib","text":"public pure function is_printable(c) Checks whether or not c is a printable character - including the Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_printable.html"},{"title":"is_punctuation – Fortran-lang/stdlib","text":"public pure function is_punctuation(c) Checks whether or not c is a punctuation character. That includes Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Calls proc~~is_punctuation~~CallsGraph proc~is_punctuation is_punctuation proc~is_alphanum is_alphanum proc~is_punctuation->proc~is_alphanum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_punctuation.html"},{"title":"is_upper – Fortran-lang/stdlib","text":"public pure function is_upper(c) Checks whether c is an uppercase ASCII letter (A .. Z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Called by proc~~is_upper~~CalledByGraph proc~is_upper is_upper proc~to_lower to_lower proc~to_lower->proc~is_upper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/is_upper.html"},{"title":"is_white – Fortran-lang/stdlib","text":"public pure function is_white(c) Checks whether or not c is a whitespace character. That includes the Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Contents Variables ic Variables Type Visibility Attributes Name Initial integer, public :: ic","tags":"","loc":"proc/is_white.html"},{"title":"to_lower – Fortran-lang/stdlib","text":"public pure function to_lower(c) result(t) Returns the corresponding lowercase letter, if c is an uppercase Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c A character. Return Value character(len=1) Calls proc~~to_lower~~CallsGraph proc~to_lower to_lower proc~is_upper is_upper proc~to_lower->proc~is_upper Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables diff Variables Type Visibility Attributes Name Initial integer, public :: diff","tags":"","loc":"proc/to_lower.html"},{"title":"to_upper – Fortran-lang/stdlib","text":"public pure function to_upper(c) result(t) Returns the corresponding uppercase letter, if c is a lowercase Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c A character. Return Value character(len=1) Calls proc~~to_upper~~CallsGraph proc~to_upper to_upper proc~is_lower is_lower proc~to_upper->proc~is_lower Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables diff Variables Type Visibility Attributes Name Initial integer, public :: diff","tags":"","loc":"proc/to_upper.html"},{"title":"stdlib_linalg – Fortran-lang/stdlib","text":"Provides a support for various linear algebra procedures\n ( Specification ) Uses stdlib_kinds module~~stdlib_linalg~~UsesGraph module~stdlib_linalg stdlib_linalg module~stdlib_kinds stdlib_kinds module~stdlib_linalg->module~stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: stdlib_linalg_diag module~~stdlib_linalg~~UsedByGraph module~stdlib_linalg stdlib_linalg module~stdlib_linalg_diag stdlib_linalg_diag module~stdlib_linalg_diag->module~stdlib_linalg module~stdlib_stats_corr stdlib_stats_corr module~stdlib_stats_corr->module~stdlib_linalg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces diag trace Functions eye Interfaces public interface diag Creates a diagonal array or extract the diagonal elements of an array\n ( Specification ) public function diag_cdp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: v (:) Return Value complex(kind=dp)\n  (size(v),size(v)) public function diag_cdp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=dp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_cdp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value complex(kind=dp)\n  (minval(shape(A))) public function diag_cdp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=dp)\n  (minval(shape(A))-abs(k)) public function diag_cqp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: v (:) Return Value complex(kind=qp)\n  (size(v),size(v)) public function diag_cqp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=qp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_cqp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) Return Value complex(kind=qp)\n  (minval(shape(A))) public function diag_cqp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=qp)\n  (minval(shape(A))-abs(k)) public function diag_csp(v) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: v (:) Return Value complex(kind=sp)\n  (size(v),size(v)) public function diag_csp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: v (:) integer, intent(in) :: k Return Value complex(kind=sp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_csp_mat(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value complex(kind=sp)\n  (minval(shape(A))) public function diag_csp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value complex(kind=sp)\n  (minval(shape(A))-abs(k)) public function diag_iint16(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: v (:) Return Value integer(kind=int16)\n  (size(v),size(v)) public function diag_iint16_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int16)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint16_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) Return Value integer(kind=int16)\n  (minval(shape(A))) public function diag_iint16_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int16)\n  (minval(shape(A))-abs(k)) public function diag_iint32(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: v (:) Return Value integer(kind=int32)\n  (size(v),size(v)) public function diag_iint32_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int32)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint32_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) Return Value integer(kind=int32)\n  (minval(shape(A))) public function diag_iint32_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int32)\n  (minval(shape(A))-abs(k)) public function diag_iint64(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: v (:) Return Value integer(kind=int64)\n  (size(v),size(v)) public function diag_iint64_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int64)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint64_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) Return Value integer(kind=int64)\n  (minval(shape(A))) public function diag_iint64_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int64)\n  (minval(shape(A))-abs(k)) public function diag_iint8(v) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: v (:) Return Value integer(kind=int8)\n  (size(v),size(v)) public function diag_iint8_k(v, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: v (:) integer, intent(in) :: k Return Value integer(kind=int8)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_iint8_mat(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) Return Value integer(kind=int8)\n  (minval(shape(A))) public function diag_iint8_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) integer, intent(in) :: k Return Value integer(kind=int8)\n  (minval(shape(A))-abs(k)) public function diag_rdp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) Return Value real(kind=dp)\n  (size(v),size(v)) public function diag_rdp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=dp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rdp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp)\n  (minval(shape(A))) public function diag_rdp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=dp)\n  (minval(shape(A))-abs(k)) public function diag_rqp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: v (:) Return Value real(kind=qp)\n  (size(v),size(v)) public function diag_rqp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=qp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rqp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) Return Value real(kind=qp)\n  (minval(shape(A))) public function diag_rqp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=qp)\n  (minval(shape(A))-abs(k)) public function diag_rsp(v) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: v (:) Return Value real(kind=sp)\n  (size(v),size(v)) public function diag_rsp_k(v, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: v (:) integer, intent(in) :: k Return Value real(kind=sp)\n  (size(v)+abs(k),size(v)+abs(k)) public function diag_rsp_mat(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value real(kind=sp)\n  (minval(shape(A))) public function diag_rsp_mat_k(A, k) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) integer, intent(in) :: k Return Value real(kind=sp)\n  (minval(shape(A))-abs(k)) public interface trace Computes the trace of a matrix\n ( Specification ) private function trace_rsp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) Return Value real(kind=sp) private function trace_rdp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) Return Value real(kind=dp) private function trace_rqp(A) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: A (:,:) Return Value real(kind=qp) private function trace_csp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: A (:,:) Return Value complex(kind=sp) private function trace_cdp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) Return Value complex(kind=dp) private function trace_cqp(A) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: A (:,:) Return Value complex(kind=qp) private function trace_iint8(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: A (:,:) Return Value integer(kind=int8) private function trace_iint16(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: A (:,:) Return Value integer(kind=int16) private function trace_iint32(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) Return Value integer(kind=int32) private function trace_iint64(A) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) Return Value integer(kind=int64) Functions public function eye (n) result(res) Version experimental Constructs the identity matrix\n ( Specification ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value integer(kind=int8)\n  (n,n)","tags":"","loc":"module/stdlib_linalg.html"},{"title":"stdlib_optval – Fortran-lang/stdlib","text":"Provides a generic function optval , which can be used to\n conveniently implement fallback values for optional arguments\n to subprograms\n ( Specification ) If x is an optional parameter of a\n subprogram, then the expression optval(x, default) inside that\n subprogram evaluates to x if it is present, otherwise default . It is an error to call optval with a single actual argument. Uses stdlib_kinds module~~stdlib_optval~~UsesGraph module~stdlib_optval stdlib_optval module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~stdlib_optval~~UsedByGraph module~stdlib_optval stdlib_optval module~stdlib_stats_cov stdlib_stats_cov module~stdlib_stats_cov->module~stdlib_optval module~stdlib_error stdlib_error module~stdlib_stats_cov->module~stdlib_error module~stdlib_stats_moment stdlib_stats_moment module~stdlib_stats_moment->module~stdlib_optval module~stdlib_stats_moment->module~stdlib_error module~stdlib_stats_corr stdlib_stats_corr module~stdlib_stats_corr->module~stdlib_optval module~stdlib_stats_corr->module~stdlib_error module~stdlib_stats_var stdlib_stats_var module~stdlib_stats_var->module~stdlib_optval module~stdlib_stats_var->module~stdlib_error module~stdlib_error->module~stdlib_optval module~stdlib_stats_mean stdlib_stats_mean module~stdlib_stats_mean->module~stdlib_optval module~stdlib_stats_mean->module~stdlib_error module~stdlib_io stdlib_io module~stdlib_io->module~stdlib_optval module~stdlib_io->module~stdlib_error module~stdlib_quadrature_simps stdlib_quadrature_simps module~stdlib_quadrature_simps->module~stdlib_error module~stdlib_quadrature_trapz stdlib_quadrature_trapz module~stdlib_quadrature_trapz->module~stdlib_error module~estop~2 estop module~estop~2->module~stdlib_error module~estop estop module~estop->module~stdlib_error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces optval Interfaces public interface optval Fallback value for optional arguments\n ( Specification ) private pure elemental function optval_rsp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), optional :: x real(kind=sp), intent(in) :: default Return Value real(kind=sp) private pure elemental function optval_rdp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional :: x real(kind=dp), intent(in) :: default Return Value real(kind=dp) private pure elemental function optval_rqp(x, default) result(y) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), optional :: x real(kind=qp), intent(in) :: default Return Value real(kind=qp) private pure elemental function optval_iint8(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), optional :: x integer(kind=int8), intent(in) :: default Return Value integer(kind=int8) private pure elemental function optval_iint16(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), optional :: x integer(kind=int16), intent(in) :: default Return Value integer(kind=int16) private pure elemental function optval_iint32(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), optional :: x integer(kind=int32), intent(in) :: default Return Value integer(kind=int32) private pure elemental function optval_iint64(x, default) result(y) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), optional :: x integer(kind=int64), intent(in) :: default Return Value integer(kind=int64) private pure elemental function optval_csp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in), optional :: x complex(kind=sp), intent(in) :: default Return Value complex(kind=sp) private pure elemental function optval_cdp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in), optional :: x complex(kind=dp), intent(in) :: default Return Value complex(kind=dp) private pure elemental function optval_cqp(x, default) result(y) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in), optional :: x complex(kind=qp), intent(in) :: default Return Value complex(kind=qp) private pure elemental function optval_ll1(x, default) result(y) Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: x logical, intent(in) :: default Return Value logical private pure function optval_character(x, default) result(y) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: x character(len=*), intent(in) :: default Return Value character(len=:),\n  allocatable","tags":"","loc":"module/stdlib_optval.html"},{"title":"stdlib_stats – Fortran-lang/stdlib","text":"Provides support for various statistical methods. This includes currently\n descriptive statistics\n ( Specification ) Uses stdlib_kinds module~~stdlib_stats~~UsesGraph module~stdlib_stats stdlib_stats module~stdlib_kinds stdlib_kinds module~stdlib_stats->module~stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: stdlib_stats_corr stdlib_stats_cov stdlib_stats_mean stdlib_stats_moment stdlib_stats_var module~~stdlib_stats~~UsedByGraph module~stdlib_stats stdlib_stats module~stdlib_stats_cov stdlib_stats_cov module~stdlib_stats_cov->module~stdlib_stats module~stdlib_stats_moment stdlib_stats_moment module~stdlib_stats_moment->module~stdlib_stats module~stdlib_stats_corr stdlib_stats_corr module~stdlib_stats_corr->module~stdlib_stats module~stdlib_stats_var stdlib_stats_var module~stdlib_stats_var->module~stdlib_stats module~stdlib_stats_mean stdlib_stats_mean module~stdlib_stats_mean->module~stdlib_stats Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces corr cov mean moment var Interfaces public interface corr Pearson correlation of array elements\n ( Specification ) public function corr_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function corr_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function corr_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function corr_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function corr_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function corr_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function corr_mask_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function corr_mask_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function corr_mask_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function corr_mask_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function corr_mask_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function corr_mask_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public interface cov Covariance of array elements\n ( Specification ) public function cov_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_mask_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_mask_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function cov_mask_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function cov_mask_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function cov_mask_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function cov_mask_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public interface mean Mean of array elements\n ( Specification ) public function mean_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_3_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_all_1_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_1_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_1_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_1_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_1_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_1_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_all_2_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_2_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_2_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_2_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_2_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_2_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_all_3_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=dp) public function mean_all_3_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=qp) public function mean_all_3_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value complex(kind=sp) public function mean_all_3_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=dp) public function mean_all_3_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=qp) public function mean_all_3_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask Return Value real(kind=sp) public function mean_mask_1_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function mean_mask_1_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function mean_mask_1_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function mean_mask_1_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_1_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=qp) public function mean_mask_1_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) Return Value real(kind=sp) public function mean_mask_2_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_2_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_cdp_cdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_cqp_cqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_csp_csp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint16_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint32_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint64_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_iint8_dp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rdp_rdp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rqp_rqp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_3_rsp_rsp(x, dim, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function mean_mask_all_1_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function mean_mask_all_1_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function mean_mask_all_1_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function mean_mask_all_1_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=dp) public function mean_mask_all_1_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=qp) public function mean_mask_all_1_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) Return Value real(kind=sp) public function mean_mask_all_2_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=dp) public function mean_mask_all_2_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=qp) public function mean_mask_all_2_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value complex(kind=sp) public function mean_mask_all_2_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function mean_mask_all_2_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=qp) public function mean_mask_all_2_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) Return Value real(kind=sp) public function mean_mask_all_3_cdp_cdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp) public function mean_mask_all_3_cqp_cqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp) public function mean_mask_all_3_csp_csp(x, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp) public function mean_mask_all_3_iint16_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint32_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint64_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_iint8_dp(x, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_rdp_rdp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function mean_mask_all_3_rqp_rqp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp) public function mean_mask_all_3_rsp_rsp(x, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp) public interface moment Central moment of array elements\n ( Specification ) public function moment_1_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_1_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_1_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_1_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_1_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_1_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_all_1_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_1_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_1_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_1_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_1_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_1_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_all_2_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_2_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_2_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_2_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_2_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_2_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_all_3_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=dp) public function moment_all_3_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=qp) public function moment_all_3_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value complex(kind=sp) public function moment_all_3_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=dp) public function moment_all_3_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=qp) public function moment_all_3_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in), optional :: mask Return Value real(kind=sp) public function moment_mask_1_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function moment_mask_1_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function moment_mask_1_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function moment_mask_1_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_1_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=qp) public function moment_mask_1_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=sp) public function moment_mask_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in), optional :: center (merge(size(x,1),size(x,2),mask=1 logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_all_1_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=dp) public function moment_mask_all_1_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=qp) public function moment_mask_all_1_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value complex(kind=sp) public function moment_mask_all_1_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=dp) public function moment_mask_all_1_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=qp) public function moment_mask_all_1_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:) Return Value real(kind=sp) public function moment_mask_all_2_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=dp) public function moment_mask_all_2_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=qp) public function moment_mask_all_2_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=sp) public function moment_mask_all_2_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp) public function moment_mask_all_2_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=qp) public function moment_mask_all_2_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:) Return Value real(kind=sp) public function moment_mask_all_3_cdp_cdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp) public function moment_mask_all_3_cqp_cqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp) public function moment_mask_all_3_csp_csp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order complex(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp) public function moment_mask_all_3_iint16_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint32_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint64_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_iint8_dp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_rdp_rdp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=dp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp) public function moment_mask_all_3_rqp_rqp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=qp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp) public function moment_mask_all_3_rsp_rsp(x, order, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order real(kind=sp), intent(in), optional :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp) public function moment_mask_scalar_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_mask_scalar_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in) :: mask (:,:,:) Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_2_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_cdp_cdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_cqp_cqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_csp_csp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim complex(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value complex(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint16_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint32_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint64_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_iint8_dp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rdp_rdp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=dp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rqp_rqp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=qp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function moment_scalar_3_rsp_rsp(x, order, dim, center, mask) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: order integer, intent(in) :: dim real(kind=sp), intent(in) :: center logical, intent(in), optional :: mask Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public interface var Variance of array elements\n ( Specification ) public function var_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_3_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_all_1_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_1_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_1_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_1_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_1_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_2_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_2_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_2_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_2_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_2_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_3_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_3_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_all_3_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_all_3_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_all_3_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in), optional :: mask logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_1_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_1_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_1_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_1_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_1_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) integer, intent(in) :: dim logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_2_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_2_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_cdp_cdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_cqp_cqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_csp_csp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint16_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint32_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint64_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_iint8_dp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rdp_rdp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rqp_rqp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_3_rsp_rsp(x, dim, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) integer, intent(in) :: dim logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)\n  (merge(size(x,1),size(x,2),mask=1 public function var_mask_all_1_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_1_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_1_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_1_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_1_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) logical, intent(in) :: mask (:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_2_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_2_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_2_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_2_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_2_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:) logical, intent(in) :: mask (:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_3_cdp_cdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_cqp_cqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_3_csp_csp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp) public function var_mask_all_3_iint16_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint32_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint64_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_iint8_dp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_rdp_rdp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=dp) public function var_mask_all_3_rqp_rqp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=qp) public function var_mask_all_3_rsp_rsp(x, mask, corrected) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:,:,:) logical, intent(in) :: mask (:,:,:) logical, intent(in), optional :: corrected Return Value real(kind=sp)","tags":"","loc":"module/stdlib_stats.html"},{"title":"stdlib_io – Fortran-lang/stdlib","text":"Provides a support for file handling\n ( Specification ) Uses stdlib_kinds stdlib_error stdlib_optval stdlib_ascii module~~stdlib_io~~UsesGraph module~stdlib_io stdlib_io module~stdlib_ascii stdlib_ascii module~stdlib_io->module~stdlib_ascii module~stdlib_error stdlib_error module~stdlib_io->module~stdlib_error module~stdlib_kinds stdlib_kinds module~stdlib_io->module~stdlib_kinds module~stdlib_optval stdlib_optval module~stdlib_io->module~stdlib_optval module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds->iso_fortran_env module~stdlib_optval->module~stdlib_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces loadtxt savetxt Functions open parse_mode Interfaces public interface loadtxt Loads a 2D array from a text file\n ( Specification ) private subroutine loadtxt_rsp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=sp), intent(out), allocatable :: d (:,:) Example real ( sp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_rdp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=dp), intent(out), allocatable :: d (:,:) Example real ( dp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_rqp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions real(kind=qp), intent(out), allocatable :: d (:,:) Example real ( qp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint8(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int8), intent(out), allocatable :: d (:,:) Example integer ( int8 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint16(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int16), intent(out), allocatable :: d (:,:) Example integer ( int16 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint32(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int32), intent(out), allocatable :: d (:,:) Example integer ( int32 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_iint64(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions integer(kind=int64), intent(out), allocatable :: d (:,:) Example integer ( int64 ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_csp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=sp), intent(out), allocatable :: d (:,:) Example complex ( sp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_cdp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=dp), intent(out), allocatable :: d (:,:) Example complex ( dp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... private subroutine loadtxt_cqp(filename, d) Loads a 2D array from a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename The array 'd' will be automatically allocated with the correct dimensions complex(kind=qp), intent(out), allocatable :: d (:,:) Example complex ( qp ), allocatable :: data (:, :) call loadtxt ( \"log.txt\" , data ) ! 'data' will be automatically allocated Where 'log.txt' contains for example:: 1 2 3 2 4 6 8 9 10 11 12 13 ... public interface savetxt Saves a 2D array into a text file\n ( Specification ) private subroutine savetxt_rsp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=sp), intent(in) :: d (:,:) Example real ( sp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_rdp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=dp), intent(in) :: d (:,:) Example real ( dp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_rqp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename real(kind=qp), intent(in) :: d (:,:) Example real ( qp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint8(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int8), intent(in) :: d (:,:) Example integer ( int8 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint16(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int16), intent(in) :: d (:,:) Example integer ( int16 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint32(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int32), intent(in) :: d (:,:) Example integer ( int32 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_iint64(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer(kind=int64), intent(in) :: d (:,:) Example integer ( int64 ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_csp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=sp), intent(in) :: d (:,:) Example complex ( sp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_cdp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=dp), intent(in) :: d (:,:) Example complex ( dp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) private subroutine savetxt_cqp(filename, d) Saves a 2D array into a text file. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename complex(kind=qp), intent(in) :: d (:,:) Example complex ( qp ) :: data ( 3 , 2 ) call savetxt ( \"log.txt\" , data ) Functions public function open (filename, mode, iostat) result(u) Version experimental Opens a file\n ( Specification ) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in), optional :: mode integer, intent(out), optional :: iostat Return Value integer public function parse_mode (mode) result(mode_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: mode Return Value character(len=3)","tags":"","loc":"module/stdlib_io.html"},{"title":"stdlib_error – Fortran-lang/stdlib","text":"Provides support for catching and handling errors\n ( Specification ) Uses iso_fortran_env stdlib_optval module~~stdlib_error~~UsesGraph module~stdlib_error stdlib_error iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_optval stdlib_optval module~stdlib_error->module~stdlib_optval module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: estop estop module~~stdlib_error~~UsedByGraph module~stdlib_error stdlib_error module~stdlib_stats_cov stdlib_stats_cov module~stdlib_stats_cov->module~stdlib_error module~stdlib_io stdlib_io module~stdlib_io->module~stdlib_error module~stdlib_quadrature_simps stdlib_quadrature_simps module~stdlib_quadrature_simps->module~stdlib_error module~stdlib_stats_moment stdlib_stats_moment module~stdlib_stats_moment->module~stdlib_error module~estop~2 estop module~estop~2->module~stdlib_error module~stdlib_stats_corr stdlib_stats_corr module~stdlib_stats_corr->module~stdlib_error module~estop estop module~estop->module~stdlib_error module~stdlib_stats_var stdlib_stats_var module~stdlib_stats_var->module~stdlib_error module~stdlib_stats_mean stdlib_stats_mean module~stdlib_stats_mean->module~stdlib_error module~stdlib_quadrature_trapz stdlib_quadrature_trapz module~stdlib_quadrature_trapz->module~stdlib_error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces error_stop Subroutines check Interfaces interface public module subroutine error_stop(msg, code) Provides a call to error stop and allows the user to specify a code and message\n ( Specification ) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg integer, intent(in), optional :: code Subroutines public subroutine check (condition, msg, code, warn) Version experimental Checks the value of a logical condition\n ( Specification ) Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: condition character(len=*), intent(in), optional :: msg integer, intent(in), optional :: code logical, intent(in), optional :: warn","tags":"","loc":"module/stdlib_error.html"},{"title":"stdlib_quadrature – Fortran-lang/stdlib","text":"( Specification ) Uses stdlib_kinds module~~stdlib_quadrature~~UsesGraph module~stdlib_quadrature stdlib_quadrature module~stdlib_kinds stdlib_kinds module~stdlib_quadrature->module~stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by Descendants: stdlib_quadrature_simps stdlib_quadrature_trapz module~~stdlib_quadrature~~UsedByGraph module~stdlib_quadrature stdlib_quadrature module~stdlib_quadrature_simps stdlib_quadrature_simps module~stdlib_quadrature_simps->module~stdlib_quadrature module~stdlib_quadrature_trapz stdlib_quadrature_trapz module~stdlib_quadrature_trapz->module~stdlib_quadrature Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces simps simps_weights trapz trapz_weights Interfaces public interface simps Integrates sampled values using Simpson's rule\n ( Specification ) public pure recursive function simps_dx_dp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=dp) public pure recursive function simps_dx_qp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=qp) public pure recursive function simps_dx_sp(y, dx, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in) :: dx integer, intent(in), optional :: even Return Value real(kind=sp) public recursive function simps_x_dp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=dp) public recursive function simps_x_qp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=qp) public recursive function simps_x_sp(y, x, even) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=sp) public interface simps_weights Integrates sampled values using trapezoidal rule weights for given abscissas\n ( Specification ) public pure recursive function simps_weights_dp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=dp),\n  dimension(size(x)) public pure recursive function simps_weights_qp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=qp),\n  dimension(size(x)) public pure recursive function simps_weights_sp(x, even) result(w) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x integer, intent(in), optional :: even Return Value real(kind=sp),\n  dimension(size(x)) public interface trapz Integrates sampled values using trapezoidal rule\n ( Specification ) public pure function trapz_dx_dp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in) :: dx Return Value real(kind=dp) public pure function trapz_dx_qp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in) :: dx Return Value real(kind=qp) public pure function trapz_dx_sp(y, dx) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in) :: dx Return Value real(kind=sp) public function trapz_x_dp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: y real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp) public function trapz_x_qp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: y real(kind=qp), intent(in), dimension(:) :: x Return Value real(kind=qp) public function trapz_x_sp(y, x) result(integral) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: y real(kind=sp), intent(in), dimension(:) :: x Return Value real(kind=sp) public interface trapz_weights Integrates sampled values using trapezoidal rule weights for given abscissas\n ( Specification ) public pure function trapz_weights_dp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), dimension(:) :: x Return Value real(kind=dp),\n  dimension(size(x)) public pure function trapz_weights_qp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=qp), intent(in), dimension(:) :: x Return Value real(kind=qp),\n  dimension(size(x)) public pure function trapz_weights_sp(x) result(w) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), dimension(:) :: x Return Value real(kind=sp),\n  dimension(size(x))","tags":"","loc":"module/stdlib_quadrature.html"},{"title":"stdlib_kinds – Fortran-lang/stdlib","text":"Uses iso_fortran_env iso_fortran_env module~~stdlib_kinds~~UsesGraph module~stdlib_kinds stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~stdlib_kinds~~UsedByGraph module~stdlib_kinds stdlib_kinds module~stdlib_linalg stdlib_linalg module~stdlib_linalg->module~stdlib_kinds module~stdlib_stats stdlib_stats module~stdlib_stats->module~stdlib_kinds module~stdlib_optval stdlib_optval module~stdlib_optval->module~stdlib_kinds module~stdlib_quadrature stdlib_quadrature module~stdlib_quadrature->module~stdlib_kinds module~stdlib_io stdlib_io module~stdlib_io->module~stdlib_kinds module~stdlib_io->module~stdlib_optval module~stdlib_error stdlib_error module~stdlib_io->module~stdlib_error module~stdlib_stats_cov stdlib_stats_cov module~stdlib_stats_cov->module~stdlib_stats module~stdlib_stats_cov->module~stdlib_optval module~stdlib_stats_cov->module~stdlib_error module~stdlib_quadrature_simps stdlib_quadrature_simps module~stdlib_quadrature_simps->module~stdlib_quadrature module~stdlib_quadrature_simps->module~stdlib_error module~stdlib_stats_moment stdlib_stats_moment module~stdlib_stats_moment->module~stdlib_stats module~stdlib_stats_moment->module~stdlib_optval module~stdlib_stats_moment->module~stdlib_error module~stdlib_linalg_diag stdlib_linalg_diag module~stdlib_linalg_diag->module~stdlib_linalg module~stdlib_stats_corr stdlib_stats_corr module~stdlib_stats_corr->module~stdlib_linalg module~stdlib_stats_corr->module~stdlib_stats module~stdlib_stats_corr->module~stdlib_optval module~stdlib_stats_corr->module~stdlib_error module~stdlib_stats_var stdlib_stats_var module~stdlib_stats_var->module~stdlib_stats module~stdlib_stats_var->module~stdlib_optval module~stdlib_stats_var->module~stdlib_error module~stdlib_error->module~stdlib_optval module~stdlib_stats_mean stdlib_stats_mean module~stdlib_stats_mean->module~stdlib_stats module~stdlib_stats_mean->module~stdlib_optval module~stdlib_stats_mean->module~stdlib_error module~stdlib_quadrature_trapz stdlib_quadrature_trapz module~stdlib_quadrature_trapz->module~stdlib_quadrature module~stdlib_quadrature_trapz->module~stdlib_error module~estop~2 estop module~estop~2->module~stdlib_error module~estop estop module~estop->module~stdlib_error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_kinds.html"},{"title":"stdlib_ascii – Fortran-lang/stdlib","text":"Used by module~~stdlib_ascii~~UsedByGraph module~stdlib_ascii stdlib_ascii module~stdlib_io stdlib_io module~stdlib_io->module~stdlib_ascii Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ACK BEL BS CAN CR DC1 DC2 DC3 DC4 DEL DLE EM ENQ EOT ESC ETB ETX FF FS GS LF NAK NUL RS SI SO SOH STX SUB SYN TAB US VT digits fullhex_digits hex_digits letters lowercase lowerhex_digits octal_digits uppercase whitespace Functions is_alpha is_alphanum is_ascii is_blank is_control is_digit is_graphical is_hex_digit is_lower is_octal_digit is_printable is_punctuation is_upper is_white to_lower to_upper Variables Type Visibility Attributes Name Initial character(len=1), public, parameter :: ACK = achar(int(z'06')) Acknowledge character(len=1), public, parameter :: BEL = achar(int(z'07')) Bell character(len=1), public, parameter :: BS = achar(int(z'08')) Backspace character(len=1), public, parameter :: CAN = achar(int(z'18')) Cancel character(len=1), public, parameter :: CR = achar(int(z'0D')) Carriage return character(len=1), public, parameter :: DC1 = achar(int(z'11')) Device control 1 character(len=1), public, parameter :: DC2 = achar(int(z'12')) Device control 2 character(len=1), public, parameter :: DC3 = achar(int(z'13')) Device control 3 character(len=1), public, parameter :: DC4 = achar(int(z'14')) Device control 4 character(len=1), public, parameter :: DEL = achar(int(z'7F')) Delete character(len=1), public, parameter :: DLE = achar(int(z'10')) Data link escape character(len=1), public, parameter :: EM = achar(int(z'19')) End of medium character(len=1), public, parameter :: ENQ = achar(int(z'05')) Enquiry character(len=1), public, parameter :: EOT = achar(int(z'04')) End of transmission character(len=1), public, parameter :: ESC = achar(int(z'1B')) Escape character(len=1), public, parameter :: ETB = achar(int(z'17')) End of transmission block character(len=1), public, parameter :: ETX = achar(int(z'03')) End of text character(len=1), public, parameter :: FF = achar(int(z'0C')) NP form feed, new page character(len=1), public, parameter :: FS = achar(int(z'1C')) File separator character(len=1), public, parameter :: GS = achar(int(z'1D')) Group separator character(len=1), public, parameter :: LF = achar(int(z'0A')) NL line feed, new line character(len=1), public, parameter :: NAK = achar(int(z'15')) Negative acknowledge character(len=1), public, parameter :: NUL = achar(int(z'00')) Null character(len=1), public, parameter :: RS = achar(int(z'1E')) Record separator character(len=1), public, parameter :: SI = achar(int(z'0F')) Shift in character(len=1), public, parameter :: SO = achar(int(z'0E')) Shift out character(len=1), public, parameter :: SOH = achar(int(z'01')) Start of heading character(len=1), public, parameter :: STX = achar(int(z'02')) Start of text character(len=1), public, parameter :: SUB = achar(int(z'1A')) Substitute character(len=1), public, parameter :: SYN = achar(int(z'16')) Synchronous idle character(len=1), public, parameter :: TAB = achar(int(z'09')) Horizontal tab character(len=1), public, parameter :: US = achar(int(z'1F')) Unit separator character(len=1), public, parameter :: VT = achar(int(z'0B')) Vertical tab character(len=*), public, parameter :: digits = hex_digits(1:10) 0 .. 9 character(len=*), public, parameter :: fullhex_digits = \"0123456789ABCDEFabcdef\" 0 .. 9A .. Fa .. f character(len=*), public, parameter :: hex_digits = fullhex_digits(1:16) 0 .. 9A .. F character(len=*), public, parameter :: letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" A .. Za .. z character(len=*), public, parameter :: lowercase = letters(27:) a .. z character(len=*), public, parameter :: lowerhex_digits = \"0123456789abcdef\" 0 .. 9a .. f character(len=*), public, parameter :: octal_digits = digits(1:8) 0 .. 7 character(len=*), public, parameter :: uppercase = letters(1:26) A .. Z character(len=*), public, parameter :: whitespace = \" \"//TAB//VT//CR//LF//FF ASCII _whitespace Functions public pure function is_alpha (c) Checks whether c is an ASCII letter (A .. Z, a .. z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_alphanum (c) Checks whether c is a letter or a number (0 .. 9, a .. z, A .. Z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_ascii (c) Checks whether or not c is in the ASCII character set - Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_blank (c) Checks whether or not c is a blank character. That includes the Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_control (c) Checks whether c is a control character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_digit (c) Checks whether c is a digit (0 .. 9). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_graphical (c) Checks whether or not c is a printable character other than the Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_hex_digit (c) Checks whether c is a digit in base 16 (0 .. 9, A .. F, a .. f). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_lower (c) Checks whether c is a lowercase ASCII letter (a .. z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_octal_digit (c) Checks whether c is a digit in base 8 (0 .. 7). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_printable (c) Checks whether or not c is a printable character - including the Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_punctuation (c) Checks whether or not c is a punctuation character. That includes Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_upper (c) Checks whether c is an uppercase ASCII letter (A .. Z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function is_white (c) Checks whether or not c is a whitespace character. That includes the Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public pure function to_lower (c) result(t) Returns the corresponding lowercase letter, if c is an uppercase Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c A character. Return Value character(len=1) public pure function to_upper (c) result(t) Returns the corresponding uppercase letter, if c is a lowercase Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c A character. Return Value character(len=1)","tags":"","loc":"module/stdlib_ascii.html"},{"title":"stdlib_stats_corr – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_linalg stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_corr~~UsesGraph module~stdlib_stats_corr stdlib_stats_corr ieee_arithmetic ieee_arithmetic module~stdlib_stats_corr->ieee_arithmetic module~stdlib_linalg stdlib_linalg module~stdlib_stats_corr->module~stdlib_linalg module~stdlib_error stdlib_error module~stdlib_stats_corr->module~stdlib_error module~stdlib_optval stdlib_optval module~stdlib_stats_corr->module~stdlib_optval module~stdlib_stats stdlib_stats module~stdlib_stats_corr->module~stdlib_stats module~stdlib_kinds stdlib_kinds module~stdlib_linalg->module~stdlib_kinds module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_optval->module~stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_corr.html"},{"title":"stdlib_stats_cov – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_cov~~UsesGraph module~stdlib_stats_cov stdlib_stats_cov ieee_arithmetic ieee_arithmetic module~stdlib_stats_cov->ieee_arithmetic module~stdlib_error stdlib_error module~stdlib_stats_cov->module~stdlib_error module~stdlib_optval stdlib_optval module~stdlib_stats_cov->module~stdlib_optval module~stdlib_stats stdlib_stats module~stdlib_stats_cov->module~stdlib_stats module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_cov.html"},{"title":"stdlib_stats_moment – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_moment~~UsesGraph module~stdlib_stats_moment stdlib_stats_moment ieee_arithmetic ieee_arithmetic module~stdlib_stats_moment->ieee_arithmetic module~stdlib_error stdlib_error module~stdlib_stats_moment->module~stdlib_error module~stdlib_optval stdlib_optval module~stdlib_stats_moment->module~stdlib_optval module~stdlib_stats stdlib_stats module~stdlib_stats_moment->module~stdlib_stats module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_moment.html"},{"title":"stdlib_quadrature_simps – Fortran-lang/stdlib","text":"Uses stdlib_error Ancestors: stdlib_quadrature module~~stdlib_quadrature_simps~~UsesGraph module~stdlib_quadrature_simps stdlib_quadrature_simps module~stdlib_quadrature stdlib_quadrature module~stdlib_quadrature_simps->module~stdlib_quadrature module~stdlib_error stdlib_error module~stdlib_quadrature_simps->module~stdlib_error module~stdlib_kinds stdlib_kinds module~stdlib_quadrature->module~stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_optval stdlib_optval module~stdlib_error->module~stdlib_optval module~stdlib_kinds->iso_fortran_env module~stdlib_optval->module~stdlib_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_quadrature_simps.html"},{"title":"stdlib_linalg_diag – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_linalg module~~stdlib_linalg_diag~~UsesGraph module~stdlib_linalg_diag stdlib_linalg_diag module~stdlib_linalg stdlib_linalg module~stdlib_linalg_diag->module~stdlib_linalg module~stdlib_kinds stdlib_kinds module~stdlib_linalg->module~stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_linalg_diag.html"},{"title":"stdlib_stats_mean – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_mean~~UsesGraph module~stdlib_stats_mean stdlib_stats_mean ieee_arithmetic ieee_arithmetic module~stdlib_stats_mean->ieee_arithmetic module~stdlib_error stdlib_error module~stdlib_stats_mean->module~stdlib_error module~stdlib_optval stdlib_optval module~stdlib_stats_mean->module~stdlib_optval module~stdlib_stats stdlib_stats module~stdlib_stats_mean->module~stdlib_stats module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_mean.html"},{"title":"estop – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_error module~~estop~~UsesGraph module~estop estop module~stdlib_error stdlib_error module~estop->module~stdlib_error iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_optval stdlib_optval module~stdlib_error->module~stdlib_optval module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/estop.html"},{"title":"stdlib_quadrature_trapz – Fortran-lang/stdlib","text":"Uses stdlib_error Ancestors: stdlib_quadrature module~~stdlib_quadrature_trapz~~UsesGraph module~stdlib_quadrature_trapz stdlib_quadrature_trapz module~stdlib_quadrature stdlib_quadrature module~stdlib_quadrature_trapz->module~stdlib_quadrature module~stdlib_error stdlib_error module~stdlib_quadrature_trapz->module~stdlib_error module~stdlib_kinds stdlib_kinds module~stdlib_quadrature->module~stdlib_kinds iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_optval stdlib_optval module~stdlib_error->module~stdlib_optval module~stdlib_kinds->iso_fortran_env module~stdlib_optval->module~stdlib_kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_quadrature_trapz.html"},{"title":"stdlib_stats_var – Fortran-lang/stdlib","text":"Uses ieee_arithmetic stdlib_error stdlib_optval Ancestors: stdlib_stats module~~stdlib_stats_var~~UsesGraph module~stdlib_stats_var stdlib_stats_var ieee_arithmetic ieee_arithmetic module~stdlib_stats_var->ieee_arithmetic module~stdlib_error stdlib_error module~stdlib_stats_var->module~stdlib_error module~stdlib_optval stdlib_optval module~stdlib_stats_var->module~stdlib_optval module~stdlib_stats stdlib_stats module~stdlib_stats_var->module~stdlib_stats module~stdlib_error->module~stdlib_optval iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_stats->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/stdlib_stats_var.html"},{"title":"estop – Fortran-lang/stdlib","text":"Uses Ancestors: stdlib_error module~~estop~2~~UsesGraph module~estop~2 estop module~stdlib_error stdlib_error module~estop~2->module~stdlib_error iso_fortran_env iso_fortran_env module~stdlib_error->iso_fortran_env module~stdlib_optval stdlib_optval module~stdlib_error->module~stdlib_optval module~stdlib_kinds stdlib_kinds module~stdlib_optval->module~stdlib_kinds module~stdlib_kinds->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"module/estop~2.html"},{"title":"Contributing and specs – Fortran-lang/stdlib","text":"Warning This page is currently under construction! Todo Improve the title of this FORD \"pages\" section, and\nimprove the organization of pages\nto separate end-user, high-level documentation and examples from developer documentation and specs.","tags":"","loc":"page//index.html"},{"title":"Fortran stdlib License (MIT) – Fortran-lang/stdlib","text":"MIT License Copyright (c) 2019 Fortran stdlib developers Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","tags":"","loc":"page/./License.html"},{"title":"Contributing – Fortran-lang/stdlib","text":"This page aims to prodive information that are useful for stdlib contributors.\nIssues can be reported on GitHub .","tags":"","loc":"page/contributing/index.html"},{"title":"Contributor Code of Conduct – Fortran-lang/stdlib","text":"Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to make participation in our project and\nour community a harassment-free experience for everyone, regardless of age,\nbody size, disability, ethnicity, gender identity and expression, level of\nexperience, nationality, personal appearance, race, religion, or sexual\nidentity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment\ninclude: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or\nadvances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic\n  address, without explicit permission Other conduct which could reasonably be considered inappropriate in a\n  professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may\nbe further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing or otherwise unacceptable behavior may be\nreported by contacting one of the project maintainers at caomaco@gmail.com or \nondrej@certik.us. All complaints will be reviewed and investigated and will\nresult in a response that is deemed necessary and appropriate to the\ncircumstances. The project team is obligated to maintain confidentiality with\nregard to the reporter of an incident. Further details of specific enforcement\npolicies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4,\navailable at https://contributor-covenant.org/version/1/4","tags":"","loc":"page/contributing/CodeOfConduct.html"},{"title":"Style Guide – Fortran-lang/stdlib","text":"Note This is a living document.\nYou are welcome to propose changes to this workflow by opening an issue . Fortran stdlib Style Guide Use (modern) standard Fortran File naming conventions Indentation & whitespace Variable and procedure naming Attributes End  block closing statements Document public API code with FORD Fortran stdlib Style Guide Adopting a consistent style can improve code legibility through the choice of good naming conventions.\nIn addition, style checks will be run during CI to flag any severe non-conformance.\nThis allows code review discussions to focus on semantics and substance rather than pedantry.\nConsistent whitespace usage, and not polluting line endings with trailing white space makes git diff s considerably more legible.\nThis style guide is a living document and proposed changes may be adopted after discussing them and coming to a consensus. Use (modern) standard Fortran Do not use obsolescent or deleted language features\n  E.g., common , pause , entry , arithmetic if and computed goto Do not use vendor extensions in the form of non-standard syntax and vendor supplied intrinsic procedures\n  E.g., real*8 or etime() File naming conventions Source files should contain at most one program , module , or submodule The filename should match the program or module name and have the file extension .f90 or .F90 if preprocessing is required If the interface and implementation is split using submodules the implementation submodule file should have the same name as the\n  interface (parent) module but end in _implementation E.g., string_class.f90 and string_class_implementation.f90 Tests should be added in the tests subdirectory and have the same name as the module they are testing with the test_ prefix\n  added\n  E.g., string_class.f90 and tests/test_string_class.f90 Indentation & whitespace By setting and following a convention for indentation and whitespace, code reviews and git-diffs can\nfocus on the semantics of the proposed changes rather than style and formatting. The body of every Fortran construct should be indented by four (4) spaces Line length should be limited to 80 characters and must not exceed 132 Please do not use Tab characters for indentation Please remove trailing white space before committing code Variable and procedure naming Variable and procedure names, as well as Fortran keywords, should be written in lowercase Variable and procedure names should be made up of one or more full words separated by an underscore,\n  for example has_failed is preferred over hasfailed Where conventional and appropriate shortening of a word is used then the underscore may be omitted,\n  for example linspace is preferred over lin_space Attributes Always specify intent for dummy arguments. Don't use dimension attribute to declare arrays because it is less verbose.\n  Use this: real, allocatable :: a(:), b(:,:) instead of: real, dimension(:), allocatable :: a real, dimension(:,:), allocatable :: b When defining many arrays of the same dimension, dimension can be used as an exception if it makes the code less verbose. If the optional attribute is used to declare a dummy argument, it should follow the intent attribute. End block closing statements Fortran allows certain block constructs or scopes to include the name of the program unit in the end statement.\nThe convention adopted herein is to include procedure names, module names and program names in the end statement,\nunless the closing statement can reasonably be expected to be on the same screen or page, within about 25 lines. Document public API code with FORD Documentation strings should be provided for all public and protected entities and their arguments or parameters.\nThis is currently accomplished using the FORD tool .\nFor help writing FORD style documentation please see the FORD wiki .\nThe following two sections are most relevant for contributing new code: Writing Documentation Documentation Meta Data Limitations To write the \"spec\" (specification) for a new proposal, please place it in the FORD \"pages\" directory at doc/specs/ .\nTo get help please see the \"Writing Pages\" and \"Writing Documentation\" pages\non the FORD wiki .","tags":"","loc":"page/contributing/StyleGuide.html"},{"title":"Workflow for Contributors – Fortran-lang/stdlib","text":"Note This is a living document.\nYou are welcome to propose changes to this workflow by opening an issue . Workflow for the Fortran stdlib contributors This document describes our current workflow. We welcome everyone and anyone to participate and propose additions to stdlib.\nIt is okay if you do not have experience for specification or implementation,\nbut have an idea for stdlib. If the idea is popular among the community, more\nexperienced contributors will help it through all 5 steps. Idea : You have an idea or a proposal. Open an issue to discuss it. This\n   is on the level of \"is there interest in having image reader/writer\n   functions in stdlib?\" The goal of this step is to find out if the community\n   is interested in having this functionality as part of stdlib. API : When there seems to be significant interest in the proposal (vast\n   majority of participants think it is a good idea), move on to discuss the\n   specific API. It's OK to propose the API off the bat if you already have an\n   idea for it. This step is exploratory and its goal is to find out what the\n   API should look and feel like. Specification : Discuss the API and iterate. When there is vast majority\n   approval for the API, move on to implement it and submit a PR. Small PRs are\n   always better than large.  It is OK to implement only a few functions of a\n   new module, and continue work on the others in a later PR. All new\n   functionality goes into an \"experimental\" namespace\n   ( version: experimental ). As part of the PR, when submitting a new\n   public facing API, please provide the initial draft of the specification\n   document as well as the initial reference implementation of this\n   specification.  The specification is a document that describes the API and\n   the functionality, so that anyone can use it to create an implementation\n   from scratch without looking at stdlib . The stdlib library then provides\n   the reference implementation. Implementation in experimental: When opening a PR, request reviews from\n   one or more people that are most relevant to it. These are likely to be\n   people involved in prior steps of the workflow. Other contributors (not\n   explicitly invited) are encouraged to provide reviews and suggestions as\n   well. Iterate until all (or most) participants are on the same page.\n   A merge is permitted if there are unit tests for a majority of the possible\n   calling scenarios (with or without optional arguments, with arguments that\n   trigger an error) and if there is vast majority approval of the PR. Release : Moving from experimental to release. The experimental\n   \"namespace\" contains new functionality together with its specification. In\n   order to move from experimental to release, the specification document must\n   be approved by the wide community and the standards committee (informally).\n   If that happens, it has now been blessed for broad use and we can move the\n   code into the main section of stdlib , and the particular specification\n   document becomes part of the Fortran Standard Library. Note: the general term \"vast majority\" above means at least 80%, but ultimately\nit is left to our best judgement to ensure that the community agrees that each\nPR and proposal was approved by \"vast majority\". You are welcome to propose changes to this workflow by opening an issue .","tags":"","loc":"page/contributing/Workflow.html"},{"title":"Specifications (specs) – Fortran-lang/stdlib","text":"Fortran stdlib Specifications (specs) This is and index/directory of the specifications (specs) for each new module/feature as described in the workflow document . Fortran stdlib Specifications (specs) Experimental Features & Modules Missing specs Released/Stable Features & Modules Experimental Features & Modules error - Catching and handling errors IO - Input/output helper & convenience linalg - Linear Algebra optval - Fallback value for optional arguments quadrature - Numerical integration stats - Descriptive Statistics Missing specs ascii kinds Released/Stable Features & Modules (None yet)","tags":"","loc":"page/specs/index.html"},{"title":"error – Fortran-lang/stdlib","text":"Catching and handling errors Catching and handling errors check - Checks the value of a logical condition Status Description Syntax Arguments Return value Examples error_stop - aborts the program Status Description Syntax Arguments Output Examples check - Checks the value of a logical condition Status Experimental Description Checks the value of a logical condition. Syntax call check (condition, msg, code, warn) Arguments condition : Shall be a scalar of type logical . msg (optional): Shall be a character expression containing the message to be printed to stderr . The default msg is 'Check failed.'. code (optional): Shall be a scalar of type integer . The default code is 1 . warn (optional): Shall be a scalar of type logical . The default warn is .true. . Return value If condition is .false ., and: no other arguments are provided, this subroutine stops the program with the default message and exit code 1; msg is provided, this subroutine stops the program and it prints the value of msg ; code is provided, this subroutine stops the program with the given exit code; warn is provided and warn is .true. , this subroutine doesn't stop the program and prints the message. Examples program demo_check1 use stdlib_error , only : check implicit none integer :: a = 1 ! If a /= 5, stops the program with exit code 1 and prints 'Check failed.' call check ( a == 5 ) end program demo_check1 program demo_check2 use stdlib_error , only : check implicit none integer :: a = 1 ! If a /= 5, stops the program with exit code 1 and prints  'a == 5 failed.' call check ( a == 5 , msg = 'a == 5 failed.' ) end program demo_check2 program demo_check3 use stdlib_error , only : check implicit none integer :: a = 1 ! If a /= 5,  prints 'a == 5 failed.', but doesn't stop the program. call check ( a == 5 , msg = 'a == 5 failed.' , warn = . true .) end program demo_check2 program demo_check3 use stdlib_error , only : check implicit none integer :: a = 1 ! If a /= 5, stops the program with exit code 77 and prints 'a == 5 failed.' call check ( a == 5 , msg = 'a == 5 failed.' , code = 77 ) end program demo_check3 error_stop - aborts the program Status Experimental Description Aborts the program with a message and a nonzero exit code. Syntax call error_stop (msg, code) Arguments msg : Shall be a character expression containing the message to be printed to stderr . code (optional): Shall be a scalar of type integer to be returned as exit code. Output Aborts the program with printing the message msg to stderr and a nonzero exit code. The nonzero exit code is equal to code if provided, and 1 otherwise. Examples Without error code: program demo_error_stop1 use stdlib_error , only : error_stop implicit none call error_stop ( \"Invalid argument\" ) end program demo_error_stop1 With error code: program demo_error_stop2 use stdlib_error , only : error_stop implicit none call error_stop ( \"Invalid argument\" , code = 123 ) end program demo_error_stop2","tags":"","loc":"page/specs/stdlib_error.html"},{"title":"IO – Fortran-lang/stdlib","text":"IO IO loadtxt - load a 2D array from a text file Status Description Syntax Arguments Return value Example open - open a file Status Description Syntax Arguments Return value Example savetxt - save a 2D array into a text file Status Description Syntax Arguments Output Example loadtxt - load a 2D array from a text file Status Experimental Description Loads a rank-2 array from a text file. Syntax call loadtxt (filename, array) Arguments filename : Shall be  a character expression containing the file name from which to load the rank-2 array . array : Shall be an allocatable rank-2 array of type real , complex or integer . Return value Returns an allocated rank-2 array with the content of filename . Example program demo_loadtxt use stdlib_io , only : loadtxt implicit none real , allocatable :: x (:,:) call loadtxt ( 'example.dat' , x ) end program demo_loadtxt open - open a file Status Experimental Description Returns the unit number of a file opened to read, to write, or to read and write. The file might be a text file or a binary file. All files are opened using a streamed access. Syntax u = open (filename [, mode] [, iostat]) Arguments filename : Shall be a character expression containing the name of the file to open. mode (optional): Shall be a character expression containing characters describing the way in which the file will be used. The available modes are: Character Meaning 'r' open for reading (default) 'w' open for writing, truncating the file first 'x' open for exclusive creation, failing if the file already exists 'a' open for writing, appending to the end of the file if it exists '+' open for updating (reading and writing) 'b' binary mode 't' text mode (default) The default mode is 'rt' (i.e. open for reading a text file). The mode may include one of the four different methods for opening a file (i.e., 'r' , 'w' , 'x' , and 'a' ). These four methods can be associated with the character '+' to open the file for updating. In addition, it can be specified if the file should be handled as a binary file ( 'b' ) or a text file ( 't' ). iostat (optional): Shall be a scalar of type integer that receives the error status of open , if provided. If no error exists, iostat is zero. u : Shall be a scalar of type integer that specifies the unit number associated with the file filename . Return value The result is a scalar of type integer . Example program demo_open use stdlib_io , only : open implicit none integer :: u u = open ( 'example.dat' , 'wt' ) write ( u , '(a)' ) 'This is an example for open' close ( u ) end program demo_open savetxt - save a 2D array into a text file Status Experimental Description Saves a rank-2 array into a text file. Syntax call savetxt (filename, array) Arguments filename : Shall be  a character expression containing the name of the file that will contain the 2D array . array : Shall be a rank-2 array of type real , complex or integer . Output Provides a text file called filename that contains the rank-2 array . Example program demo_savetxt use stdlib_io , only : savetxt implicit none real :: x ( 3 , 2 ) = 1 call savetxt ( 'example.dat' , x ) end program demo_savetxt","tags":"","loc":"page/specs/stdlib_io.html"},{"title":"linalg – Fortran-lang/stdlib","text":"Linear Algebra Linear Algebra diag - Create a diagonal array or extract the diagonal elements of an array Status Description Syntax Arguments Return value Example eye - Construct the identity matrix Status Description Syntax Arguments Return value Example trace - Trace of a matrix Status Description Syntax Arguments Return value Example diag - Create a diagonal array or extract the diagonal elements of an array Status Experimental Description Create a diagonal array or extract the diagonal elements of an array Syntax d = diag (a [, k]) Arguments a : Shall be a rank-1 or or rank-2 array. If a is a rank-1 array (i.e. a vector) then diag returns a rank-2 array with the elements of a on the diagonal. If a is a rank-2 array (i.e. a matrix) then diag returns a rank-1 array of the diagonal elements. k (optional): Shall be a scalar of type integer and specifies the diagonal. The default k = 0 represents the main diagonal, k > 0 are diagonals above the main diagonal, k < 0 are diagonals below the main diagonal. Return value Returns a diagonal array or a vector with the extracted diagonal elements. Example program demo_diag1 use stdlib_linalg , only : diag implicit none real , allocatable :: A (:,:) integer :: i A = diag ([( 1 , i = 1 , 10 )]) ! creates a 10 by 10 identity matrix end program demo_diag1 program demo_diag2 use stdlib_linalg , only : diag implicit none real :: v (:) real , allocatable :: A (:,:) integer :: i v = [ 1 , 2 , 3 , 4 , 5 ] A = diag ( v ) ! creates a 5 by 5 matrix with elements of v on the diagonal end program demo_diag2 program demo_diag3 use stdlib_linalg , only : diag implicit none integer , parameter :: n = 10 real :: c ( n ), ul ( n - 1 ) real :: A ( n , n ) integer :: i c = 2 ul = - 1 A = diag ( ul , - 1 ) + diag ( c ) + diag ( ul , 1 ) ! Gil Strang's favorite matrix end program demo_diag3 program demo_diag4 use stdlib_linalg , only : diag implicit none integer , parameter :: n = 12 real :: A ( n , n ) real :: v ( n ) integer :: i call random_number ( A ) v = diag ( A ) ! v contains diagonal elements of A end program demo_diag4 program demo_diag5 use stdlib_linalg , only : diag implicit none integer , parameter :: n = 3 real :: A ( n , n ) real , allocatable :: v (:) integer :: i A = reshape ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ],[ n , n ]) v = diag ( A , - 1 ) ! v is [2,6] v = diag ( A , 1 ) ! v is [4,8] end program demo_diag5 eye - Construct the identity matrix Status Experimental Description Construct the identity matrix Syntax I = eye (n) Arguments n : Shall be a scalar of default type integer . Return value Returns the identity matrix, i.e. a square matrix with ones on the main diagonal and zeros elsewhere. The return value is of type integer(int8) . Example program demo_eye1 use stdlib_linalg , only : eye implicit none real :: a ( 3 , 3 ) A = eye ( 3 ) end program demo_eye1 program demo_eye2 use stdlib_linalg , only : eye , diag implicit none print * , all ( eye ( 4 ) == diag ([ 1 , 1 , 1 , 1 ])) ! prints .true. end program demo_eye2 trace - Trace of a matrix Status Experimental Description Trace of a matrix (rank-2 array) Syntax result = [stdlib_linalg(module):trace(interface)](A) Arguments A : Shall be a rank-2 array. If A is not square, then trace(A) will return the sum of diagonal values from the square sub-section of A . Return value Returns the trace of the matrix, i.e. the sum of diagonal elements. Example program demo_trace use stdlib_linalg , only : trace implicit none real :: A ( 3 , 3 ) A = reshape ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ],[ 3 , 3 ]) print * , trace ( A ) ! 1 + 5 + 9 end program demo_trace","tags":"","loc":"page/specs/stdlib_linalg.html"},{"title":"optval – Fortran-lang/stdlib","text":"Default values for optional arguments Default values for optional arguments optval - fallback value for optional arguments Status Description Syntax Arguments Return value Example optval - fallback value for optional arguments Status Experimental Description Returns x if it is present, otherwise default . This function is intended to be called in a procedure with one or more optional arguments, in order to conveniently fall back to a default value if an optional argument is not present. Syntax result = optval (x, default) Arguments x : Shall be of type integer , real , complex , or logical , or a scalar of type character . default : Shall have the same type, kind, and rank as x . Return value If x is present, the result is x , otherwise the result is default . Example program demo_optval use stdlib_optval , only : optval implicit none print * , root ( 6 4.0 ) ! 8.0 print * , root ( 6 4.0 , 3 ) ! 4.0 contains real function root ( x , n ) real , intent ( in ) :: x integer , intent ( in ), optional :: n root = x ** ( 1.0 / optval ( n , 2 )) end function root end program demo_optval","tags":"","loc":"page/specs/stdlib_optval.html"},{"title":"quadrature – Fortran-lang/stdlib","text":"Numerical integration Numerical integration trapz - integrate sampled values using trapezoidal rule Status Description Syntax Arguments Return value Example trapz_weights - trapezoidal rule weights for given abscissas Status Description Syntax Arguments Return value Example simps - integrate sampled values using Simpson's rule Status Description Syntax Arguments Return value Example simps_weights - Simpson's rule weights for given abscissas Status Description Syntax Arguments Return value Example trapz - integrate sampled values using trapezoidal rule Status Experimental Description Returns the trapezoidal rule integral of an array y representing discrete samples of a function. The integral is computed assuming either equidistant abscissas with spacing dx or arbitary abscissas x . Syntax result = trapz (y, x) result = trapz (y, dx) Arguments y : Shall be a rank-one array of type real . x : Shall be a rank-one array of type real having the same kind and size as y . dx : Shall be a scalar of type real having the same kind as y . Return value The result is a scalar of type real having the same kind as y . If the size of y is zero or one, the result is zero. Example program demo_trapz use stdlib_quadrature , only : trapz implicit none real :: x ( 5 ) = [ 0. , 1. , 2. , 3. , 4. ] real :: y ( 5 ) = x ** 2 print * , trapz ( y , x ) ! 22.0 print * , trapz ( y , 0.5 ) ! 11.0 end program demo_trapz trapz_weights - trapezoidal rule weights for given abscissas Status Experimental Description Given an array of abscissas x , computes the array of weights w such that if y represented function values tabulated at x , then sum(w*y) produces a trapezoidal rule approximation to the integral. Syntax result = trapz_weights (x) Arguments x : Shall be a rank-one array of type real . Return value The result is a real array with the same size and kind as x . If the size of x is one, then the sole element of the result is zero. Example program demo_trapz_weights use stdlib_quadrature , only : trapz_weights implicit none real :: x ( 5 ) = [ 0. , 1. , 2. , 3. , 4. ] real :: y ( 5 ) = x ** 2 real :: w ( 5 ) w = trapz_weights ( x ) print * , sum ( w * y ) ! 22.0 end program demo_trapz_weights simps - integrate sampled values using Simpson's rule Status Experimental Description Returns the Simpson's rule integral of an array y representing discrete samples of a function. The integral is computed assuming either equidistant abscissas with spacing dx or arbitary abscissas x . Simpson's ordinary (\"1/3\") rule is used for odd-length arrays. For even-length arrays, Simpson's 3/8 rule is also utilized in a way that depends on the value of even . If even is negative (positive), the 3/8 rule is used at the beginning (end) of the array. If even is zero or not present, the result is as if the 3/8 rule were first used at the beginning of the array, then at the end of the array, and these two results were averaged. Syntax result = simps (y, x [, even]) result = simps (y, dx [, even]) Arguments y : Shall be a rank-one array of type real . x : Shall be a rank-one array of type real having the same kind and size as y . dx : Shall be a scalar of type real having the same kind as y . even : (Optional) Shall be a default-kind integer . Return value The result is a scalar of type real having the same kind as y . If the size of y is zero or one, the result is zero. If the size of y is two, the result is the same as if trapz had been called instead. Example program demo_simps use stdlib_quadrature , only : simps implicit none real :: x ( 5 ) = [ 0. , 1. , 2. , 3. , 4. ] real :: y ( 5 ) = 3. * x ** 2 print * , simps ( y , x ) ! 64.0 print * , simps ( y , 0.5 ) ! 32.0 end program demo_simps simps_weights - Simpson's rule weights for given abscissas Status Experimental Description Given an array of abscissas x , computes the array of weights w such that if y represented function values tabulated at x , then sum(w*y) produces a Simpson's rule approximation to the integral. Simpson's ordinary (\"1/3\") rule is used for odd-length arrays. For even-length arrays, Simpson's 3/8 rule is also utilized in a way that depends on the value of even . If even is negative (positive), the 3/8 rule is used at the beginning (end) of the array and the 1/3 rule used elsewhere. If even is zero or not present, the result is as if the 3/8 rule were first used at the beginning of the array, then at the end of the array, and then these two results were averaged. Syntax result = simps_weights (x [, even]) Arguments x : Shall be a rank-one array of type real . even : (Optional) Shall be a default-kind integer . Return value The result is a real array with the same size and kind as x . If the size of x is one, then the sole element of the result is zero. If the size of x is two, then the result is the same as if trapz_weights had been called instead. Example program demo_simps_weights use stdlib_quadrature , only : simps_weights implicit none real :: x ( 5 ) = [ 0. , 1. , 2. , 3. , 4. ] real :: y ( 5 ) = 3. * x ** 2 real :: w ( 5 ) w = simps_weights ( x ) print * , sum ( w * y ) ! 64.0 end program demo_simps_weights","tags":"","loc":"page/specs/stdlib_quadrature.html"},{"title":"stats – Fortran-lang/stdlib","text":"Descriptive statistics Descriptive statistics corr - Pearson correlation of array elements Status Description Syntax Arguments Return value Example cov - covariance of array elements Status Description Syntax Arguments Return value Example mean - mean of array elements Status Description Syntax Arguments Return value Example moment - central moments of array elements Status Description Syntax Arguments Return value Example var - variance of array elements Status Description Syntax Arguments Return value Example corr - Pearson correlation of array elements Status Experimental Description Returns the Pearson correlation of the elements of array along dimension dim if the corresponding element in mask is true . The Pearson correlation between two rows (or columns), say x and y , of array is defined as: corr(x, y) = cov(x, y) / sqrt( var(x) * var(y)) Syntax result = corr (array, dim [, mask]) Arguments array : Shall be a rank-1 or a rank-2 array of type integer , real , or complex . dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . Return value If array is of rank 1 and of type real or complex , the result is of type real and has the same kind as array .\nIf array is of rank 2 and of type real or complex , the result is of the same type and kind as array .\nIf array is of type integer , the result is of type real(dp) . If array is of rank 1 and of size larger than 1, a scalar equal to 1 is returned. Otherwise, IEEE NaN is returned.\nIf array is of rank 2, a rank-2 array  with the corresponding correlations is returned. If mask is specified, the result is the Pearson correlation of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example program demo_corr use stdlib_stats , only : corr implicit none real :: x ( 1 : 6 ) = [ 1. , 2. , 3. , 4. , 5. , 6. ] real :: y ( 1 : 2 , 1 : 3 ) = reshape ([ - 1. , 4 0. , - 3. , 4. , 1 0. , 6. ], [ 2 , 3 ]) print * , corr ( x , 1 ) !returns 1. print * , corr ( y , 2 ) !returns reshape([ 1., -.32480, -.32480, 1. ], [ 2, 3]) end program demo_corr cov - covariance of array elements Status Experimental Description Returns the covariance of the elements of array along dimension dim if the corresponding element in mask is true . Per default, the covariance is defined as: cov(array) = 1/(n-1) sum_i (array(i) - mean(array) * (array(i) - mean(array))) where n is the number of elements. The scaling can be changed with the logical argument corrected . If corrected is .false. , then the sum is scaled with n , otherwise with n-1 . Syntax result = cov (array, dim [, mask [, corrected]]) Arguments array : Shall be a rank-1 or a rank-2 array of type integer , real , or complex . dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . corrected (optional): Shall be a scalar of type logical . If corrected is .true. (default value), the sum is scaled with n-1 . If corrected is .false. , then the sum is scaled with n . Return value If array is of rank 1 and of type real or complex , the result is of type real corresponding to the type of array .\nIf array is of rank 2 and of type real or complex , the result is of the same type as array .\nIf array is of type integer , the result is of type real(dp) . If array is of rank 1, a scalar with the covariance (that is the variance) of all elements in array is returned.\nIf array is of rank 2, a rank-2 array is returned. If mask is specified, the result is the covariance of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example program demo_cov use stdlib_stats , only : cov implicit none real :: x ( 1 : 6 ) = [ 1. , 2. , 3. , 4. , 5. , 6. ] real :: y ( 1 : 2 , 1 : 3 ) = reshape ([ 1. , 2. , 3. , 4. , 5. , 6. ], [ 2 , 3 ]) print * , cov ( x , 1 ) !returns 3.5 print * , cov ( x , 1 , corrected = . false .) !returns 2.9167 print * , cov ( y , 1 ) !returns a square matrix of size 3 with all elements equal to 0.5 end program demo_cov mean - mean of array elements Status Experimental Description Returns the mean of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . Syntax result = mean (array [, mask]) result = mean (array, dim [, mask]) Arguments array : Shall be an array of type integer , real , or complex . dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . Return value If array is of type real or complex , the result is of the same type as array .\nIf array is of type integer , the result is of type real(dp) . If dim is absent, a scalar with the mean of all elements in array is returned. Otherwise, an array of rank n-1 , where n equals the rank of array , and a shape similar to that of array with dimension dim dropped is returned. If mask is specified, the result is the mean of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example program demo_mean use stdlib_stats , only : mean implicit none real :: x ( 1 : 6 ) = [ 1. , 2. , 3. , 4. , 5. , 6. ] real :: y ( 1 : 2 , 1 : 3 ) = reshape ([ 1. , 2. , 3. , 4. , 5. , 6. ], [ 2 , 3 ]) print * , mean ( x ) !returns 3.5 print * , mean ( y ) !returns 3.5 print * , mean ( y , 1 ) !returns [ 1.5, 3.5, 5.5 ] print * , mean ( y , 1 , y > 3. ) !returns [ NaN, 4.0, 5.5 ] end program demo_mean moment - central moments of array elements Status Experimental Description Returns the k -th order central moment of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . If a scalar or an array center is provided, the function returns the k -th order moment about 'center', of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . The k -th order central moment is defined as : moment(array) = 1/n sum_i (array(i) - mean(array))&#94;k where n is the number of elements. The k -th order moment about center is defined as : moment(array) = 1/n sum_i (array(i) - center)&#94;k Syntax result = moment (array, order [, center [, mask]]) result = moment (array, order, dim [, center [, mask]]) Arguments array : Shall be an array of type integer , real , or complex . order : Shall be an scalar of type integer . dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . center (optional): Shall be a scalar of the same type of result if dim is not provided. If dim is provided, center shall be a scalar or an array (with a shape similar to that of array with dimension dim dropped) of the same type of result . mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . Return value If array is of type real or complex , the result is of the same type as array .\nIf array is of type integer , the result is of type real(dp) . If dim is absent, a scalar with the k -th (central) moment of all elements in array is returned. Otherwise, an array of rank n-1 , where n equals the rank of array , and a shape similar to that of array with dimension dim dropped is returned. If mask is specified, the result is the k -th  (central) moment of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . Example program demo_moment use stdlib_stats , only : moment implicit none real :: x ( 1 : 6 ) = [ 1. , 2. , 3. , 4. , 5. , 6. ] real :: y ( 1 : 2 , 1 : 3 ) = reshape ([ 1. , 2. , 3. , 4. , 5. , 6. ], [ 2 , 3 ]) print * , moment ( x , 2 ) !returns 2.9167 print * , moment ( y , 2 ) !returns 2.9167 print * , moment ( y , 2 , 1 ) !returns [0.25, 0.25, 0.25] print * , moment ( y , 2 , 1 , mask = ( y > 3. )) !returns [NaN, 0., 0.25] print * , moment ( x , 2 , center = 0. ) !returns 15.1667 print * , moment ( y , 1 , 1 , center = 0. ) !returns [1.5, 3.5, 5.5] end program demo_moment var - variance of array elements Status Experimental Description Returns the variance of all the elements of array , or of the elements of array along dimension dim if provided, and if the corresponding element in mask is true . Per default, the variance is defined as the best unbiased estimator and is computed as: var(array) = 1/(n-1) sum_i (array(i) - mean(array))&#94;2 where n is the number of elements. The use of the term n-1 for scaling is called Bessel 's correction. The scaling can be changed with the logical argument corrected . If corrected is .false. , then the sum is scaled with n , otherwise with n-1 . Syntax result = var (array [, mask [, corrected]]) result = var (array, dim [, mask [, corrected]]) Arguments array : Shall be an array of type integer , real , or complex . dim : Shall be a scalar of type integer with a value in the range from 1 to n , where n is the rank of array . mask (optional): Shall be of type logical and either a scalar or an array of the same shape as array . corrected (optional): Shall be a scalar of type logical . If corrected is .true. (default value), the sum is scaled with n-1 . If corrected is .false. , then the sum is scaled with n . Return value If array is of type real or complex , the result is of type real corresponding to the type of array .\nIf array is of type integer , the result is of type real(dp) . If dim is absent, a scalar with the variance of all elements in array is returned. Otherwise, an array of rank n-1 , where n equals the rank of array , and a shape similar to that of array with dimension dim dropped is returned. If mask is specified, the result is the variance of all elements of array corresponding to true elements of mask . If every element of mask is false , the result is IEEE NaN . If the variance is computed with only one single element, then the result is IEEE NaN if corrected is .true. and is 0. if corrected is .false. . Example program demo_var use stdlib_stats , only : var implicit none real :: x ( 1 : 6 ) = [ 1. , 2. , 3. , 4. , 5. , 6. ] real :: y ( 1 : 2 , 1 : 3 ) = reshape ([ 1. , 2. , 3. , 4. , 5. , 6. ], [ 2 , 3 ]) print * , var ( x ) !returns 3.5 print * , var ( x , corrected = . false .) !returns 2.9167 print * , var ( y ) !returns 3.5 print * , var ( y , 1 ) !returns [0.5, 0.5, 0.5] print * , var ( y , 1 , y > 3. ) !returns [NaN, NaN, 0.5] print * , var ( y , 1 , y > 3. , corrected = . false .) !returns [NaN, 0., 0.25] end program demo_var","tags":"","loc":"page/specs/stdlib_stats.html"}]}